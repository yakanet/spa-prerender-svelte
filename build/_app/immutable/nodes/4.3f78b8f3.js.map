{"version":3,"file":"4.3f78b8f3.js","sources":["../../../../../../node_modules/.pnpm/svelte@4.2.0/node_modules/svelte/src/runtime/internal/each.js","../../../../../../node_modules/.pnpm/svelte@4.2.0/node_modules/svelte/src/runtime/internal/spread.js","../../../../../../src/lib/client/restaurants.ts","../../../../../../node_modules/.pnpm/fuse.js@6.6.2/node_modules/fuse.js/dist/fuse.esm.js","../../../../../../node_modules/.pnpm/dequal@2.0.3/node_modules/dequal/dist/index.mjs","../../../../../../node_modules/.pnpm/@melt-ui+svelte@0.41.3_svelte@4.2.0/node_modules/@melt-ui/svelte/dist/internal/helpers/array.js","../../../../../../node_modules/.pnpm/@melt-ui+svelte@0.41.3_svelte@4.2.0/node_modules/@melt-ui/svelte/dist/internal/helpers/store/lightable.js","../../../../../../node_modules/.pnpm/@melt-ui+svelte@0.41.3_svelte@4.2.0/node_modules/@melt-ui/svelte/dist/internal/helpers/builder.js","../../../../../../node_modules/.pnpm/@melt-ui+svelte@0.41.3_svelte@4.2.0/node_modules/@melt-ui/svelte/dist/internal/helpers/is.js","../../../../../../node_modules/.pnpm/@melt-ui+svelte@0.41.3_svelte@4.2.0/node_modules/@melt-ui/svelte/dist/internal/helpers/callbacks.js","../../../../../../node_modules/.pnpm/@melt-ui+svelte@0.41.3_svelte@4.2.0/node_modules/@melt-ui/svelte/dist/internal/helpers/event.js","../../../../../../node_modules/.pnpm/@melt-ui+svelte@0.41.3_svelte@4.2.0/node_modules/@melt-ui/svelte/dist/internal/helpers/highlight.js","../../../../../../node_modules/.pnpm/@melt-ui+svelte@0.41.3_svelte@4.2.0/node_modules/@melt-ui/svelte/dist/internal/helpers/list.js","../../../../../../node_modules/.pnpm/@melt-ui+svelte@0.41.3_svelte@4.2.0/node_modules/@melt-ui/svelte/dist/internal/helpers/object.js","../../../../../../node_modules/.pnpm/@melt-ui+svelte@0.41.3_svelte@4.2.0/node_modules/@melt-ui/svelte/dist/internal/helpers/overridable.js","../../../../../../node_modules/.pnpm/@melt-ui+svelte@0.41.3_svelte@4.2.0/node_modules/@melt-ui/svelte/dist/internal/helpers/sleep.js","../../../../../../node_modules/.pnpm/@melt-ui+svelte@0.41.3_svelte@4.2.0/node_modules/@melt-ui/svelte/dist/internal/helpers/style.js","../../../../../../node_modules/.pnpm/nanoid@4.0.2/node_modules/nanoid/non-secure/index.js","../../../../../../node_modules/.pnpm/@melt-ui+svelte@0.41.3_svelte@4.2.0/node_modules/@melt-ui/svelte/dist/internal/helpers/id.js","../../../../../../node_modules/.pnpm/@melt-ui+svelte@0.41.3_svelte@4.2.0/node_modules/@melt-ui/svelte/dist/internal/helpers/keyboard.js","../../../../../../node_modules/.pnpm/@melt-ui+svelte@0.41.3_svelte@4.2.0/node_modules/@melt-ui/svelte/dist/internal/helpers/platform.js","../../../../../../node_modules/.pnpm/@melt-ui+svelte@0.41.3_svelte@4.2.0/node_modules/@melt-ui/svelte/dist/internal/helpers/scroll.js","../../../../../../node_modules/.pnpm/@melt-ui+svelte@0.41.3_svelte@4.2.0/node_modules/@melt-ui/svelte/dist/internal/helpers/store/derivedVisible.js","../../../../../../node_modules/.pnpm/@melt-ui+svelte@0.41.3_svelte@4.2.0/node_modules/@melt-ui/svelte/dist/internal/helpers/store/derivedWithUnsubscribe.js","../../../../../../node_modules/.pnpm/@melt-ui+svelte@0.41.3_svelte@4.2.0/node_modules/@melt-ui/svelte/dist/internal/helpers/store/effect.js","../../../../../../node_modules/.pnpm/@melt-ui+svelte@0.41.3_svelte@4.2.0/node_modules/@melt-ui/svelte/dist/internal/helpers/store/debounceable.js","../../../../../../node_modules/.pnpm/@melt-ui+svelte@0.41.3_svelte@4.2.0/node_modules/@melt-ui/svelte/dist/internal/helpers/store/toWritableStores.js","../../../../../../node_modules/.pnpm/@melt-ui+svelte@0.41.3_svelte@4.2.0/node_modules/@melt-ui/svelte/dist/internal/helpers/elements.js","../../../../../../node_modules/.pnpm/@melt-ui+svelte@0.41.3_svelte@4.2.0/node_modules/@melt-ui/svelte/dist/internal/actions/click-outside/action.js","../../../../../../node_modules/.pnpm/@melt-ui+svelte@0.41.3_svelte@4.2.0/node_modules/@melt-ui/svelte/dist/internal/actions/escape-keydown/action.js","../../../../../../node_modules/.pnpm/@floating-ui+utils@0.1.1/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs","../../../../../../node_modules/.pnpm/@floating-ui+core@1.4.1/node_modules/@floating-ui/core/dist/floating-ui.core.mjs","../../../../../../node_modules/.pnpm/@floating-ui+utils@0.1.1/node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs","../../../../../../node_modules/.pnpm/@floating-ui+dom@1.5.1/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs","../../../../../../node_modules/.pnpm/@melt-ui+svelte@0.41.3_svelte@4.2.0/node_modules/@melt-ui/svelte/dist/internal/actions/floating/action.js","../../../../../../node_modules/.pnpm/tabbable@6.2.0/node_modules/tabbable/dist/index.esm.js","../../../../../../node_modules/.pnpm/focus-trap@7.5.2/node_modules/focus-trap/dist/focus-trap.esm.js","../../../../../../node_modules/.pnpm/@melt-ui+svelte@0.41.3_svelte@4.2.0/node_modules/@melt-ui/svelte/dist/internal/actions/focus-trap/action.js","../../../../../../node_modules/.pnpm/@melt-ui+svelte@0.41.3_svelte@4.2.0/node_modules/@melt-ui/svelte/dist/internal/actions/popper/action.js","../../../../../../node_modules/.pnpm/@melt-ui+svelte@0.41.3_svelte@4.2.0/node_modules/@melt-ui/svelte/dist/internal/actions/portal.js","../../../../../../node_modules/.pnpm/@melt-ui+svelte@0.41.3_svelte@4.2.0/node_modules/@melt-ui/svelte/dist/builders/label/create.js","../../../../../../node_modules/.pnpm/@melt-ui+svelte@0.41.3_svelte@4.2.0/node_modules/@melt-ui/svelte/dist/builders/combobox/create.js","../../../../../../node_modules/.pnpm/@sveltejs+kit@1.22.6_svelte@4.2.0_vite@4.4.9/node_modules/@sveltejs/kit/src/runtime/app/navigation.js","../../../../../../src/routes/[lang=lang]/Searchbar.svelte","../../../../../../src/routes/[lang=lang]/+page.svelte"],"sourcesContent":["import { transition_in, transition_out } from './transitions.js';\nimport { run_all } from './utils.js';\n\n// general each functions:\n\nexport function ensure_array_like(array_like_or_iterator) {\n\treturn array_like_or_iterator?.length !== undefined\n\t\t? array_like_or_iterator\n\t\t: Array.from(array_like_or_iterator);\n}\n\n// keyed each functions:\n\n/** @returns {void} */\nexport function destroy_block(block, lookup) {\n\tblock.d(1);\n\tlookup.delete(block.key);\n}\n\n/** @returns {void} */\nexport function outro_and_destroy_block(block, lookup) {\n\ttransition_out(block, 1, 1, () => {\n\t\tlookup.delete(block.key);\n\t});\n}\n\n/** @returns {void} */\nexport function fix_and_destroy_block(block, lookup) {\n\tblock.f();\n\tdestroy_block(block, lookup);\n}\n\n/** @returns {void} */\nexport function fix_and_outro_and_destroy_block(block, lookup) {\n\tblock.f();\n\toutro_and_destroy_block(block, lookup);\n}\n\n/** @returns {any[]} */\nexport function update_keyed_each(\n\told_blocks,\n\tdirty,\n\tget_key,\n\tdynamic,\n\tctx,\n\tlist,\n\tlookup,\n\tnode,\n\tdestroy,\n\tcreate_each_block,\n\tnext,\n\tget_context\n) {\n\tlet o = old_blocks.length;\n\tlet n = list.length;\n\tlet i = o;\n\tconst old_indexes = {};\n\twhile (i--) old_indexes[old_blocks[i].key] = i;\n\tconst new_blocks = [];\n\tconst new_lookup = new Map();\n\tconst deltas = new Map();\n\tconst updates = [];\n\ti = n;\n\twhile (i--) {\n\t\tconst child_ctx = get_context(ctx, list, i);\n\t\tconst key = get_key(child_ctx);\n\t\tlet block = lookup.get(key);\n\t\tif (!block) {\n\t\t\tblock = create_each_block(key, child_ctx);\n\t\t\tblock.c();\n\t\t} else if (dynamic) {\n\t\t\t// defer updates until all the DOM shuffling is done\n\t\t\tupdates.push(() => block.p(child_ctx, dirty));\n\t\t}\n\t\tnew_lookup.set(key, (new_blocks[i] = block));\n\t\tif (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));\n\t}\n\tconst will_move = new Set();\n\tconst did_move = new Set();\n\t/** @returns {void} */\n\tfunction insert(block) {\n\t\ttransition_in(block, 1);\n\t\tblock.m(node, next);\n\t\tlookup.set(block.key, block);\n\t\tnext = block.first;\n\t\tn--;\n\t}\n\twhile (o && n) {\n\t\tconst new_block = new_blocks[n - 1];\n\t\tconst old_block = old_blocks[o - 1];\n\t\tconst new_key = new_block.key;\n\t\tconst old_key = old_block.key;\n\t\tif (new_block === old_block) {\n\t\t\t// do nothing\n\t\t\tnext = new_block.first;\n\t\t\to--;\n\t\t\tn--;\n\t\t} else if (!new_lookup.has(old_key)) {\n\t\t\t// remove old block\n\t\t\tdestroy(old_block, lookup);\n\t\t\to--;\n\t\t} else if (!lookup.has(new_key) || will_move.has(new_key)) {\n\t\t\tinsert(new_block);\n\t\t} else if (did_move.has(old_key)) {\n\t\t\to--;\n\t\t} else if (deltas.get(new_key) > deltas.get(old_key)) {\n\t\t\tdid_move.add(new_key);\n\t\t\tinsert(new_block);\n\t\t} else {\n\t\t\twill_move.add(old_key);\n\t\t\to--;\n\t\t}\n\t}\n\twhile (o--) {\n\t\tconst old_block = old_blocks[o];\n\t\tif (!new_lookup.has(old_block.key)) destroy(old_block, lookup);\n\t}\n\twhile (n) insert(new_blocks[n - 1]);\n\trun_all(updates);\n\treturn new_blocks;\n}\n\n/** @returns {void} */\nexport function validate_each_keys(ctx, list, get_context, get_key) {\n\tconst keys = new Map();\n\tfor (let i = 0; i < list.length; i++) {\n\t\tconst key = get_key(get_context(ctx, list, i));\n\t\tif (keys.has(key)) {\n\t\t\tlet value = '';\n\t\t\ttry {\n\t\t\t\tvalue = `with value '${String(key)}' `;\n\t\t\t} catch (e) {\n\t\t\t\t// can't stringify\n\t\t\t}\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot have duplicate keys in a keyed each: Keys at index ${keys.get(\n\t\t\t\t\tkey\n\t\t\t\t)} and ${i} ${value}are duplicates`\n\t\t\t);\n\t\t}\n\t\tkeys.set(key, i);\n\t}\n}\n","/** @returns {{}} */\nexport function get_spread_update(levels, updates) {\n\tconst update = {};\n\tconst to_null_out = {};\n\tconst accounted_for = { $$scope: 1 };\n\tlet i = levels.length;\n\twhile (i--) {\n\t\tconst o = levels[i];\n\t\tconst n = updates[i];\n\t\tif (n) {\n\t\t\tfor (const key in o) {\n\t\t\t\tif (!(key in n)) to_null_out[key] = 1;\n\t\t\t}\n\t\t\tfor (const key in n) {\n\t\t\t\tif (!accounted_for[key]) {\n\t\t\t\t\tupdate[key] = n[key];\n\t\t\t\t\taccounted_for[key] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlevels[i] = n;\n\t\t} else {\n\t\t\tfor (const key in o) {\n\t\t\t\taccounted_for[key] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (const key in to_null_out) {\n\t\tif (!(key in update)) update[key] = undefined;\n\t}\n\treturn update;\n}\n\nexport function get_spread_object(spread_props) {\n\treturn typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n","import type { Restaurants } from \"$lib/client.types\";\r\n\r\nexport function isRestaurantOpen(restaurant: { close_hour?: string | null, open_hour?: string | null }, currentTime = new Date().toISOString().substring(11, 19)) {\r\n    if (!restaurant.close_hour || !restaurant.open_hour) {\r\n        return true;\r\n    }\r\n    if (restaurant.open_hour.localeCompare(restaurant.close_hour) < 0) {\r\n        return (\r\n            restaurant.close_hour.localeCompare(currentTime) >= 0 &&\r\n            restaurant.open_hour.localeCompare(currentTime) <= 0\r\n        );\r\n    } else {\r\n        return (\r\n            restaurant.close_hour.localeCompare(currentTime) >= 0 ||\r\n            restaurant.open_hour.localeCompare(currentTime) <= 0\r\n        );\r\n    }\r\n}\r\n\r\nexport function getFranceTime(date: Date = new Date()) {\r\n    const formatter = new Intl.DateTimeFormat([], {\r\n        timeZone: 'Europe/Paris',\r\n        hour: 'numeric',\r\n        minute: 'numeric',\r\n        second: 'numeric',\r\n    });\r\n    return formatter.format(date);\r\n}\r\n\r\nexport async function getAffluence(restaurantId: Restaurants['id']): Promise<number> {\r\n    return new Promise((resolve, reject) => {\r\n        setTimeout(() => {\r\n            resolve(Math.ceil(Math.random() * 60));\r\n        }, 2000);\r\n    });\r\n}","/**\n * Fuse.js v6.6.2 - Lightweight fuzzy-search (http://fusejs.io)\n *\n * Copyright (c) 2022 Kiro Risk (http://kiro.me)\n * All Rights Reserved. Apache Software License 2.0\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n */\n\nfunction isArray(value) {\n  return !Array.isArray\n    ? getTag(value) === '[object Array]'\n    : Array.isArray(value)\n}\n\n// Adapted from: https://github.com/lodash/lodash/blob/master/.internal/baseToString.js\nconst INFINITY = 1 / 0;\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value\n  }\n  let result = value + '';\n  return result == '0' && 1 / value == -INFINITY ? '-0' : result\n}\n\nfunction toString(value) {\n  return value == null ? '' : baseToString(value)\n}\n\nfunction isString(value) {\n  return typeof value === 'string'\n}\n\nfunction isNumber(value) {\n  return typeof value === 'number'\n}\n\n// Adapted from: https://github.com/lodash/lodash/blob/master/isBoolean.js\nfunction isBoolean(value) {\n  return (\n    value === true ||\n    value === false ||\n    (isObjectLike(value) && getTag(value) == '[object Boolean]')\n  )\n}\n\nfunction isObject(value) {\n  return typeof value === 'object'\n}\n\n// Checks if `value` is object-like.\nfunction isObjectLike(value) {\n  return isObject(value) && value !== null\n}\n\nfunction isDefined(value) {\n  return value !== undefined && value !== null\n}\n\nfunction isBlank(value) {\n  return !value.trim().length\n}\n\n// Gets the `toStringTag` of `value`.\n// Adapted from: https://github.com/lodash/lodash/blob/master/.internal/getTag.js\nfunction getTag(value) {\n  return value == null\n    ? value === undefined\n      ? '[object Undefined]'\n      : '[object Null]'\n    : Object.prototype.toString.call(value)\n}\n\nconst EXTENDED_SEARCH_UNAVAILABLE = 'Extended search is not available';\n\nconst INCORRECT_INDEX_TYPE = \"Incorrect 'index' type\";\n\nconst LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) =>\n  `Invalid value for key ${key}`;\n\nconst PATTERN_LENGTH_TOO_LARGE = (max) =>\n  `Pattern length exceeds max of ${max}.`;\n\nconst MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;\n\nconst INVALID_KEY_WEIGHT_VALUE = (key) =>\n  `Property 'weight' in key '${key}' must be a positive integer`;\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nclass KeyStore {\n  constructor(keys) {\n    this._keys = [];\n    this._keyMap = {};\n\n    let totalWeight = 0;\n\n    keys.forEach((key) => {\n      let obj = createKey(key);\n\n      totalWeight += obj.weight;\n\n      this._keys.push(obj);\n      this._keyMap[obj.id] = obj;\n\n      totalWeight += obj.weight;\n    });\n\n    // Normalize weights so that their sum is equal to 1\n    this._keys.forEach((key) => {\n      key.weight /= totalWeight;\n    });\n  }\n  get(keyId) {\n    return this._keyMap[keyId]\n  }\n  keys() {\n    return this._keys\n  }\n  toJSON() {\n    return JSON.stringify(this._keys)\n  }\n}\n\nfunction createKey(key) {\n  let path = null;\n  let id = null;\n  let src = null;\n  let weight = 1;\n  let getFn = null;\n\n  if (isString(key) || isArray(key)) {\n    src = key;\n    path = createKeyPath(key);\n    id = createKeyId(key);\n  } else {\n    if (!hasOwn.call(key, 'name')) {\n      throw new Error(MISSING_KEY_PROPERTY('name'))\n    }\n\n    const name = key.name;\n    src = name;\n\n    if (hasOwn.call(key, 'weight')) {\n      weight = key.weight;\n\n      if (weight <= 0) {\n        throw new Error(INVALID_KEY_WEIGHT_VALUE(name))\n      }\n    }\n\n    path = createKeyPath(name);\n    id = createKeyId(name);\n    getFn = key.getFn;\n  }\n\n  return { path, id, weight, src, getFn }\n}\n\nfunction createKeyPath(key) {\n  return isArray(key) ? key : key.split('.')\n}\n\nfunction createKeyId(key) {\n  return isArray(key) ? key.join('.') : key\n}\n\nfunction get(obj, path) {\n  let list = [];\n  let arr = false;\n\n  const deepGet = (obj, path, index) => {\n    if (!isDefined(obj)) {\n      return\n    }\n    if (!path[index]) {\n      // If there's no path left, we've arrived at the object we care about.\n      list.push(obj);\n    } else {\n      let key = path[index];\n\n      const value = obj[key];\n\n      if (!isDefined(value)) {\n        return\n      }\n\n      // If we're at the last value in the path, and if it's a string/number/bool,\n      // add it to the list\n      if (\n        index === path.length - 1 &&\n        (isString(value) || isNumber(value) || isBoolean(value))\n      ) {\n        list.push(toString(value));\n      } else if (isArray(value)) {\n        arr = true;\n        // Search each item in the array.\n        for (let i = 0, len = value.length; i < len; i += 1) {\n          deepGet(value[i], path, index + 1);\n        }\n      } else if (path.length) {\n        // An object. Recurse further.\n        deepGet(value, path, index + 1);\n      }\n    }\n  };\n\n  // Backwards compatibility (since path used to be a string)\n  deepGet(obj, isString(path) ? path.split('.') : path, 0);\n\n  return arr ? list : list[0]\n}\n\nconst MatchOptions = {\n  // Whether the matches should be included in the result set. When `true`, each record in the result\n  // set will include the indices of the matched characters.\n  // These can consequently be used for highlighting purposes.\n  includeMatches: false,\n  // When `true`, the matching function will continue to the end of a search pattern even if\n  // a perfect match has already been located in the string.\n  findAllMatches: false,\n  // Minimum number of characters that must be matched before a result is considered a match\n  minMatchCharLength: 1\n};\n\nconst BasicOptions = {\n  // When `true`, the algorithm continues searching to the end of the input even if a perfect\n  // match is found before the end of the same input.\n  isCaseSensitive: false,\n  // When true, the matching function will continue to the end of a search pattern even if\n  includeScore: false,\n  // List of properties that will be searched. This also supports nested properties.\n  keys: [],\n  // Whether to sort the result list, by score\n  shouldSort: true,\n  // Default sort function: sort by ascending score, ascending index\n  sortFn: (a, b) =>\n    a.score === b.score ? (a.idx < b.idx ? -1 : 1) : a.score < b.score ? -1 : 1\n};\n\nconst FuzzyOptions = {\n  // Approximately where in the text is the pattern expected to be found?\n  location: 0,\n  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match\n  // (of both letters and location), a threshold of '1.0' would match anything.\n  threshold: 0.6,\n  // Determines how close the match must be to the fuzzy location (specified above).\n  // An exact letter match which is 'distance' characters away from the fuzzy location\n  // would score as a complete mismatch. A distance of '0' requires the match be at\n  // the exact location specified, a threshold of '1000' would require a perfect match\n  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.\n  distance: 100\n};\n\nconst AdvancedOptions = {\n  // When `true`, it enables the use of unix-like search commands\n  useExtendedSearch: false,\n  // The get function to use when fetching an object's properties.\n  // The default will search nested paths *ie foo.bar.baz*\n  getFn: get,\n  // When `true`, search will ignore `location` and `distance`, so it won't matter\n  // where in the string the pattern appears.\n  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score\n  ignoreLocation: false,\n  // When `true`, the calculation for the relevance score (used for sorting) will\n  // ignore the field-length norm.\n  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm\n  ignoreFieldNorm: false,\n  // The weight to determine how much field length norm effects scoring.\n  fieldNormWeight: 1\n};\n\nvar Config = {\n  ...BasicOptions,\n  ...MatchOptions,\n  ...FuzzyOptions,\n  ...AdvancedOptions\n};\n\nconst SPACE = /[^ ]+/g;\n\n// Field-length norm: the shorter the field, the higher the weight.\n// Set to 3 decimals to reduce index size.\nfunction norm(weight = 1, mantissa = 3) {\n  const cache = new Map();\n  const m = Math.pow(10, mantissa);\n\n  return {\n    get(value) {\n      const numTokens = value.match(SPACE).length;\n\n      if (cache.has(numTokens)) {\n        return cache.get(numTokens)\n      }\n\n      // Default function is 1/sqrt(x), weight makes that variable\n      const norm = 1 / Math.pow(numTokens, 0.5 * weight);\n\n      // In place of `toFixed(mantissa)`, for faster computation\n      const n = parseFloat(Math.round(norm * m) / m);\n\n      cache.set(numTokens, n);\n\n      return n\n    },\n    clear() {\n      cache.clear();\n    }\n  }\n}\n\nclass FuseIndex {\n  constructor({\n    getFn = Config.getFn,\n    fieldNormWeight = Config.fieldNormWeight\n  } = {}) {\n    this.norm = norm(fieldNormWeight, 3);\n    this.getFn = getFn;\n    this.isCreated = false;\n\n    this.setIndexRecords();\n  }\n  setSources(docs = []) {\n    this.docs = docs;\n  }\n  setIndexRecords(records = []) {\n    this.records = records;\n  }\n  setKeys(keys = []) {\n    this.keys = keys;\n    this._keysMap = {};\n    keys.forEach((key, idx) => {\n      this._keysMap[key.id] = idx;\n    });\n  }\n  create() {\n    if (this.isCreated || !this.docs.length) {\n      return\n    }\n\n    this.isCreated = true;\n\n    // List is Array<String>\n    if (isString(this.docs[0])) {\n      this.docs.forEach((doc, docIndex) => {\n        this._addString(doc, docIndex);\n      });\n    } else {\n      // List is Array<Object>\n      this.docs.forEach((doc, docIndex) => {\n        this._addObject(doc, docIndex);\n      });\n    }\n\n    this.norm.clear();\n  }\n  // Adds a doc to the end of the index\n  add(doc) {\n    const idx = this.size();\n\n    if (isString(doc)) {\n      this._addString(doc, idx);\n    } else {\n      this._addObject(doc, idx);\n    }\n  }\n  // Removes the doc at the specified index of the index\n  removeAt(idx) {\n    this.records.splice(idx, 1);\n\n    // Change ref index of every subsquent doc\n    for (let i = idx, len = this.size(); i < len; i += 1) {\n      this.records[i].i -= 1;\n    }\n  }\n  getValueForItemAtKeyId(item, keyId) {\n    return item[this._keysMap[keyId]]\n  }\n  size() {\n    return this.records.length\n  }\n  _addString(doc, docIndex) {\n    if (!isDefined(doc) || isBlank(doc)) {\n      return\n    }\n\n    let record = {\n      v: doc,\n      i: docIndex,\n      n: this.norm.get(doc)\n    };\n\n    this.records.push(record);\n  }\n  _addObject(doc, docIndex) {\n    let record = { i: docIndex, $: {} };\n\n    // Iterate over every key (i.e, path), and fetch the value at that key\n    this.keys.forEach((key, keyIndex) => {\n      let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);\n\n      if (!isDefined(value)) {\n        return\n      }\n\n      if (isArray(value)) {\n        let subRecords = [];\n        const stack = [{ nestedArrIndex: -1, value }];\n\n        while (stack.length) {\n          const { nestedArrIndex, value } = stack.pop();\n\n          if (!isDefined(value)) {\n            continue\n          }\n\n          if (isString(value) && !isBlank(value)) {\n            let subRecord = {\n              v: value,\n              i: nestedArrIndex,\n              n: this.norm.get(value)\n            };\n\n            subRecords.push(subRecord);\n          } else if (isArray(value)) {\n            value.forEach((item, k) => {\n              stack.push({\n                nestedArrIndex: k,\n                value: item\n              });\n            });\n          } else ;\n        }\n        record.$[keyIndex] = subRecords;\n      } else if (isString(value) && !isBlank(value)) {\n        let subRecord = {\n          v: value,\n          n: this.norm.get(value)\n        };\n\n        record.$[keyIndex] = subRecord;\n      }\n    });\n\n    this.records.push(record);\n  }\n  toJSON() {\n    return {\n      keys: this.keys,\n      records: this.records\n    }\n  }\n}\n\nfunction createIndex(\n  keys,\n  docs,\n  { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}\n) {\n  const myIndex = new FuseIndex({ getFn, fieldNormWeight });\n  myIndex.setKeys(keys.map(createKey));\n  myIndex.setSources(docs);\n  myIndex.create();\n  return myIndex\n}\n\nfunction parseIndex(\n  data,\n  { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}\n) {\n  const { keys, records } = data;\n  const myIndex = new FuseIndex({ getFn, fieldNormWeight });\n  myIndex.setKeys(keys);\n  myIndex.setIndexRecords(records);\n  return myIndex\n}\n\nfunction computeScore$1(\n  pattern,\n  {\n    errors = 0,\n    currentLocation = 0,\n    expectedLocation = 0,\n    distance = Config.distance,\n    ignoreLocation = Config.ignoreLocation\n  } = {}\n) {\n  const accuracy = errors / pattern.length;\n\n  if (ignoreLocation) {\n    return accuracy\n  }\n\n  const proximity = Math.abs(expectedLocation - currentLocation);\n\n  if (!distance) {\n    // Dodge divide by zero error.\n    return proximity ? 1.0 : accuracy\n  }\n\n  return accuracy + proximity / distance\n}\n\nfunction convertMaskToIndices(\n  matchmask = [],\n  minMatchCharLength = Config.minMatchCharLength\n) {\n  let indices = [];\n  let start = -1;\n  let end = -1;\n  let i = 0;\n\n  for (let len = matchmask.length; i < len; i += 1) {\n    let match = matchmask[i];\n    if (match && start === -1) {\n      start = i;\n    } else if (!match && start !== -1) {\n      end = i - 1;\n      if (end - start + 1 >= minMatchCharLength) {\n        indices.push([start, end]);\n      }\n      start = -1;\n    }\n  }\n\n  // (i-1 - start) + 1 => i - start\n  if (matchmask[i - 1] && i - start >= minMatchCharLength) {\n    indices.push([start, i - 1]);\n  }\n\n  return indices\n}\n\n// Machine word size\nconst MAX_BITS = 32;\n\nfunction search(\n  text,\n  pattern,\n  patternAlphabet,\n  {\n    location = Config.location,\n    distance = Config.distance,\n    threshold = Config.threshold,\n    findAllMatches = Config.findAllMatches,\n    minMatchCharLength = Config.minMatchCharLength,\n    includeMatches = Config.includeMatches,\n    ignoreLocation = Config.ignoreLocation\n  } = {}\n) {\n  if (pattern.length > MAX_BITS) {\n    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS))\n  }\n\n  const patternLen = pattern.length;\n  // Set starting location at beginning text and initialize the alphabet.\n  const textLen = text.length;\n  // Handle the case when location > text.length\n  const expectedLocation = Math.max(0, Math.min(location, textLen));\n  // Highest score beyond which we give up.\n  let currentThreshold = threshold;\n  // Is there a nearby exact match? (speedup)\n  let bestLocation = expectedLocation;\n\n  // Performance: only computer matches when the minMatchCharLength > 1\n  // OR if `includeMatches` is true.\n  const computeMatches = minMatchCharLength > 1 || includeMatches;\n  // A mask of the matches, used for building the indices\n  const matchMask = computeMatches ? Array(textLen) : [];\n\n  let index;\n\n  // Get all exact matches, here for speed up\n  while ((index = text.indexOf(pattern, bestLocation)) > -1) {\n    let score = computeScore$1(pattern, {\n      currentLocation: index,\n      expectedLocation,\n      distance,\n      ignoreLocation\n    });\n\n    currentThreshold = Math.min(score, currentThreshold);\n    bestLocation = index + patternLen;\n\n    if (computeMatches) {\n      let i = 0;\n      while (i < patternLen) {\n        matchMask[index + i] = 1;\n        i += 1;\n      }\n    }\n  }\n\n  // Reset the best location\n  bestLocation = -1;\n\n  let lastBitArr = [];\n  let finalScore = 1;\n  let binMax = patternLen + textLen;\n\n  const mask = 1 << (patternLen - 1);\n\n  for (let i = 0; i < patternLen; i += 1) {\n    // Scan for the best match; each iteration allows for one more error.\n    // Run a binary search to determine how far from the match location we can stray\n    // at this error level.\n    let binMin = 0;\n    let binMid = binMax;\n\n    while (binMin < binMid) {\n      const score = computeScore$1(pattern, {\n        errors: i,\n        currentLocation: expectedLocation + binMid,\n        expectedLocation,\n        distance,\n        ignoreLocation\n      });\n\n      if (score <= currentThreshold) {\n        binMin = binMid;\n      } else {\n        binMax = binMid;\n      }\n\n      binMid = Math.floor((binMax - binMin) / 2 + binMin);\n    }\n\n    // Use the result from this iteration as the maximum for the next.\n    binMax = binMid;\n\n    let start = Math.max(1, expectedLocation - binMid + 1);\n    let finish = findAllMatches\n      ? textLen\n      : Math.min(expectedLocation + binMid, textLen) + patternLen;\n\n    // Initialize the bit array\n    let bitArr = Array(finish + 2);\n\n    bitArr[finish + 1] = (1 << i) - 1;\n\n    for (let j = finish; j >= start; j -= 1) {\n      let currentLocation = j - 1;\n      let charMatch = patternAlphabet[text.charAt(currentLocation)];\n\n      if (computeMatches) {\n        // Speed up: quick bool to int conversion (i.e, `charMatch ? 1 : 0`)\n        matchMask[currentLocation] = +!!charMatch;\n      }\n\n      // First pass: exact match\n      bitArr[j] = ((bitArr[j + 1] << 1) | 1) & charMatch;\n\n      // Subsequent passes: fuzzy match\n      if (i) {\n        bitArr[j] |=\n          ((lastBitArr[j + 1] | lastBitArr[j]) << 1) | 1 | lastBitArr[j + 1];\n      }\n\n      if (bitArr[j] & mask) {\n        finalScore = computeScore$1(pattern, {\n          errors: i,\n          currentLocation,\n          expectedLocation,\n          distance,\n          ignoreLocation\n        });\n\n        // This match will almost certainly be better than any existing match.\n        // But check anyway.\n        if (finalScore <= currentThreshold) {\n          // Indeed it is\n          currentThreshold = finalScore;\n          bestLocation = currentLocation;\n\n          // Already passed `loc`, downhill from here on in.\n          if (bestLocation <= expectedLocation) {\n            break\n          }\n\n          // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.\n          start = Math.max(1, 2 * expectedLocation - bestLocation);\n        }\n      }\n    }\n\n    // No hope for a (better) match at greater error levels.\n    const score = computeScore$1(pattern, {\n      errors: i + 1,\n      currentLocation: expectedLocation,\n      expectedLocation,\n      distance,\n      ignoreLocation\n    });\n\n    if (score > currentThreshold) {\n      break\n    }\n\n    lastBitArr = bitArr;\n  }\n\n  const result = {\n    isMatch: bestLocation >= 0,\n    // Count exact matches (those with a score of 0) to be \"almost\" exact\n    score: Math.max(0.001, finalScore)\n  };\n\n  if (computeMatches) {\n    const indices = convertMaskToIndices(matchMask, minMatchCharLength);\n    if (!indices.length) {\n      result.isMatch = false;\n    } else if (includeMatches) {\n      result.indices = indices;\n    }\n  }\n\n  return result\n}\n\nfunction createPatternAlphabet(pattern) {\n  let mask = {};\n\n  for (let i = 0, len = pattern.length; i < len; i += 1) {\n    const char = pattern.charAt(i);\n    mask[char] = (mask[char] || 0) | (1 << (len - i - 1));\n  }\n\n  return mask\n}\n\nclass BitapSearch {\n  constructor(\n    pattern,\n    {\n      location = Config.location,\n      threshold = Config.threshold,\n      distance = Config.distance,\n      includeMatches = Config.includeMatches,\n      findAllMatches = Config.findAllMatches,\n      minMatchCharLength = Config.minMatchCharLength,\n      isCaseSensitive = Config.isCaseSensitive,\n      ignoreLocation = Config.ignoreLocation\n    } = {}\n  ) {\n    this.options = {\n      location,\n      threshold,\n      distance,\n      includeMatches,\n      findAllMatches,\n      minMatchCharLength,\n      isCaseSensitive,\n      ignoreLocation\n    };\n\n    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();\n\n    this.chunks = [];\n\n    if (!this.pattern.length) {\n      return\n    }\n\n    const addChunk = (pattern, startIndex) => {\n      this.chunks.push({\n        pattern,\n        alphabet: createPatternAlphabet(pattern),\n        startIndex\n      });\n    };\n\n    const len = this.pattern.length;\n\n    if (len > MAX_BITS) {\n      let i = 0;\n      const remainder = len % MAX_BITS;\n      const end = len - remainder;\n\n      while (i < end) {\n        addChunk(this.pattern.substr(i, MAX_BITS), i);\n        i += MAX_BITS;\n      }\n\n      if (remainder) {\n        const startIndex = len - MAX_BITS;\n        addChunk(this.pattern.substr(startIndex), startIndex);\n      }\n    } else {\n      addChunk(this.pattern, 0);\n    }\n  }\n\n  searchIn(text) {\n    const { isCaseSensitive, includeMatches } = this.options;\n\n    if (!isCaseSensitive) {\n      text = text.toLowerCase();\n    }\n\n    // Exact match\n    if (this.pattern === text) {\n      let result = {\n        isMatch: true,\n        score: 0\n      };\n\n      if (includeMatches) {\n        result.indices = [[0, text.length - 1]];\n      }\n\n      return result\n    }\n\n    // Otherwise, use Bitap algorithm\n    const {\n      location,\n      distance,\n      threshold,\n      findAllMatches,\n      minMatchCharLength,\n      ignoreLocation\n    } = this.options;\n\n    let allIndices = [];\n    let totalScore = 0;\n    let hasMatches = false;\n\n    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {\n      const { isMatch, score, indices } = search(text, pattern, alphabet, {\n        location: location + startIndex,\n        distance,\n        threshold,\n        findAllMatches,\n        minMatchCharLength,\n        includeMatches,\n        ignoreLocation\n      });\n\n      if (isMatch) {\n        hasMatches = true;\n      }\n\n      totalScore += score;\n\n      if (isMatch && indices) {\n        allIndices = [...allIndices, ...indices];\n      }\n    });\n\n    let result = {\n      isMatch: hasMatches,\n      score: hasMatches ? totalScore / this.chunks.length : 1\n    };\n\n    if (hasMatches && includeMatches) {\n      result.indices = allIndices;\n    }\n\n    return result\n  }\n}\n\nclass BaseMatch {\n  constructor(pattern) {\n    this.pattern = pattern;\n  }\n  static isMultiMatch(pattern) {\n    return getMatch(pattern, this.multiRegex)\n  }\n  static isSingleMatch(pattern) {\n    return getMatch(pattern, this.singleRegex)\n  }\n  search(/*text*/) {}\n}\n\nfunction getMatch(pattern, exp) {\n  const matches = pattern.match(exp);\n  return matches ? matches[1] : null\n}\n\n// Token: 'file\n\nclass ExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'exact'\n  }\n  static get multiRegex() {\n    return /^=\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^=(.*)$/\n  }\n  search(text) {\n    const isMatch = text === this.pattern;\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [0, this.pattern.length - 1]\n    }\n  }\n}\n\n// Token: !fire\n\nclass InverseExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'inverse-exact'\n  }\n  static get multiRegex() {\n    return /^!\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^!(.*)$/\n  }\n  search(text) {\n    const index = text.indexOf(this.pattern);\n    const isMatch = index === -1;\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [0, text.length - 1]\n    }\n  }\n}\n\n// Token: ^file\n\nclass PrefixExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'prefix-exact'\n  }\n  static get multiRegex() {\n    return /^\\^\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^\\^(.*)$/\n  }\n  search(text) {\n    const isMatch = text.startsWith(this.pattern);\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [0, this.pattern.length - 1]\n    }\n  }\n}\n\n// Token: !^fire\n\nclass InversePrefixExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'inverse-prefix-exact'\n  }\n  static get multiRegex() {\n    return /^!\\^\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^!\\^(.*)$/\n  }\n  search(text) {\n    const isMatch = !text.startsWith(this.pattern);\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [0, text.length - 1]\n    }\n  }\n}\n\n// Token: .file$\n\nclass SuffixExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'suffix-exact'\n  }\n  static get multiRegex() {\n    return /^\"(.*)\"\\$$/\n  }\n  static get singleRegex() {\n    return /^(.*)\\$$/\n  }\n  search(text) {\n    const isMatch = text.endsWith(this.pattern);\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [text.length - this.pattern.length, text.length - 1]\n    }\n  }\n}\n\n// Token: !.file$\n\nclass InverseSuffixExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'inverse-suffix-exact'\n  }\n  static get multiRegex() {\n    return /^!\"(.*)\"\\$$/\n  }\n  static get singleRegex() {\n    return /^!(.*)\\$$/\n  }\n  search(text) {\n    const isMatch = !text.endsWith(this.pattern);\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [0, text.length - 1]\n    }\n  }\n}\n\nclass FuzzyMatch extends BaseMatch {\n  constructor(\n    pattern,\n    {\n      location = Config.location,\n      threshold = Config.threshold,\n      distance = Config.distance,\n      includeMatches = Config.includeMatches,\n      findAllMatches = Config.findAllMatches,\n      minMatchCharLength = Config.minMatchCharLength,\n      isCaseSensitive = Config.isCaseSensitive,\n      ignoreLocation = Config.ignoreLocation\n    } = {}\n  ) {\n    super(pattern);\n    this._bitapSearch = new BitapSearch(pattern, {\n      location,\n      threshold,\n      distance,\n      includeMatches,\n      findAllMatches,\n      minMatchCharLength,\n      isCaseSensitive,\n      ignoreLocation\n    });\n  }\n  static get type() {\n    return 'fuzzy'\n  }\n  static get multiRegex() {\n    return /^\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^(.*)$/\n  }\n  search(text) {\n    return this._bitapSearch.searchIn(text)\n  }\n}\n\n// Token: 'file\n\nclass IncludeMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'include'\n  }\n  static get multiRegex() {\n    return /^'\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^'(.*)$/\n  }\n  search(text) {\n    let location = 0;\n    let index;\n\n    const indices = [];\n    const patternLen = this.pattern.length;\n\n    // Get all exact matches\n    while ((index = text.indexOf(this.pattern, location)) > -1) {\n      location = index + patternLen;\n      indices.push([index, location - 1]);\n    }\n\n    const isMatch = !!indices.length;\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices\n    }\n  }\n}\n\n// â—Order is important. DO NOT CHANGE.\nconst searchers = [\n  ExactMatch,\n  IncludeMatch,\n  PrefixExactMatch,\n  InversePrefixExactMatch,\n  InverseSuffixExactMatch,\n  SuffixExactMatch,\n  InverseExactMatch,\n  FuzzyMatch\n];\n\nconst searchersLen = searchers.length;\n\n// Regex to split by spaces, but keep anything in quotes together\nconst SPACE_RE = / +(?=(?:[^\\\"]*\\\"[^\\\"]*\\\")*[^\\\"]*$)/;\nconst OR_TOKEN = '|';\n\n// Return a 2D array representation of the query, for simpler parsing.\n// Example:\n// \"^core go$ | rb$ | py$ xy$\" => [[\"^core\", \"go$\"], [\"rb$\"], [\"py$\", \"xy$\"]]\nfunction parseQuery(pattern, options = {}) {\n  return pattern.split(OR_TOKEN).map((item) => {\n    let query = item\n      .trim()\n      .split(SPACE_RE)\n      .filter((item) => item && !!item.trim());\n\n    let results = [];\n    for (let i = 0, len = query.length; i < len; i += 1) {\n      const queryItem = query[i];\n\n      // 1. Handle multiple query match (i.e, once that are quoted, like `\"hello world\"`)\n      let found = false;\n      let idx = -1;\n      while (!found && ++idx < searchersLen) {\n        const searcher = searchers[idx];\n        let token = searcher.isMultiMatch(queryItem);\n        if (token) {\n          results.push(new searcher(token, options));\n          found = true;\n        }\n      }\n\n      if (found) {\n        continue\n      }\n\n      // 2. Handle single query matches (i.e, once that are *not* quoted)\n      idx = -1;\n      while (++idx < searchersLen) {\n        const searcher = searchers[idx];\n        let token = searcher.isSingleMatch(queryItem);\n        if (token) {\n          results.push(new searcher(token, options));\n          break\n        }\n      }\n    }\n\n    return results\n  })\n}\n\n// These extended matchers can return an array of matches, as opposed\n// to a singl match\nconst MultiMatchSet = new Set([FuzzyMatch.type, IncludeMatch.type]);\n\n/**\n * Command-like searching\n * ======================\n *\n * Given multiple search terms delimited by spaces.e.g. `^jscript .python$ ruby !java`,\n * search in a given text.\n *\n * Search syntax:\n *\n * | Token       | Match type                 | Description                            |\n * | ----------- | -------------------------- | -------------------------------------- |\n * | `jscript`   | fuzzy-match                | Items that fuzzy match `jscript`       |\n * | `=scheme`   | exact-match                | Items that are `scheme`                |\n * | `'python`   | include-match              | Items that include `python`            |\n * | `!ruby`     | inverse-exact-match        | Items that do not include `ruby`       |\n * | `^java`     | prefix-exact-match         | Items that start with `java`           |\n * | `!^earlang` | inverse-prefix-exact-match | Items that do not start with `earlang` |\n * | `.js$`      | suffix-exact-match         | Items that end with `.js`              |\n * | `!.go$`     | inverse-suffix-exact-match | Items that do not end with `.go`       |\n *\n * A single pipe character acts as an OR operator. For example, the following\n * query matches entries that start with `core` and end with either`go`, `rb`,\n * or`py`.\n *\n * ```\n * ^core go$ | rb$ | py$\n * ```\n */\nclass ExtendedSearch {\n  constructor(\n    pattern,\n    {\n      isCaseSensitive = Config.isCaseSensitive,\n      includeMatches = Config.includeMatches,\n      minMatchCharLength = Config.minMatchCharLength,\n      ignoreLocation = Config.ignoreLocation,\n      findAllMatches = Config.findAllMatches,\n      location = Config.location,\n      threshold = Config.threshold,\n      distance = Config.distance\n    } = {}\n  ) {\n    this.query = null;\n    this.options = {\n      isCaseSensitive,\n      includeMatches,\n      minMatchCharLength,\n      findAllMatches,\n      ignoreLocation,\n      location,\n      threshold,\n      distance\n    };\n\n    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();\n    this.query = parseQuery(this.pattern, this.options);\n  }\n\n  static condition(_, options) {\n    return options.useExtendedSearch\n  }\n\n  searchIn(text) {\n    const query = this.query;\n\n    if (!query) {\n      return {\n        isMatch: false,\n        score: 1\n      }\n    }\n\n    const { includeMatches, isCaseSensitive } = this.options;\n\n    text = isCaseSensitive ? text : text.toLowerCase();\n\n    let numMatches = 0;\n    let allIndices = [];\n    let totalScore = 0;\n\n    // ORs\n    for (let i = 0, qLen = query.length; i < qLen; i += 1) {\n      const searchers = query[i];\n\n      // Reset indices\n      allIndices.length = 0;\n      numMatches = 0;\n\n      // ANDs\n      for (let j = 0, pLen = searchers.length; j < pLen; j += 1) {\n        const searcher = searchers[j];\n        const { isMatch, indices, score } = searcher.search(text);\n\n        if (isMatch) {\n          numMatches += 1;\n          totalScore += score;\n          if (includeMatches) {\n            const type = searcher.constructor.type;\n            if (MultiMatchSet.has(type)) {\n              allIndices = [...allIndices, ...indices];\n            } else {\n              allIndices.push(indices);\n            }\n          }\n        } else {\n          totalScore = 0;\n          numMatches = 0;\n          allIndices.length = 0;\n          break\n        }\n      }\n\n      // OR condition, so if TRUE, return\n      if (numMatches) {\n        let result = {\n          isMatch: true,\n          score: totalScore / numMatches\n        };\n\n        if (includeMatches) {\n          result.indices = allIndices;\n        }\n\n        return result\n      }\n    }\n\n    // Nothing was matched\n    return {\n      isMatch: false,\n      score: 1\n    }\n  }\n}\n\nconst registeredSearchers = [];\n\nfunction register(...args) {\n  registeredSearchers.push(...args);\n}\n\nfunction createSearcher(pattern, options) {\n  for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {\n    let searcherClass = registeredSearchers[i];\n    if (searcherClass.condition(pattern, options)) {\n      return new searcherClass(pattern, options)\n    }\n  }\n\n  return new BitapSearch(pattern, options)\n}\n\nconst LogicalOperator = {\n  AND: '$and',\n  OR: '$or'\n};\n\nconst KeyType = {\n  PATH: '$path',\n  PATTERN: '$val'\n};\n\nconst isExpression = (query) =>\n  !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);\n\nconst isPath = (query) => !!query[KeyType.PATH];\n\nconst isLeaf = (query) =>\n  !isArray(query) && isObject(query) && !isExpression(query);\n\nconst convertToExplicit = (query) => ({\n  [LogicalOperator.AND]: Object.keys(query).map((key) => ({\n    [key]: query[key]\n  }))\n});\n\n// When `auto` is `true`, the parse function will infer and initialize and add\n// the appropriate `Searcher` instance\nfunction parse(query, options, { auto = true } = {}) {\n  const next = (query) => {\n    let keys = Object.keys(query);\n\n    const isQueryPath = isPath(query);\n\n    if (!isQueryPath && keys.length > 1 && !isExpression(query)) {\n      return next(convertToExplicit(query))\n    }\n\n    if (isLeaf(query)) {\n      const key = isQueryPath ? query[KeyType.PATH] : keys[0];\n\n      const pattern = isQueryPath ? query[KeyType.PATTERN] : query[key];\n\n      if (!isString(pattern)) {\n        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key))\n      }\n\n      const obj = {\n        keyId: createKeyId(key),\n        pattern\n      };\n\n      if (auto) {\n        obj.searcher = createSearcher(pattern, options);\n      }\n\n      return obj\n    }\n\n    let node = {\n      children: [],\n      operator: keys[0]\n    };\n\n    keys.forEach((key) => {\n      const value = query[key];\n\n      if (isArray(value)) {\n        value.forEach((item) => {\n          node.children.push(next(item));\n        });\n      }\n    });\n\n    return node\n  };\n\n  if (!isExpression(query)) {\n    query = convertToExplicit(query);\n  }\n\n  return next(query)\n}\n\n// Practical scoring function\nfunction computeScore(\n  results,\n  { ignoreFieldNorm = Config.ignoreFieldNorm }\n) {\n  results.forEach((result) => {\n    let totalScore = 1;\n\n    result.matches.forEach(({ key, norm, score }) => {\n      const weight = key ? key.weight : null;\n\n      totalScore *= Math.pow(\n        score === 0 && weight ? Number.EPSILON : score,\n        (weight || 1) * (ignoreFieldNorm ? 1 : norm)\n      );\n    });\n\n    result.score = totalScore;\n  });\n}\n\nfunction transformMatches(result, data) {\n  const matches = result.matches;\n  data.matches = [];\n\n  if (!isDefined(matches)) {\n    return\n  }\n\n  matches.forEach((match) => {\n    if (!isDefined(match.indices) || !match.indices.length) {\n      return\n    }\n\n    const { indices, value } = match;\n\n    let obj = {\n      indices,\n      value\n    };\n\n    if (match.key) {\n      obj.key = match.key.src;\n    }\n\n    if (match.idx > -1) {\n      obj.refIndex = match.idx;\n    }\n\n    data.matches.push(obj);\n  });\n}\n\nfunction transformScore(result, data) {\n  data.score = result.score;\n}\n\nfunction format(\n  results,\n  docs,\n  {\n    includeMatches = Config.includeMatches,\n    includeScore = Config.includeScore\n  } = {}\n) {\n  const transformers = [];\n\n  if (includeMatches) transformers.push(transformMatches);\n  if (includeScore) transformers.push(transformScore);\n\n  return results.map((result) => {\n    const { idx } = result;\n\n    const data = {\n      item: docs[idx],\n      refIndex: idx\n    };\n\n    if (transformers.length) {\n      transformers.forEach((transformer) => {\n        transformer(result, data);\n      });\n    }\n\n    return data\n  })\n}\n\nclass Fuse {\n  constructor(docs, options = {}, index) {\n    this.options = { ...Config, ...options };\n\n    if (\n      this.options.useExtendedSearch &&\n      !true\n    ) {\n      throw new Error(EXTENDED_SEARCH_UNAVAILABLE)\n    }\n\n    this._keyStore = new KeyStore(this.options.keys);\n\n    this.setCollection(docs, index);\n  }\n\n  setCollection(docs, index) {\n    this._docs = docs;\n\n    if (index && !(index instanceof FuseIndex)) {\n      throw new Error(INCORRECT_INDEX_TYPE)\n    }\n\n    this._myIndex =\n      index ||\n      createIndex(this.options.keys, this._docs, {\n        getFn: this.options.getFn,\n        fieldNormWeight: this.options.fieldNormWeight\n      });\n  }\n\n  add(doc) {\n    if (!isDefined(doc)) {\n      return\n    }\n\n    this._docs.push(doc);\n    this._myIndex.add(doc);\n  }\n\n  remove(predicate = (/* doc, idx */) => false) {\n    const results = [];\n\n    for (let i = 0, len = this._docs.length; i < len; i += 1) {\n      const doc = this._docs[i];\n      if (predicate(doc, i)) {\n        this.removeAt(i);\n        i -= 1;\n        len -= 1;\n\n        results.push(doc);\n      }\n    }\n\n    return results\n  }\n\n  removeAt(idx) {\n    this._docs.splice(idx, 1);\n    this._myIndex.removeAt(idx);\n  }\n\n  getIndex() {\n    return this._myIndex\n  }\n\n  search(query, { limit = -1 } = {}) {\n    const {\n      includeMatches,\n      includeScore,\n      shouldSort,\n      sortFn,\n      ignoreFieldNorm\n    } = this.options;\n\n    let results = isString(query)\n      ? isString(this._docs[0])\n        ? this._searchStringList(query)\n        : this._searchObjectList(query)\n      : this._searchLogical(query);\n\n    computeScore(results, { ignoreFieldNorm });\n\n    if (shouldSort) {\n      results.sort(sortFn);\n    }\n\n    if (isNumber(limit) && limit > -1) {\n      results = results.slice(0, limit);\n    }\n\n    return format(results, this._docs, {\n      includeMatches,\n      includeScore\n    })\n  }\n\n  _searchStringList(query) {\n    const searcher = createSearcher(query, this.options);\n    const { records } = this._myIndex;\n    const results = [];\n\n    // Iterate over every string in the index\n    records.forEach(({ v: text, i: idx, n: norm }) => {\n      if (!isDefined(text)) {\n        return\n      }\n\n      const { isMatch, score, indices } = searcher.searchIn(text);\n\n      if (isMatch) {\n        results.push({\n          item: text,\n          idx,\n          matches: [{ score, value: text, norm, indices }]\n        });\n      }\n    });\n\n    return results\n  }\n\n  _searchLogical(query) {\n\n    const expression = parse(query, this.options);\n\n    const evaluate = (node, item, idx) => {\n      if (!node.children) {\n        const { keyId, searcher } = node;\n\n        const matches = this._findMatches({\n          key: this._keyStore.get(keyId),\n          value: this._myIndex.getValueForItemAtKeyId(item, keyId),\n          searcher\n        });\n\n        if (matches && matches.length) {\n          return [\n            {\n              idx,\n              item,\n              matches\n            }\n          ]\n        }\n\n        return []\n      }\n\n      const res = [];\n      for (let i = 0, len = node.children.length; i < len; i += 1) {\n        const child = node.children[i];\n        const result = evaluate(child, item, idx);\n        if (result.length) {\n          res.push(...result);\n        } else if (node.operator === LogicalOperator.AND) {\n          return []\n        }\n      }\n      return res\n    };\n\n    const records = this._myIndex.records;\n    const resultMap = {};\n    const results = [];\n\n    records.forEach(({ $: item, i: idx }) => {\n      if (isDefined(item)) {\n        let expResults = evaluate(expression, item, idx);\n\n        if (expResults.length) {\n          // Dedupe when adding\n          if (!resultMap[idx]) {\n            resultMap[idx] = { idx, item, matches: [] };\n            results.push(resultMap[idx]);\n          }\n          expResults.forEach(({ matches }) => {\n            resultMap[idx].matches.push(...matches);\n          });\n        }\n      }\n    });\n\n    return results\n  }\n\n  _searchObjectList(query) {\n    const searcher = createSearcher(query, this.options);\n    const { keys, records } = this._myIndex;\n    const results = [];\n\n    // List is Array<Object>\n    records.forEach(({ $: item, i: idx }) => {\n      if (!isDefined(item)) {\n        return\n      }\n\n      let matches = [];\n\n      // Iterate over every key (i.e, path), and fetch the value at that key\n      keys.forEach((key, keyIndex) => {\n        matches.push(\n          ...this._findMatches({\n            key,\n            value: item[keyIndex],\n            searcher\n          })\n        );\n      });\n\n      if (matches.length) {\n        results.push({\n          idx,\n          item,\n          matches\n        });\n      }\n    });\n\n    return results\n  }\n  _findMatches({ key, value, searcher }) {\n    if (!isDefined(value)) {\n      return []\n    }\n\n    let matches = [];\n\n    if (isArray(value)) {\n      value.forEach(({ v: text, i: idx, n: norm }) => {\n        if (!isDefined(text)) {\n          return\n        }\n\n        const { isMatch, score, indices } = searcher.searchIn(text);\n\n        if (isMatch) {\n          matches.push({\n            score,\n            key,\n            value: text,\n            idx,\n            norm,\n            indices\n          });\n        }\n      });\n    } else {\n      const { v: text, n: norm } = value;\n\n      const { isMatch, score, indices } = searcher.searchIn(text);\n\n      if (isMatch) {\n        matches.push({ score, key, value: text, norm, indices });\n      }\n    }\n\n    return matches\n  }\n}\n\nFuse.version = '6.6.2';\nFuse.createIndex = createIndex;\nFuse.parseIndex = parseIndex;\nFuse.config = Config;\n\n{\n  Fuse.parseQuery = parse;\n}\n\n{\n  register(ExtendedSearch);\n}\n\nexport { Fuse as default };\n","var has = Object.prototype.hasOwnProperty;\n\nfunction find(iter, tar, key) {\n\tfor (key of iter.keys()) {\n\t\tif (dequal(key, tar)) return key;\n\t}\n}\n\nexport function dequal(foo, bar) {\n\tvar ctor, len, tmp;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ctor === Set) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len;\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!bar.has(tmp)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === Map) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len[0];\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!dequal(len[1], bar.get(tmp))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === ArrayBuffer) {\n\t\t\tfoo = new Uint8Array(foo);\n\t\t\tbar = new Uint8Array(bar);\n\t\t} else if (ctor === DataView) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo.getInt8(len) === bar.getInt8(len));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ArrayBuffer.isView(foo)) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo[len] === bar[len]);\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n","import { dequal as deepEqual } from 'dequal';\n/**\n * Returns the element some number before the given index. If the target index is out of bounds:\n *   - If looping is disabled, the first element will be returned.\n *   - If looping is enabled, the last element will be returned.\n * @param array the array.\n * @param currentIndex the index of the current element.\n * @param increment the number of elements to move forward.\n * @param loop loop to the beginning of the array if the target index is out of bounds?\n */\nexport function back(array, index, increment, loop = true) {\n    const previousIndex = index - increment;\n    if (previousIndex <= 0) {\n        return loop ? array[array.length - 1] : array[0];\n    }\n    return array[previousIndex];\n}\n/**\n * Returns the element some number after the given index. If the target index is out of bounds:\n *   - If looping is disabled, the last element will be returned.\n *   - If looping is enabled, the first element will be returned.\n * @param array the array.\n * @param currentIndex the index of the current element.\n * @param increment the number of elements to move forward.\n * @param loop loop to the beginning of the array if the target index is out of bounds?\n */\nexport function forward(array, index, increment, loop = true) {\n    const nextIndex = index + increment;\n    if (nextIndex > array.length - 1) {\n        return loop ? array[0] : array[array.length - 1];\n    }\n    return array[nextIndex];\n}\n/**\n * Returns the array element after to the given index.\n * @param array the array.\n * @param currentIndex the index of the current element.\n * @param loop loop to the beginning of the array if the next index is out of bounds?\n */\nexport function next(array, index, loop = true) {\n    if (index === array.length - 1) {\n        return loop ? array[0] : array[index];\n    }\n    return array[index + 1];\n}\n/**\n * Returns the array element prior to the given index.\n * @param array the array.\n * @param currentIndex the index of the current element.\n * @param loop loop to the end of the array if the previous index is out of bounds?\n */\nexport function prev(array, currentIndex, loop = true) {\n    if (currentIndex <= 0) {\n        return loop ? array[array.length - 1] : array[0];\n    }\n    return array[currentIndex - 1];\n}\n/**\n * Returns the last element in an array.\n * @param array the array.\n */\nexport function last(array) {\n    return array[array.length - 1];\n}\n/**\n * Wraps an array around itself at a given starting index.\n * @example ```ts\n * wrapArray(['a', 'b', 'c', 'd'], 2);\n * // ['c', 'd', 'a', 'b']\n * ```\n * @see https://github.com/radix-ui/primitives\n */\nexport function wrapArray(array, startIndex) {\n    return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\nexport function toggle(item, array) {\n    const itemIdx = array.findIndex((i) => deepEqual(i, item));\n    if (itemIdx !== -1) {\n        array.splice(itemIdx, 1);\n    }\n    else {\n        array.push(item);\n    }\n    return array;\n}\n","export function lightable(value) {\n    function subscribe(run) {\n        run(value);\n        return () => {\n            // don't need to unsub from anything\n        };\n    }\n    return { subscribe };\n}\n","import { derived } from 'svelte/store';\nimport { isBrowser, isHTMLElement, noop } from './index.js';\nimport { lightable } from './store/lightable.js';\nexport function getElementByMeltId(id) {\n    if (!isBrowser)\n        return null;\n    const el = document.querySelector(`[data-melt-id=\"${id}\"]`);\n    return isHTMLElement(el) ? el : null;\n}\nexport const hiddenAction = (obj) => {\n    return new Proxy(obj, {\n        get(target, prop, receiver) {\n            return Reflect.get(target, prop, receiver);\n        },\n        ownKeys(target) {\n            return Reflect.ownKeys(target).filter((key) => key !== 'action');\n        },\n    });\n};\nconst isFunctionWithParams = (fn) => {\n    return typeof fn === 'function';\n};\nexport function builder(name, args) {\n    const { stores, action, returned } = args ?? {};\n    const derivedStore = (() => {\n        if (stores && returned) {\n            // If stores are provided, create a derived store from them\n            return derived(stores, (values) => {\n                const result = returned(values);\n                if (isFunctionWithParams(result)) {\n                    const fn = (...args) => {\n                        return hiddenAction({\n                            ...result(...args),\n                            [`data-melt-${name}`]: '',\n                            action: action ?? noop,\n                        });\n                    };\n                    fn.action = action ?? noop;\n                    return fn;\n                }\n                return hiddenAction({\n                    ...result,\n                    [`data-melt-${name}`]: '',\n                    action: action ?? noop,\n                });\n            });\n        }\n        else {\n            // If stores are not provided, return a lightable store, for consistency\n            const returnedFn = returned;\n            const result = returnedFn?.();\n            if (isFunctionWithParams(result)) {\n                const resultFn = (...args) => {\n                    return hiddenAction({\n                        ...result(...args),\n                        [`data-melt-${name}`]: '',\n                        action: action ?? noop,\n                    });\n                };\n                resultFn.action = action ?? noop;\n                return lightable(resultFn);\n            }\n            return lightable(hiddenAction({\n                ...result,\n                [`data-melt-${name}`]: '',\n                action: action ?? noop,\n            }));\n        }\n    })();\n    const actionFn = (action ??\n        (() => {\n            /** noop */\n        }));\n    actionFn.subscribe = derivedStore.subscribe;\n    return actionFn;\n}\nexport function createElHelpers(prefix) {\n    const name = (part) => (part ? `${prefix}-${part}` : prefix);\n    const attribute = (part) => `data-melt-${prefix}${part ? `-${part}` : ''}`;\n    const selector = (part) => `[data-melt-${prefix}${part ? `-${part}` : ''}]`;\n    const getEl = (part) => document.querySelector(selector(part));\n    return {\n        name,\n        attribute,\n        selector,\n        getEl,\n    };\n}\n","export const isBrowser = typeof document !== 'undefined';\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport const isFunction = (v) => typeof v === 'function';\nexport function isElement(element) {\n    return element instanceof Element;\n}\nexport function isHTMLElement(element) {\n    return element instanceof HTMLElement;\n}\nexport function isHTMLInputElement(element) {\n    return element instanceof HTMLInputElement;\n}\nexport function isElementDisabled(element) {\n    const ariaDisabled = element.getAttribute('aria-disabled');\n    const disabled = element.getAttribute('disabled');\n    const dataDisabled = element.hasAttribute('data-disabled');\n    if (ariaDisabled === 'true' || disabled !== null || dataDisabled) {\n        return true;\n    }\n    return false;\n}\nexport function isTouch(event) {\n    return event.pointerType === 'touch';\n}\nexport function isLeftClick(event) {\n    return event.button === 0 && event.ctrlKey === false && event.metaKey === false;\n}\nexport function isFocusVisible(element) {\n    return element.matches(':focus-visible');\n}\n","/**\n * Executes an array of callback functions with the same arguments.\n * @template T The types of the arguments that the callback functions take.\n * @param n array of callback functions to execute.\n * @returns A new function that executes all of the original callback functions with the same arguments.\n */\nexport function executeCallbacks(...callbacks) {\n    return (...args) => {\n        for (const callback of callbacks) {\n            if (typeof callback === 'function') {\n                callback(...args);\n            }\n        }\n    };\n}\n/**\n * A no operation function (does nothing)\n */\nexport function noop() {\n    //\n}\n","import { noop } from './callbacks.js';\nimport { isHTMLElement } from './is.js';\n/**\n * Adds an event listener to the specified target element(s) for the given event(s), and returns a function to remove it.\n * @param target The target element(s) to add the event listener to.\n * @param event The event(s) to listen for.\n * @param handler The function to be called when the event is triggered.\n * @param options An optional object that specifies characteristics about the event listener.\n * @returns A function that removes the event listener from the target element(s).\n */\nexport function addEventListener(target, event, handler, options) {\n    const events = Array.isArray(event) ? event : [event];\n    // Add the event listener to each specified event for the target element(s).\n    events.forEach((_event) => target.addEventListener(_event, handler, options));\n    // Return a function that removes the event listener from the target element(s).\n    return () => {\n        events.forEach((_event) => target.removeEventListener(_event, handler, options));\n    };\n}\nexport function addMeltEventListener(target, event, handler, options) {\n    const events = Array.isArray(event) ? event : [event];\n    if (typeof handler === 'function') {\n        const handlerWithMelt = withMelt((_event) => handler(_event));\n        // Add the event listener to each specified event for the target element(s).\n        events.forEach((_event) => target.addEventListener(_event, handlerWithMelt, options));\n        // Return a function that removes the event listener from the target element(s).\n        return () => {\n            events.forEach((_event) => target.removeEventListener(_event, handlerWithMelt, options));\n        };\n    }\n    return () => noop();\n}\nexport function dispatchMeltEvent(originalEvent) {\n    const node = originalEvent.currentTarget;\n    if (!isHTMLElement(node))\n        return null;\n    const customMeltEvent = new CustomEvent(`m-${originalEvent.type}`, {\n        detail: {\n            originalEvent,\n        },\n        cancelable: true,\n    });\n    node.dispatchEvent(customMeltEvent);\n    return customMeltEvent;\n}\nexport function withMelt(handler) {\n    return (event) => {\n        const customEvent = dispatchMeltEvent(event);\n        if (customEvent?.defaultPrevented)\n            return;\n        return handler(event);\n    };\n}\n","export function addHighlight(element) {\n    element.setAttribute('data-highlighted', '');\n}\nexport function removeHighlight(element) {\n    element.removeAttribute('data-highlighted');\n}\n","import { isHTMLElement } from './is.js';\n/** Retrieves all option descendants of a given element. */\nexport function getOptions(el) {\n    return Array.from(el.querySelectorAll('[role=\"option\"]:not([data-disabled])')).filter((el) => isHTMLElement(el));\n}\n/** Retrieves the first option descendant of a given element. */\nexport function getFirstOption(el) {\n    const firstOption = el.querySelector('[role=\"option\"]:not([data-disabled])');\n    return isHTMLElement(firstOption) ? firstOption : null;\n}\n","export function omit(obj, ...keys) {\n    const result = {};\n    for (const key of Object.keys(obj)) {\n        if (!keys.includes(key)) {\n            result[key] = obj[key];\n        }\n    }\n    return result;\n}\n","export const overridable = (store, onChange) => {\n    const update = (updater, sideEffect) => {\n        store.update((curr) => {\n            const next = updater(curr);\n            let res = next;\n            if (onChange) {\n                res = onChange({ curr, next });\n            }\n            sideEffect?.(res);\n            return res;\n        });\n    };\n    const set = (curr) => {\n        update(() => curr);\n    };\n    return {\n        ...store,\n        update,\n        set,\n    };\n};\n","export function sleep(ms) {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n}\n","/**\n * A utility function that converts a style object to a string.\n *\n * @param style - The style object to convert\n * @returns The style object as a string\n */\nexport function styleToString(style) {\n    return Object.keys(style).reduce((str, key) => {\n        if (style[key] === undefined)\n            return str;\n        return str + `${key}:${style[key]};`;\n    }, '');\n}\n","let urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nexport let customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nexport let nanoid = (size = 21) => {\n  let id = ''\n  let i = size\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\n","import { nanoid } from 'nanoid/non-secure';\n/**\n * A function that generates a random id\n * @returns An id\n */\nexport function generateId() {\n    return nanoid(10);\n}\n","/**\n * A constant object that maps commonly used keyboard keys to their corresponding string values.\n * This object can be used in other parts of the application to handle keyboard input and prevent\n * hard-coded strings throughout.\n */\nexport const kbd = {\n    ALT: 'Alt',\n    ARROW_DOWN: 'ArrowDown',\n    ARROW_LEFT: 'ArrowLeft',\n    ARROW_RIGHT: 'ArrowRight',\n    ARROW_UP: 'ArrowUp',\n    BACKSPACE: 'Backspace',\n    CAPS_LOCK: 'CapsLock',\n    CONTROL: 'Control',\n    DELETE: 'Delete',\n    END: 'End',\n    ENTER: 'Enter',\n    ESCAPE: 'Escape',\n    F1: 'F1',\n    F10: 'F10',\n    F11: 'F11',\n    F12: 'F12',\n    F2: 'F2',\n    F3: 'F3',\n    F4: 'F4',\n    F5: 'F5',\n    F6: 'F6',\n    F7: 'F7',\n    F8: 'F8',\n    F9: 'F9',\n    HOME: 'Home',\n    META: 'Meta',\n    PAGE_DOWN: 'PageDown',\n    PAGE_UP: 'PageUp',\n    SHIFT: 'Shift',\n    SPACE: ' ',\n    TAB: 'Tab',\n    CTRL: 'Control',\n};\n/** Key sets for navigation within lists, such as select, menu, and combobox. */\nexport const FIRST_KEYS = [kbd.ARROW_DOWN, kbd.PAGE_UP, kbd.HOME];\nexport const LAST_KEYS = [kbd.ARROW_UP, kbd.PAGE_DOWN, kbd.END];\nexport const FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];\nexport const SELECTION_KEYS = [kbd.ENTER, kbd.SPACE];\nexport const getNextKey = (dir = 'ltr', orientation = 'horizontal') => {\n    return {\n        horizontal: dir === 'rtl' ? kbd.ARROW_LEFT : kbd.ARROW_RIGHT,\n        vertical: kbd.ARROW_DOWN,\n    }[orientation];\n};\nexport const getPrevKey = (dir = 'ltr', orientation = 'horizontal') => {\n    return {\n        horizontal: dir === 'rtl' ? kbd.ARROW_RIGHT : kbd.ARROW_LEFT,\n        vertical: kbd.ARROW_UP,\n    }[orientation];\n};\nexport const getDirectionalKeys = (dir = 'ltr', orientation = 'horizontal') => {\n    return {\n        nextKey: getNextKey(dir, orientation),\n        prevKey: getPrevKey(dir, orientation),\n    };\n};\n","export const isDom = () => typeof window !== 'undefined';\nexport function getPlatform() {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const agent = navigator.userAgentData;\n    return agent?.platform ?? navigator.platform;\n}\nconst pt = (v) => isDom() && v.test(getPlatform());\nconst ua = (v) => isDom() && v.test(navigator.userAgent);\nconst vn = (v) => isDom() && v.test(navigator.vendor);\nexport const isTouchDevice = () => isDom() && !!navigator.maxTouchPoints;\nexport const isMac = () => pt(/^Mac/) && !isTouchDevice();\nexport const isIPhone = () => pt(/^iPhone/);\nexport const isSafari = () => isApple() && vn(/apple/i);\nexport const isFirefox = () => ua(/firefox\\//i);\nexport const isApple = () => pt(/mac|iphone|ipad|ipod/i);\nexport const isIos = () => isApple() && !isMac();\n","// Modified from @zag-js/remove-scroll v0.10.2 (2023-06-10)\n// Source: https://github.com/chakra-ui/zag\n// https://github.com/chakra-ui/zag/blob/main/packages/utilities/remove-scroll/src/index.ts\nimport { noop } from './callbacks.js';\nimport { isIos } from './platform.js';\nconst LOCK_CLASSNAME = 'data-melt-scroll-lock';\nfunction assignStyle(el, style) {\n    if (!el)\n        return;\n    const previousStyle = el.style.cssText;\n    Object.assign(el.style, style);\n    return () => {\n        el.style.cssText = previousStyle;\n    };\n}\nfunction setCSSProperty(el, property, value) {\n    if (!el)\n        return;\n    const previousValue = el.style.getPropertyValue(property);\n    el.style.setProperty(property, value);\n    return () => {\n        if (previousValue) {\n            el.style.setProperty(property, previousValue);\n        }\n        else {\n            el.style.removeProperty(property);\n        }\n    };\n}\nfunction getPaddingProperty(documentElement) {\n    // RTL <body> scrollbar\n    const documentLeft = documentElement.getBoundingClientRect().left;\n    const scrollbarX = Math.round(documentLeft) + documentElement.scrollLeft;\n    return scrollbarX ? 'paddingLeft' : 'paddingRight';\n}\nexport function removeScroll(_document) {\n    const doc = _document ?? document;\n    const win = doc.defaultView ?? window;\n    const { documentElement, body } = doc;\n    const locked = body.hasAttribute(LOCK_CLASSNAME);\n    if (locked)\n        return noop;\n    body.setAttribute(LOCK_CLASSNAME, '');\n    const scrollbarWidth = win.innerWidth - documentElement.clientWidth;\n    const setScrollbarWidthProperty = () => setCSSProperty(documentElement, '--scrollbar-width', `${scrollbarWidth}px`);\n    const paddingProperty = getPaddingProperty(documentElement);\n    const scrollbarSidePadding = win.getComputedStyle(body)[paddingProperty];\n    const setStyle = () => assignStyle(body, {\n        overflow: 'hidden',\n        [paddingProperty]: `calc(${scrollbarSidePadding} + ${scrollbarWidth}px)`,\n    });\n    // Only iOS doesn't respect `overflow: hidden` on document.body\n    const setIOSStyle = () => {\n        const { scrollX, scrollY, visualViewport } = win;\n        // iOS 12 does not support `visuaViewport`.\n        const offsetLeft = visualViewport?.offsetLeft ?? 0;\n        const offsetTop = visualViewport?.offsetTop ?? 0;\n        const restoreStyle = assignStyle(body, {\n            position: 'fixed',\n            overflow: 'hidden',\n            top: `${-(scrollY - Math.floor(offsetTop))}px`,\n            left: `${-(scrollX - Math.floor(offsetLeft))}px`,\n            right: '0',\n            [paddingProperty]: `calc(${scrollbarSidePadding} + ${scrollbarWidth}px)`,\n        });\n        return () => {\n            restoreStyle?.();\n            win.scrollTo(scrollX, scrollY);\n        };\n    };\n    const cleanups = [setScrollbarWidthProperty(), isIos() ? setIOSStyle() : setStyle()];\n    return () => {\n        cleanups.forEach((fn) => fn?.());\n        body.removeAttribute(LOCK_CLASSNAME);\n    };\n}\n","import { derived } from 'svelte/store';\n/**\n * Helper function to standardize the way we derive a visible state for the\n * popper/floating elements.\n */\nexport function derivedVisible(obj) {\n    const { open, forceVisible, activeTrigger } = obj;\n    return derived([open, forceVisible, activeTrigger], ([$open, $forceVisible, $activeTrigger]) => ($open || $forceVisible) && $activeTrigger !== null);\n}\n","import { onDestroy } from 'svelte';\nimport { derived } from 'svelte/store';\n/**\n * A utility function that creates a derived store that automatically\n * unsubscribes from its dependencies.\n *\n * @template S - The type of the stores object\n * @template T - The type of the derived store\n * @param stores - The stores object to derive from\n * @param fn - The function to derive the store from\n * @returns A derived store that automatically unsubscribes from its dependencies\n */\nexport function derivedWithUnsubscribe(stores, fn) {\n    let unsubscribers = [];\n    const onUnsubscribe = (cb) => {\n        unsubscribers.push(cb);\n    };\n    const unsubscribe = () => {\n        // console.log('dfu unsubscribing');\n        // Call all of the unsubscribe functions from the previous run of the function\n        unsubscribers.forEach((fn) => fn());\n        // Clear the list of unsubscribe functions\n        unsubscribers = [];\n    };\n    const derivedStore = derived(stores, ($storeValues) => {\n        unsubscribe();\n        return fn($storeValues, onUnsubscribe);\n    });\n    onDestroy(unsubscribe);\n    const subscribe = (...args) => {\n        const unsub = derivedStore.subscribe(...args);\n        return () => {\n            unsub();\n            unsubscribe();\n        };\n    };\n    return {\n        ...derivedStore,\n        subscribe,\n    };\n}\n","import { onDestroy } from 'svelte';\nimport { derivedWithUnsubscribe } from './derivedWithUnsubscribe';\n/**\n * A utility function that creates an effect from a set of stores and a function.\n * The effect is automatically cleaned up when the component is destroyed.\n *\n * @template S - The type of the stores object\n * @param stores - The stores object to derive from\n * @param fn - The function to run when the stores change\n * @returns A function that can be used to unsubscribe the effect\n */\nexport function effect(stores, fn) {\n    // Create a derived store that contains the stores object and an onUnsubscribe function\n    const unsub = derivedWithUnsubscribe(stores, (stores, onUnsubscribe) => {\n        return {\n            stores,\n            onUnsubscribe,\n        };\n    }).subscribe(({ stores, onUnsubscribe }) => {\n        const returned = fn(stores);\n        // If the function returns a cleanup function, call it when the effect is unsubscribed\n        if (returned) {\n            onUnsubscribe(returned);\n        }\n    });\n    // Automatically unsubscribe the effect when the component is destroyed\n    onDestroy(unsub);\n    return unsub;\n}\n","import { writable } from 'svelte/store';\nexport function debounceable(initialValue, wait = 0) {\n    const store = writable({ value: initialValue, debounced: initialValue });\n    let timeout;\n    function debouncedSet(value) {\n        store.update((state) => {\n            state.value = value;\n            return state;\n        });\n        if (timeout) {\n            clearTimeout(timeout);\n        }\n        timeout = setTimeout(() => {\n            store.update((state) => {\n                state.debounced = state.value;\n                return state;\n            });\n        }, wait);\n    }\n    function debouncedUpdate(fn) {\n        store.update((state) => {\n            state.value = fn(state.value);\n            return state;\n        });\n        if (timeout) {\n            clearTimeout(timeout);\n        }\n        timeout = setTimeout(() => {\n            store.update((state) => {\n                state.debounced = state.value;\n                return state;\n            });\n        }, wait);\n    }\n    function set(value) {\n        store.update((state) => {\n            state.value = value;\n            state.debounced = value;\n            return state;\n        });\n    }\n    function update(fn) {\n        store.update((state) => {\n            state.value = fn(state.value);\n            state.debounced = state.value;\n            return state;\n        });\n    }\n    return {\n        ...store,\n        debouncedSet,\n        debouncedUpdate,\n        set,\n        update,\n    };\n}\n","import { writable } from 'svelte/store';\n/**\n * Given an object of properties, returns an object of writable stores\n * with the same properties and values.\n */\nexport function toWritableStores(properties) {\n    const result = {};\n    Object.keys(properties).forEach((key) => {\n        const propertyKey = key;\n        const value = properties[propertyKey];\n        result[propertyKey] = writable(value);\n    });\n    return result;\n}\n","import { isHTMLElement } from './is.js';\n/**\n * Get an element's ancestor which has a `data-portal` attribute.\n * This is used to handle nested portals/overlays/dialogs/popovers.\n */\nfunction getPortalParent(node) {\n    let parent = node.parentElement;\n    while (isHTMLElement(parent) && !parent.hasAttribute('data-portal')) {\n        parent = parent.parentElement;\n    }\n    return parent || 'body';\n}\nexport function getPortalDestination(node, portalProp) {\n    const portalParent = getPortalParent(node);\n    if (portalProp !== undefined)\n        return portalProp;\n    if (portalParent === 'body')\n        return document.body;\n    return null;\n}\n","// Modified from Grail UI v0.9.6 (2023-06-10)\n// Source: https://github.com/grail-ui/grail-ui\n// https://github.com/grail-ui/grail-ui/tree/master/packages/grail-ui/src/clickOutside/clickOutside.ts\nimport { readable } from 'svelte/store';\nimport { addEventListener } from '../../helpers/event.js';\nimport { get } from 'svelte/store';\nimport { isFunction } from '../../helpers/is.js';\n/**\n * Creates a readable store that tracks the latest PointerEvent that occurred on the document.\n *\n * @returns A function to unsubscribe from the event listener and stop tracking pointer events.\n */\nconst documentClickStore = readable(undefined, (set) => {\n    /**\n     * Event handler for pointerdown events on the document.\n     * Updates the store's value with the latest PointerEvent and then resets it to undefined.\n     */\n    function clicked(event) {\n        set(event);\n        // New subscriptions will not trigger immediately\n        set(undefined);\n    }\n    // Adds a pointerdown event listener to the document, calling the clicked function when triggered.\n    const unsubscribe = addEventListener(document, 'pointerdown', clicked, {\n        passive: false,\n        capture: true,\n    });\n    // Returns a function to unsubscribe from the event listener and stop tracking pointer events.\n    return unsubscribe;\n});\nexport const useClickOutside = (node, config = {}) => {\n    let options = { enabled: true, ...config };\n    // Returns true if the click outside handler is enabled\n    function isEnabled() {\n        return typeof options.enabled === 'boolean' ? options.enabled : get(options.enabled);\n    }\n    // Handle document clicks\n    const unsubscribe = documentClickStore.subscribe((e) => {\n        // If the click outside handler is disabled, or if the event is null or the node itself, return early\n        if (!isEnabled() || !e || e.target === node) {\n            return;\n        }\n        const composedPath = e.composedPath();\n        // If the target is in the node, return early\n        if (composedPath.includes(node))\n            return;\n        // If an ignore function is passed, check if it returns true\n        if (options.ignore) {\n            if (isFunction(options.ignore)) {\n                if (options.ignore(e))\n                    return;\n            }\n            // If an ignore array is passed, check if any elements in the array match the target\n            else if (Array.isArray(options.ignore)) {\n                if (options.ignore.length > 0 &&\n                    options.ignore.some((ignoreEl) => {\n                        return ignoreEl && (e.target === ignoreEl || composedPath.includes(ignoreEl));\n                    }))\n                    return;\n            }\n        }\n        // If none of the above conditions are met, call the handler\n        options.handler?.(e);\n    });\n    return {\n        update(params) {\n            options = { ...options, ...params };\n        },\n        destroy() {\n            unsubscribe();\n        },\n    };\n};\n","import { readable } from 'svelte/store';\nimport { addEventListener } from '../../helpers/event.js';\nimport { get } from 'svelte/store';\nimport { isFunction, isHTMLElement } from '../../helpers/is.js';\nimport { kbd } from '../../helpers/index.js';\n/**\n * Creates a readable store that tracks the latest Escape Keydown that occurred on the document.\n *\n * @returns A function to unsubscribe from the event listener and stop tracking keydown events.\n */\nconst documentEscapeKeyStore = readable(undefined, (set) => {\n    /**\n     * Event handler for keydown events on the document.\n     * Updates the store's value with the latest Escape Keydown event and then resets it to undefined.\n     */\n    function keydown(event) {\n        if (event && event.key === kbd.ESCAPE) {\n            set(event);\n        }\n        // New subscriptions will not trigger immediately\n        set(undefined);\n    }\n    // Adds a keydown event listener to the document, calling the keydown function when triggered.\n    const unsubscribe = addEventListener(document, 'keydown', keydown, {\n        passive: false,\n        capture: true,\n    });\n    // Returns a function to unsubscribe from the event listener and stop tracking keydown events.\n    return unsubscribe;\n});\nexport const useEscapeKeydown = (node, config = {}) => {\n    node.dataset.escapee = '';\n    let options = { enabled: true, ...config };\n    // Returns true if the escape keydown handler is enabled\n    function isEnabled() {\n        return typeof options.enabled === 'boolean' ? options.enabled : get(options.enabled);\n    }\n    // Handle escape keydowns\n    const unsubscribe = documentEscapeKeyStore.subscribe((e) => {\n        if (!e || !isEnabled())\n            return;\n        const target = e.target;\n        if (!isHTMLElement(target) || target.closest('[data-escapee]') !== node) {\n            return;\n        }\n        // If an ignore function is passed, check if it returns true\n        if (options.ignore) {\n            if (isFunction(options.ignore)) {\n                if (options.ignore(e))\n                    return;\n            }\n            // If an ignore array is passed, check if any elements in the array match the target\n            else if (Array.isArray(options.ignore)) {\n                if (options.ignore.length > 0 &&\n                    options.ignore.some((ignoreEl) => {\n                        return ignoreEl && target === ignoreEl;\n                    }))\n                    return;\n            }\n        }\n        // If none of the above conditions are met, call the handler\n        options.handler?.(e);\n    });\n    return {\n        update(params) {\n            options = { ...options, ...params };\n        },\n        destroy() {\n            node.removeAttribute('data-escapee');\n            unsubscribe();\n        },\n    };\n};\n","const sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nfunction getSideAxis(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  return {\n    ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n","import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n      continue;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    ...rects.floating,\n    x,\n    y\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. This stops `shift()` from taking action, but can\n    // be worked around by calling it again after the `arrow()` if desired.\n    const shouldAddOffset = getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? min$1 - center : max - center : 0;\n    return {\n      [axis]: coords[axis] - alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset + alignmentOffset\n      }\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const side = getSide(placement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle.\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$map$so;\n                const placement = (_overflowsData$map$so = overflowsData.map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: diffCoords\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element â€”\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const overflowAvailableHeight = height - overflow[heightSide];\n      const overflowAvailableWidth = width - overflow[widthSide];\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if (isYAxis) {\n        const maximumClippingWidth = width - overflow.left - overflow.right;\n        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;\n      } else {\n        const maximumClippingHeight = height - overflow.top - overflow.bottom;\n        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n","function getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null ? void 0 : (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  // Browsers without `ShadowRoot` support.\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  const webkit = isWebKit();\n  const css = getComputedStyle(element);\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = getParentNode(currentNode);\n    }\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor));\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isWebKit };\n","import { rectToClientRect, computePosition as computePosition$1 } from '@floating-ui/core';\nexport { arrow, autoPlacement, detectOverflow, flip, hide, inline, limitShift, offset, shift, size } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getDocumentElement, getNodeName, isOverflowElement, getNodeScroll, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentIFrame = win.frameElement;\n    while (currentIFrame && offsetParent && offsetWin !== win) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentIFrame = getWindow(currentIFrame).frameElement;\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      ...clippingAncestor,\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  return getCssDimensions(element);\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  return element.offsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const window = getWindow(element);\n  if (!isHTMLElement(element)) {\n    return window;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nconst getElementRects = async function (_ref) {\n  let {\n    reference,\n    floating,\n    strategy\n  } = _ref;\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  return {\n    reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      ...(await getDimensionsFn(floating))\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    clearTimeout(timeoutId);\n    io && io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = element.getBoundingClientRect();\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 100);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          resizeObserver && resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo && cleanupIo();\n    resizeObserver && resizeObserver.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { autoUpdate, computePosition, platform };\n","// Modified from Grail UI v0.9.6 (2023-06-10)\n// Source: https://github.com/grail-ui/grail-ui\n// https://github.com/grail-ui/grail-ui/tree/master/packages/grail-ui/src/floating/placement.ts\nimport { flip, offset, arrow, shift, size, computePosition, autoUpdate, } from '@floating-ui/dom';\nimport { isHTMLElement, noop } from '../../helpers/index.js';\nconst defaultConfig = {\n    strategy: 'absolute',\n    placement: 'top',\n    gutter: 5,\n    flip: true,\n    sameWidth: false,\n    overflowPadding: 8,\n};\nconst ARROW_TRANSFORM = {\n    bottom: 'rotate(45deg)',\n    left: 'rotate(135deg)',\n    top: 'rotate(225deg)',\n    right: 'rotate(315deg)',\n};\nexport function useFloating(reference, floating, opts = {}) {\n    if (!floating || !reference)\n        return {\n            destroy: noop,\n        };\n    const options = { ...defaultConfig, ...opts };\n    const arrowEl = floating.querySelector('[data-arrow=true]');\n    const middleware = [];\n    if (options.flip) {\n        middleware.push(flip({\n            boundary: options.boundary,\n            padding: options.overflowPadding,\n        }));\n    }\n    const arrowOffset = isHTMLElement(arrowEl) ? arrowEl.offsetHeight / 2 : 0;\n    if (options.gutter || options.offset) {\n        const data = options.gutter ? { mainAxis: options.gutter } : options.offset;\n        if (data?.mainAxis != null) {\n            data.mainAxis += arrowOffset;\n        }\n        middleware.push(offset(data));\n    }\n    middleware.push(shift({\n        boundary: options.boundary,\n        crossAxis: options.overlap,\n        padding: options.overflowPadding,\n    }));\n    if (arrowEl) {\n        middleware.push(arrow({ element: arrowEl, padding: 8 }));\n    }\n    middleware.push(size({\n        padding: options.overflowPadding,\n        apply({ rects, availableHeight, availableWidth }) {\n            if (options.sameWidth) {\n                Object.assign(floating.style, {\n                    width: `${Math.round(rects.reference.width)}px`,\n                    minWidth: 'unset',\n                });\n            }\n            if (options.fitViewport) {\n                Object.assign(floating.style, {\n                    maxWidth: `${availableWidth}px`,\n                    maxHeight: `${availableHeight}px`,\n                });\n            }\n        },\n    }));\n    function compute() {\n        if (!reference || !floating)\n            return;\n        const { placement, strategy } = options;\n        computePosition(reference, floating, {\n            placement,\n            middleware,\n            strategy,\n        }).then((data) => {\n            const x = Math.round(data.x);\n            const y = Math.round(data.y);\n            Object.assign(floating.style, {\n                top: `${y}px`,\n                left: `${x}px`,\n            });\n            if (isHTMLElement(arrowEl) && data.middlewareData.arrow) {\n                const { x, y } = data.middlewareData.arrow;\n                const dir = data.placement.split('-')[0];\n                Object.assign(arrowEl.style, {\n                    position: 'absolute',\n                    left: x != null ? `${x}px` : '',\n                    top: y != null ? `${y}px` : '',\n                    [dir]: `calc(100% - ${arrowOffset}px)`,\n                    transform: ARROW_TRANSFORM[dir],\n                    backgroundColor: 'inherit',\n                    zIndex: 'inherit',\n                });\n            }\n            return data;\n        });\n    }\n    // Apply `position` to floating element prior to the computePosition() call.\n    Object.assign(floating.style, {\n        position: options.strategy,\n    });\n    return {\n        destroy: autoUpdate(reference, floating, compute),\n    };\n}\n","/*!\n* tabbable 6.2.0\n* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE\n*/\n// NOTE: separate `:not()` selectors has broader browser support than the newer\n//  `:not([inert], [inert] *)` (Feb 2023)\n// CAREFUL: JSDom does not support `:not([inert] *)` as a selector; using it causes\n//  the entire query to fail, resulting in no nodes found, which will break a lot\n//  of things... so we have to rely on JS to identify nodes inside an inert container\nvar candidateSelectors = ['input:not([inert])', 'select:not([inert])', 'textarea:not([inert])', 'a[href]:not([inert])', 'button:not([inert])', '[tabindex]:not(slot):not([inert])', 'audio[controls]:not([inert])', 'video[controls]:not([inert])', '[contenteditable]:not([contenteditable=\"false\"]):not([inert])', 'details>summary:first-of-type:not([inert])', 'details:not([inert])'];\nvar candidateSelector = /* #__PURE__ */candidateSelectors.join(',');\nvar NoElement = typeof Element === 'undefined';\nvar matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\nvar getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {\n  var _element$getRootNode;\n  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);\n} : function (element) {\n  return element === null || element === void 0 ? void 0 : element.ownerDocument;\n};\n\n/**\n * Determines if a node is inert or in an inert ancestor.\n * @param {Element} [node]\n * @param {boolean} [lookUp] If true and `node` is not inert, looks up at ancestors to\n *  see if any of them are inert. If false, only `node` itself is considered.\n * @returns {boolean} True if inert itself or by way of being in an inert ancestor.\n *  False if `node` is falsy.\n */\nvar isInert = function isInert(node, lookUp) {\n  var _node$getAttribute;\n  if (lookUp === void 0) {\n    lookUp = true;\n  }\n  // CAREFUL: JSDom does not support inert at all, so we can't use the `HTMLElement.inert`\n  //  JS API property; we have to check the attribute, which can either be empty or 'true';\n  //  if it's `null` (not specified) or 'false', it's an active element\n  var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, 'inert');\n  var inert = inertAtt === '' || inertAtt === 'true';\n\n  // NOTE: this could also be handled with `node.matches('[inert], :is([inert] *)')`\n  //  if it weren't for `matches()` not being a function on shadow roots; the following\n  //  code works for any kind of node\n  // CAREFUL: JSDom does not appear to support certain selectors like `:not([inert] *)`\n  //  so it likely would not support `:is([inert] *)` either...\n  var result = inert || lookUp && node && isInert(node.parentNode); // recursive\n\n  return result;\n};\n\n/**\n * Determines if a node's content is editable.\n * @param {Element} [node]\n * @returns True if it's content-editable; false if it's not or `node` is falsy.\n */\nvar isContentEditable = function isContentEditable(node) {\n  var _node$getAttribute2;\n  // CAREFUL: JSDom does not support the `HTMLElement.isContentEditable` API so we have\n  //  to use the attribute directly to check for this, which can either be empty or 'true';\n  //  if it's `null` (not specified) or 'false', it's a non-editable element\n  var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, 'contenteditable');\n  return attValue === '' || attValue === 'true';\n};\n\n/**\n * @param {Element} el container to check in\n * @param {boolean} includeContainer add container to check\n * @param {(node: Element) => boolean} filter filter candidates\n * @returns {Element[]}\n */\nvar getCandidates = function getCandidates(el, includeContainer, filter) {\n  // even if `includeContainer=false`, we still have to check it for inertness because\n  //  if it's inert, all its children are inert\n  if (isInert(el)) {\n    return [];\n  }\n  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));\n  if (includeContainer && matches.call(el, candidateSelector)) {\n    candidates.unshift(el);\n  }\n  candidates = candidates.filter(filter);\n  return candidates;\n};\n\n/**\n * @callback GetShadowRoot\n * @param {Element} element to check for shadow root\n * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.\n */\n\n/**\n * @callback ShadowRootFilter\n * @param {Element} shadowHostNode the element which contains shadow content\n * @returns {boolean} true if a shadow root could potentially contain valid candidates.\n */\n\n/**\n * @typedef {Object} CandidateScope\n * @property {Element} scopeParent contains inner candidates\n * @property {Element[]} candidates list of candidates found in the scope parent\n */\n\n/**\n * @typedef {Object} IterativeOptions\n * @property {GetShadowRoot|boolean} getShadowRoot true if shadow support is enabled; falsy if not;\n *  if a function, implies shadow support is enabled and either returns the shadow root of an element\n *  or a boolean stating if it has an undisclosed shadow root\n * @property {(node: Element) => boolean} filter filter candidates\n * @property {boolean} flatten if true then result will flatten any CandidateScope into the returned list\n * @property {ShadowRootFilter} shadowRootFilter filter shadow roots;\n */\n\n/**\n * @param {Element[]} elements list of element containers to match candidates from\n * @param {boolean} includeContainer add container list to check\n * @param {IterativeOptions} options\n * @returns {Array.<Element|CandidateScope>}\n */\nvar getCandidatesIteratively = function getCandidatesIteratively(elements, includeContainer, options) {\n  var candidates = [];\n  var elementsToCheck = Array.from(elements);\n  while (elementsToCheck.length) {\n    var element = elementsToCheck.shift();\n    if (isInert(element, false)) {\n      // no need to look up since we're drilling down\n      // anything inside this container will also be inert\n      continue;\n    }\n    if (element.tagName === 'SLOT') {\n      // add shadow dom slot scope (slot itself cannot be focusable)\n      var assigned = element.assignedElements();\n      var content = assigned.length ? assigned : element.children;\n      var nestedCandidates = getCandidatesIteratively(content, true, options);\n      if (options.flatten) {\n        candidates.push.apply(candidates, nestedCandidates);\n      } else {\n        candidates.push({\n          scopeParent: element,\n          candidates: nestedCandidates\n        });\n      }\n    } else {\n      // check candidate element\n      var validCandidate = matches.call(element, candidateSelector);\n      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {\n        candidates.push(element);\n      }\n\n      // iterate over shadow content if possible\n      var shadowRoot = element.shadowRoot ||\n      // check for an undisclosed shadow\n      typeof options.getShadowRoot === 'function' && options.getShadowRoot(element);\n\n      // no inert look up because we're already drilling down and checking for inertness\n      //  on the way down, so all containers to this root node should have already been\n      //  vetted as non-inert\n      var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));\n      if (shadowRoot && validShadowRoot) {\n        // add shadow dom scope IIF a shadow root node was given; otherwise, an undisclosed\n        //  shadow exists, so look at light dom children as fallback BUT create a scope for any\n        //  child candidates found because they're likely slotted elements (elements that are\n        //  children of the web component element (which has the shadow), in the light dom, but\n        //  slotted somewhere _inside_ the undisclosed shadow) -- the scope is created below,\n        //  _after_ we return from this recursive call\n        var _nestedCandidates = getCandidatesIteratively(shadowRoot === true ? element.children : shadowRoot.children, true, options);\n        if (options.flatten) {\n          candidates.push.apply(candidates, _nestedCandidates);\n        } else {\n          candidates.push({\n            scopeParent: element,\n            candidates: _nestedCandidates\n          });\n        }\n      } else {\n        // there's not shadow so just dig into the element's (light dom) children\n        //  __without__ giving the element special scope treatment\n        elementsToCheck.unshift.apply(elementsToCheck, element.children);\n      }\n    }\n  }\n  return candidates;\n};\n\n/**\n * @private\n * Determines if the node has an explicitly specified `tabindex` attribute.\n * @param {HTMLElement} node\n * @returns {boolean} True if so; false if not.\n */\nvar hasTabIndex = function hasTabIndex(node) {\n  return !isNaN(parseInt(node.getAttribute('tabindex'), 10));\n};\n\n/**\n * Determine the tab index of a given node.\n * @param {HTMLElement} node\n * @returns {number} Tab order (negative, 0, or positive number).\n * @throws {Error} If `node` is falsy.\n */\nvar getTabIndex = function getTabIndex(node) {\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (node.tabIndex < 0) {\n    // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\n    // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n    // yet they are still part of the regular tab order; in FF, they get a default\n    // `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n    // order, consider their tab index to be 0.\n    // Also browsers do not return `tabIndex` correctly for contentEditable nodes;\n    // so if they don't have a tabindex attribute specifically set, assume it's 0.\n    if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {\n      return 0;\n    }\n  }\n  return node.tabIndex;\n};\n\n/**\n * Determine the tab index of a given node __for sort order purposes__.\n * @param {HTMLElement} node\n * @param {boolean} [isScope] True for a custom element with shadow root or slot that, by default,\n *  has tabIndex -1, but needs to be sorted by document order in order for its content to be\n *  inserted into the correct sort position.\n * @returns {number} Tab order (negative, 0, or positive number).\n */\nvar getSortOrderTabIndex = function getSortOrderTabIndex(node, isScope) {\n  var tabIndex = getTabIndex(node);\n  if (tabIndex < 0 && isScope && !hasTabIndex(node)) {\n    return 0;\n  }\n  return tabIndex;\n};\nvar sortOrderedTabbables = function sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n};\nvar isInput = function isInput(node) {\n  return node.tagName === 'INPUT';\n};\nvar isHiddenInput = function isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n};\nvar isDetailsWithSummary = function isDetailsWithSummary(node) {\n  var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {\n    return child.tagName === 'SUMMARY';\n  });\n  return r;\n};\nvar getCheckedRadio = function getCheckedRadio(nodes, form) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked && nodes[i].form === form) {\n      return nodes[i];\n    }\n  }\n};\nvar isTabbableRadio = function isTabbableRadio(node) {\n  if (!node.name) {\n    return true;\n  }\n  var radioScope = node.form || getRootNode(node);\n  var queryRadios = function queryRadios(name) {\n    return radioScope.querySelectorAll('input[type=\"radio\"][name=\"' + name + '\"]');\n  };\n  var radioSet;\n  if (typeof window !== 'undefined' && typeof window.CSS !== 'undefined' && typeof window.CSS.escape === 'function') {\n    radioSet = queryRadios(window.CSS.escape(node.name));\n  } else {\n    try {\n      radioSet = queryRadios(node.name);\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error('Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s', err.message);\n      return false;\n    }\n  }\n  var checked = getCheckedRadio(radioSet, node.form);\n  return !checked || checked === node;\n};\nvar isRadio = function isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n};\nvar isNonTabbableRadio = function isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n};\n\n// determines if a node is ultimately attached to the window's document\nvar isNodeAttached = function isNodeAttached(node) {\n  var _nodeRoot;\n  // The root node is the shadow root if the node is in a shadow DOM; some document otherwise\n  //  (but NOT _the_ document; see second 'If' comment below for more).\n  // If rootNode is shadow root, it'll have a host, which is the element to which the shadow\n  //  is attached, and the one we need to check if it's in the document or not (because the\n  //  shadow, and all nodes it contains, is never considered in the document since shadows\n  //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,\n  //  is hidden, or is not in the document itself but is detached, it will affect the shadow's\n  //  visibility, including all the nodes it contains). The host could be any normal node,\n  //  or a custom element (i.e. web component). Either way, that's the one that is considered\n  //  part of the document, not the shadow root, nor any of its children (i.e. the node being\n  //  tested).\n  // To further complicate things, we have to look all the way up until we find a shadow HOST\n  //  that is attached (or find none) because the node might be in nested shadows...\n  // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the\n  //  document (per the docs) and while it's a Document-type object, that document does not\n  //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer\n  //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,\n  //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when\n  //  node is actually detached.\n  // NOTE: If `nodeRootHost` or `node` happens to be the `document` itself (which is possible\n  //  if a tabbable/focusable node was quickly added to the DOM, focused, and then removed\n  //  from the DOM as in https://github.com/focus-trap/focus-trap-react/issues/905), then\n  //  `ownerDocument` will be `null`, hence the optional chaining on it.\n  var nodeRoot = node && getRootNode(node);\n  var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;\n\n  // in some cases, a detached node will return itself as the root instead of a document or\n  //  shadow root object, in which case, we shouldn't try to look further up the host chain\n  var attached = false;\n  if (nodeRoot && nodeRoot !== node) {\n    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;\n    attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));\n    while (!attached && nodeRootHost) {\n      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;\n      // since it's not attached and we have a root host, the node MUST be in a nested shadow DOM,\n      //  which means we need to get the host's host and check if that parent host is contained\n      //  in (i.e. attached to) the document\n      nodeRoot = getRootNode(nodeRootHost);\n      nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;\n      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));\n    }\n  }\n  return attached;\n};\nvar isZeroArea = function isZeroArea(node) {\n  var _node$getBoundingClie = node.getBoundingClientRect(),\n    width = _node$getBoundingClie.width,\n    height = _node$getBoundingClie.height;\n  return width === 0 && height === 0;\n};\nvar isHidden = function isHidden(node, _ref) {\n  var displayCheck = _ref.displayCheck,\n    getShadowRoot = _ref.getShadowRoot;\n  // NOTE: visibility will be `undefined` if node is detached from the document\n  //  (see notes about this further down), which means we will consider it visible\n  //  (this is legacy behavior from a very long way back)\n  // NOTE: we check this regardless of `displayCheck=\"none\"` because this is a\n  //  _visibility_ check, not a _display_ check\n  if (getComputedStyle(node).visibility === 'hidden') {\n    return true;\n  }\n  var isDirectSummary = matches.call(node, 'details>summary:first-of-type');\n  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;\n  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {\n    return true;\n  }\n  if (!displayCheck || displayCheck === 'full' || displayCheck === 'legacy-full') {\n    if (typeof getShadowRoot === 'function') {\n      // figure out if we should consider the node to be in an undisclosed shadow and use the\n      //  'non-zero-area' fallback\n      var originalNode = node;\n      while (node) {\n        var parentElement = node.parentElement;\n        var rootNode = getRootNode(node);\n        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow\n        ) {\n          // node has an undisclosed shadow which means we can only treat it as a black box, so we\n          //  fall back to a non-zero-area test\n          return isZeroArea(node);\n        } else if (node.assignedSlot) {\n          // iterate up slot\n          node = node.assignedSlot;\n        } else if (!parentElement && rootNode !== node.ownerDocument) {\n          // cross shadow boundary\n          node = rootNode.host;\n        } else {\n          // iterate up normal dom\n          node = parentElement;\n        }\n      }\n      node = originalNode;\n    }\n    // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support\n    //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or\n    //  it might be a falsy value, which means shadow DOM support is disabled\n\n    // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)\n    //  now we can just test to see if it would normally be visible or not, provided it's\n    //  attached to the main document.\n    // NOTE: We must consider case where node is inside a shadow DOM and given directly to\n    //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.\n\n    if (isNodeAttached(node)) {\n      // this works wherever the node is: if there's at least one client rect, it's\n      //  somehow displayed; it also covers the CSS 'display: contents' case where the\n      //  node itself is hidden in place of its contents; and there's no need to search\n      //  up the hierarchy either\n      return !node.getClientRects().length;\n    }\n\n    // Else, the node isn't attached to the document, which means the `getClientRects()`\n    //  API will __always__ return zero rects (this can happen, for example, if React\n    //  is used to render nodes onto a detached tree, as confirmed in this thread:\n    //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)\n    //\n    // It also means that even window.getComputedStyle(node).display will return `undefined`\n    //  because styles are only computed for nodes that are in the document.\n    //\n    // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable\n    //  somehow. Though it was never stated officially, anyone who has ever used tabbable\n    //  APIs on nodes in detached containers has actually implicitly used tabbable in what\n    //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck=\"none\"` mode -- essentially\n    //  considering __everything__ to be visible because of the innability to determine styles.\n    //\n    // v6.0.0: As of this major release, the default 'full' option __no longer treats detached\n    //  nodes as visible with the 'none' fallback.__\n    if (displayCheck !== 'legacy-full') {\n      return true; // hidden\n    }\n    // else, fallback to 'none' mode and consider the node visible\n  } else if (displayCheck === 'non-zero-area') {\n    // NOTE: Even though this tests that the node's client rect is non-zero to determine\n    //  whether it's displayed, and that a detached node will __always__ have a zero-area\n    //  client rect, we don't special-case for whether the node is attached or not. In\n    //  this mode, we do want to consider nodes that have a zero area to be hidden at all\n    //  times, and that includes attached or not.\n    return isZeroArea(node);\n  }\n\n  // visible, as far as we can tell, or per current `displayCheck=none` mode, we assume\n  //  it's visible\n  return false;\n};\n\n// form fields (nested) inside a disabled fieldset are not focusable/tabbable\n//  unless they are in the _first_ <legend> element of the top-most disabled\n//  fieldset\nvar isDisabledFromFieldset = function isDisabledFromFieldset(node) {\n  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {\n    var parentNode = node.parentElement;\n    // check if `node` is contained in a disabled <fieldset>\n    while (parentNode) {\n      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {\n        // look for the first <legend> among the children of the disabled <fieldset>\n        for (var i = 0; i < parentNode.children.length; i++) {\n          var child = parentNode.children.item(i);\n          // when the first <legend> (in document order) is found\n          if (child.tagName === 'LEGEND') {\n            // if its parent <fieldset> is not nested in another disabled <fieldset>,\n            // return whether `node` is a descendant of its first <legend>\n            return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);\n          }\n        }\n        // the disabled <fieldset> containing `node` has no <legend>\n        return true;\n      }\n      parentNode = parentNode.parentElement;\n    }\n  }\n\n  // else, node's tabbable/focusable state should not be affected by a fieldset's\n  //  enabled/disabled state\n  return false;\n};\nvar isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {\n  if (node.disabled ||\n  // we must do an inert look up to filter out any elements inside an inert ancestor\n  //  because we're limited in the type of selectors we can use in JSDom (see related\n  //  note related to `candidateSelectors`)\n  isInert(node) || isHiddenInput(node) || isHidden(node, options) ||\n  // For a details element with a summary, the summary element gets the focus\n  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {\n    return false;\n  }\n  return true;\n};\nvar isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(options, node) {\n  if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {\n    return false;\n  }\n  return true;\n};\nvar isValidShadowRootTabbable = function isValidShadowRootTabbable(shadowHostNode) {\n  var tabIndex = parseInt(shadowHostNode.getAttribute('tabindex'), 10);\n  if (isNaN(tabIndex) || tabIndex >= 0) {\n    return true;\n  }\n  // If a custom element has an explicit negative tabindex,\n  // browsers will not allow tab targeting said element's children.\n  return false;\n};\n\n/**\n * @param {Array.<Element|CandidateScope>} candidates\n * @returns Element[]\n */\nvar sortByOrder = function sortByOrder(candidates) {\n  var regularTabbables = [];\n  var orderedTabbables = [];\n  candidates.forEach(function (item, i) {\n    var isScope = !!item.scopeParent;\n    var element = isScope ? item.scopeParent : item;\n    var candidateTabindex = getSortOrderTabIndex(element, isScope);\n    var elements = isScope ? sortByOrder(item.candidates) : element;\n    if (candidateTabindex === 0) {\n      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        item: item,\n        isScope: isScope,\n        content: elements\n      });\n    }\n  });\n  return orderedTabbables.sort(sortOrderedTabbables).reduce(function (acc, sortable) {\n    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);\n    return acc;\n  }, []).concat(regularTabbables);\n};\nvar tabbable = function tabbable(container, options) {\n  options = options || {};\n  var candidates;\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([container], options.includeContainer, {\n      filter: isNodeMatchingSelectorTabbable.bind(null, options),\n      flatten: false,\n      getShadowRoot: options.getShadowRoot,\n      shadowRootFilter: isValidShadowRootTabbable\n    });\n  } else {\n    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));\n  }\n  return sortByOrder(candidates);\n};\nvar focusable = function focusable(container, options) {\n  options = options || {};\n  var candidates;\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([container], options.includeContainer, {\n      filter: isNodeMatchingSelectorFocusable.bind(null, options),\n      flatten: true,\n      getShadowRoot: options.getShadowRoot\n    });\n  } else {\n    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));\n  }\n  return candidates;\n};\nvar isTabbable = function isTabbable(node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, candidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorTabbable(options, node);\n};\nvar focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');\nvar isFocusable = function isFocusable(node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, focusableCandidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorFocusable(options, node);\n};\n\nexport { focusable, getTabIndex, isFocusable, isTabbable, tabbable };\n//# sourceMappingURL=index.esm.js.map\n","/*!\n* focus-trap 7.5.2\n* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE\n*/\nimport { isFocusable, tabbable, focusable, isTabbable, getTabIndex } from 'tabbable';\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\nvar activeFocusTraps = {\n  activateTrap: function activateTrap(trapStack, trap) {\n    if (trapStack.length > 0) {\n      var activeTrap = trapStack[trapStack.length - 1];\n      if (activeTrap !== trap) {\n        activeTrap.pause();\n      }\n    }\n    var trapIndex = trapStack.indexOf(trap);\n    if (trapIndex === -1) {\n      trapStack.push(trap);\n    } else {\n      // move this existing trap to the front of the queue\n      trapStack.splice(trapIndex, 1);\n      trapStack.push(trap);\n    }\n  },\n  deactivateTrap: function deactivateTrap(trapStack, trap) {\n    var trapIndex = trapStack.indexOf(trap);\n    if (trapIndex !== -1) {\n      trapStack.splice(trapIndex, 1);\n    }\n    if (trapStack.length > 0) {\n      trapStack[trapStack.length - 1].unpause();\n    }\n  }\n};\nvar isSelectableInput = function isSelectableInput(node) {\n  return node.tagName && node.tagName.toLowerCase() === 'input' && typeof node.select === 'function';\n};\nvar isEscapeEvent = function isEscapeEvent(e) {\n  return (e === null || e === void 0 ? void 0 : e.key) === 'Escape' || (e === null || e === void 0 ? void 0 : e.key) === 'Esc' || (e === null || e === void 0 ? void 0 : e.keyCode) === 27;\n};\nvar isTabEvent = function isTabEvent(e) {\n  return (e === null || e === void 0 ? void 0 : e.key) === 'Tab' || (e === null || e === void 0 ? void 0 : e.keyCode) === 9;\n};\n\n// checks for TAB by default\nvar isKeyForward = function isKeyForward(e) {\n  return isTabEvent(e) && !e.shiftKey;\n};\n\n// checks for SHIFT+TAB by default\nvar isKeyBackward = function isKeyBackward(e) {\n  return isTabEvent(e) && e.shiftKey;\n};\nvar delay = function delay(fn) {\n  return setTimeout(fn, 0);\n};\n\n// Array.find/findIndex() are not supported on IE; this replicates enough\n//  of Array.findIndex() for our needs\nvar findIndex = function findIndex(arr, fn) {\n  var idx = -1;\n  arr.every(function (value, i) {\n    if (fn(value)) {\n      idx = i;\n      return false; // break\n    }\n\n    return true; // next\n  });\n\n  return idx;\n};\n\n/**\n * Get an option's value when it could be a plain value, or a handler that provides\n *  the value.\n * @param {*} value Option's value to check.\n * @param {...*} [params] Any parameters to pass to the handler, if `value` is a function.\n * @returns {*} The `value`, or the handler's returned value.\n */\nvar valueOrHandler = function valueOrHandler(value) {\n  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    params[_key - 1] = arguments[_key];\n  }\n  return typeof value === 'function' ? value.apply(void 0, params) : value;\n};\nvar getActualTarget = function getActualTarget(event) {\n  // NOTE: If the trap is _inside_ a shadow DOM, event.target will always be the\n  //  shadow host. However, event.target.composedPath() will be an array of\n  //  nodes \"clicked\" from inner-most (the actual element inside the shadow) to\n  //  outer-most (the host HTML document). If we have access to composedPath(),\n  //  then use its first element; otherwise, fall back to event.target (and\n  //  this only works for an _open_ shadow DOM; otherwise,\n  //  composedPath()[0] === event.target always).\n  return event.target.shadowRoot && typeof event.composedPath === 'function' ? event.composedPath()[0] : event.target;\n};\n\n// NOTE: this must be _outside_ `createFocusTrap()` to make sure all traps in this\n//  current instance use the same stack if `userOptions.trapStack` isn't specified\nvar internalTrapStack = [];\nvar createFocusTrap = function createFocusTrap(elements, userOptions) {\n  // SSR: a live trap shouldn't be created in this type of environment so this\n  //  should be safe code to execute if the `document` option isn't specified\n  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;\n  var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;\n  var config = _objectSpread2({\n    returnFocusOnDeactivate: true,\n    escapeDeactivates: true,\n    delayInitialFocus: true,\n    isKeyForward: isKeyForward,\n    isKeyBackward: isKeyBackward\n  }, userOptions);\n  var state = {\n    // containers given to createFocusTrap()\n    // @type {Array<HTMLElement>}\n    containers: [],\n    // list of objects identifying tabbable nodes in `containers` in the trap\n    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap\n    //  is active, but the trap should never get to a state where there isn't at least one group\n    //  with at least one tabbable node in it (that would lead to an error condition that would\n    //  result in an error being thrown)\n    // @type {Array<{\n    //   container: HTMLElement,\n    //   tabbableNodes: Array<HTMLElement>, // empty if none\n    //   focusableNodes: Array<HTMLElement>, // empty if none\n    //   posTabIndexesFound: boolean,\n    //   firstTabbableNode: HTMLElement|undefined,\n    //   lastTabbableNode: HTMLElement|undefined,\n    //   firstDomTabbableNode: HTMLElement|undefined,\n    //   lastDomTabbableNode: HTMLElement|undefined,\n    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined\n    // }>}\n    containerGroups: [],\n    // same order/length as `containers` list\n\n    // references to objects in `containerGroups`, but only those that actually have\n    //  tabbable nodes in them\n    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__\n    //  the same length\n    tabbableGroups: [],\n    nodeFocusedBeforeActivation: null,\n    mostRecentlyFocusedNode: null,\n    active: false,\n    paused: false,\n    // timer ID for when delayInitialFocus is true and initial focus in this trap\n    //  has been delayed during activation\n    delayInitialFocusTimer: undefined,\n    // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any\n    recentNavEvent: undefined\n  };\n  var trap; // eslint-disable-line prefer-const -- some private functions reference it, and its methods reference private functions, so we must declare here and define later\n\n  /**\n   * Gets a configuration option value.\n   * @param {Object|undefined} configOverrideOptions If true, and option is defined in this set,\n   *  value will be taken from this object. Otherwise, value will be taken from base configuration.\n   * @param {string} optionName Name of the option whose value is sought.\n   * @param {string|undefined} [configOptionName] Name of option to use __instead of__ `optionName`\n   *  IIF `configOverrideOptions` is not defined. Otherwise, `optionName` is used.\n   */\n  var getOption = function getOption(configOverrideOptions, optionName, configOptionName) {\n    return configOverrideOptions && configOverrideOptions[optionName] !== undefined ? configOverrideOptions[optionName] : config[configOptionName || optionName];\n  };\n\n  /**\n   * Finds the index of the container that contains the element.\n   * @param {HTMLElement} element\n   * @param {Event} [event] If available, and `element` isn't directly found in any container,\n   *  the event's composed path is used to see if includes any known trap containers in the\n   *  case where the element is inside a Shadow DOM.\n   * @returns {number} Index of the container in either `state.containers` or\n   *  `state.containerGroups` (the order/length of these lists are the same); -1\n   *  if the element isn't found.\n   */\n  var findContainerIndex = function findContainerIndex(element, event) {\n    var composedPath = typeof (event === null || event === void 0 ? void 0 : event.composedPath) === 'function' ? event.composedPath() : undefined;\n    // NOTE: search `containerGroups` because it's possible a group contains no tabbable\n    //  nodes, but still contains focusable nodes (e.g. if they all have `tabindex=-1`)\n    //  and we still need to find the element in there\n    return state.containerGroups.findIndex(function (_ref) {\n      var container = _ref.container,\n        tabbableNodes = _ref.tabbableNodes;\n      return container.contains(element) || ( // fall back to explicit tabbable search which will take into consideration any\n      //  web components if the `tabbableOptions.getShadowRoot` option was used for\n      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't\n      //  look inside web components even if open)\n      composedPath === null || composedPath === void 0 ? void 0 : composedPath.includes(container)) || tabbableNodes.find(function (node) {\n        return node === element;\n      });\n    });\n  };\n\n  /**\n   * Gets the node for the given option, which is expected to be an option that\n   *  can be either a DOM node, a string that is a selector to get a node, `false`\n   *  (if a node is explicitly NOT given), or a function that returns any of these\n   *  values.\n   * @param {string} optionName\n   * @returns {undefined | false | HTMLElement | SVGElement} Returns\n   *  `undefined` if the option is not specified; `false` if the option\n   *  resolved to `false` (node explicitly not given); otherwise, the resolved\n   *  DOM node.\n   * @throws {Error} If the option is set, not `false`, and is not, or does not\n   *  resolve to a node.\n   */\n  var getNodeForOption = function getNodeForOption(optionName) {\n    var optionValue = config[optionName];\n    if (typeof optionValue === 'function') {\n      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        params[_key2 - 1] = arguments[_key2];\n      }\n      optionValue = optionValue.apply(void 0, params);\n    }\n    if (optionValue === true) {\n      optionValue = undefined; // use default value\n    }\n\n    if (!optionValue) {\n      if (optionValue === undefined || optionValue === false) {\n        return optionValue;\n      }\n      // else, empty string (invalid), null (invalid), 0 (invalid)\n\n      throw new Error(\"`\".concat(optionName, \"` was specified but was not a node, or did not return a node\"));\n    }\n    var node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point\n\n    if (typeof optionValue === 'string') {\n      node = doc.querySelector(optionValue); // resolve to node, or null if fails\n      if (!node) {\n        throw new Error(\"`\".concat(optionName, \"` as selector refers to no known node\"));\n      }\n    }\n    return node;\n  };\n  var getInitialFocusNode = function getInitialFocusNode() {\n    var node = getNodeForOption('initialFocus');\n\n    // false explicitly indicates we want no initialFocus at all\n    if (node === false) {\n      return false;\n    }\n    if (node === undefined || !isFocusable(node, config.tabbableOptions)) {\n      // option not specified nor focusable: use fallback options\n      if (findContainerIndex(doc.activeElement) >= 0) {\n        node = doc.activeElement;\n      } else {\n        var firstTabbableGroup = state.tabbableGroups[0];\n        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;\n\n        // NOTE: `fallbackFocus` option function cannot return `false` (not supported)\n        node = firstTabbableNode || getNodeForOption('fallbackFocus');\n      }\n    }\n    if (!node) {\n      throw new Error('Your focus-trap needs to have at least one focusable element');\n    }\n    return node;\n  };\n  var updateTabbableNodes = function updateTabbableNodes() {\n    state.containerGroups = state.containers.map(function (container) {\n      var tabbableNodes = tabbable(container, config.tabbableOptions);\n\n      // NOTE: if we have tabbable nodes, we must have focusable nodes; focusable nodes\n      //  are a superset of tabbable nodes since nodes with negative `tabindex` attributes\n      //  are focusable but not tabbable\n      var focusableNodes = focusable(container, config.tabbableOptions);\n      var firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : undefined;\n      var lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : undefined;\n      var firstDomTabbableNode = focusableNodes.find(function (node) {\n        return isTabbable(node);\n      });\n      var lastDomTabbableNode = focusableNodes.slice().reverse().find(function (node) {\n        return isTabbable(node);\n      });\n      var posTabIndexesFound = !!tabbableNodes.find(function (node) {\n        return getTabIndex(node) > 0;\n      });\n      return {\n        container: container,\n        tabbableNodes: tabbableNodes,\n        focusableNodes: focusableNodes,\n        /** True if at least one node with positive `tabindex` was found in this container. */\n        posTabIndexesFound: posTabIndexesFound,\n        /** First tabbable node in container, __tabindex__ order; `undefined` if none. */\n        firstTabbableNode: firstTabbableNode,\n        /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */\n        lastTabbableNode: lastTabbableNode,\n        // NOTE: DOM order is NOT NECESSARILY \"document position\" order, but figuring that out\n        //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\n        //  because that API doesn't work with Shadow DOM as well as it should (@see\n        //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,\n        //  to address an edge case related to positive tabindex support, this seems like a much easier,\n        //  \"close enough most of the time\" alternative for positive tabindexes which should generally\n        //  be avoided anyway...\n        /** First tabbable node in container, __DOM__ order; `undefined` if none. */\n        firstDomTabbableNode: firstDomTabbableNode,\n        /** Last tabbable node in container, __DOM__ order; `undefined` if none. */\n        lastDomTabbableNode: lastDomTabbableNode,\n        /**\n         * Finds the __tabbable__ node that follows the given node in the specified direction,\n         *  in this container, if any.\n         * @param {HTMLElement} node\n         * @param {boolean} [forward] True if going in forward tab order; false if going\n         *  in reverse.\n         * @returns {HTMLElement|undefined} The next tabbable node, if any.\n         */\n        nextTabbableNode: function nextTabbableNode(node) {\n          var forward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n          var nodeIdx = tabbableNodes.indexOf(node);\n          if (nodeIdx < 0) {\n            // either not tabbable nor focusable, or was focused but not tabbable (negative tabindex):\n            //  since `node` should at least have been focusable, we assume that's the case and mimic\n            //  what browsers do, which is set focus to the next node in __document position order__,\n            //  regardless of positive tabindexes, if any -- and for reasons explained in the NOTE\n            //  above related to `firstDomTabbable` and `lastDomTabbable` properties, we fall back to\n            //  basic DOM order\n            if (forward) {\n              return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find(function (el) {\n                return isTabbable(el);\n              });\n            }\n            return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find(function (el) {\n              return isTabbable(el);\n            });\n          }\n          return tabbableNodes[nodeIdx + (forward ? 1 : -1)];\n        }\n      };\n    });\n    state.tabbableGroups = state.containerGroups.filter(function (group) {\n      return group.tabbableNodes.length > 0;\n    });\n\n    // throw if no groups have tabbable nodes and we don't have a fallback focus node either\n    if (state.tabbableGroups.length <= 0 && !getNodeForOption('fallbackFocus') // returning false not supported for this option\n    ) {\n      throw new Error('Your focus-trap must have at least one container with at least one tabbable node in it at all times');\n    }\n\n    // NOTE: Positive tabindexes are only properly supported in single-container traps because\n    //  doing it across multiple containers where tabindexes could be all over the place\n    //  would require Tabbable to support multiple containers, would require additional\n    //  specialized Shadow DOM support, and would require Tabbable's multi-container support\n    //  to look at those containers in document position order rather than user-provided\n    //  order (as they are treated in Focus-trap, for legacy reasons). See discussion on\n    //  https://github.com/focus-trap/focus-trap/issues/375 for more details.\n    if (state.containerGroups.find(function (g) {\n      return g.posTabIndexesFound;\n    }) && state.containerGroups.length > 1) {\n      throw new Error(\"At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.\");\n    }\n  };\n  var tryFocus = function tryFocus(node) {\n    if (node === false) {\n      return;\n    }\n    if (node === doc.activeElement) {\n      return;\n    }\n    if (!node || !node.focus) {\n      tryFocus(getInitialFocusNode());\n      return;\n    }\n    node.focus({\n      preventScroll: !!config.preventScroll\n    });\n    // NOTE: focus() API does not trigger focusIn event so set MRU node manually\n    state.mostRecentlyFocusedNode = node;\n    if (isSelectableInput(node)) {\n      node.select();\n    }\n  };\n  var getReturnFocusNode = function getReturnFocusNode(previousActiveElement) {\n    var node = getNodeForOption('setReturnFocus', previousActiveElement);\n    return node ? node : node === false ? false : previousActiveElement;\n  };\n\n  /**\n   * Finds the next node (in either direction) where focus should move according to a\n   *  keyboard focus-in event.\n   * @param {Object} params\n   * @param {Node} [params.target] Known target __from which__ to navigate, if any.\n   * @param {KeyboardEvent|FocusEvent} [params.event] Event to use if `target` isn't known (event\n   *  will be used to determine the `target`). Ignored if `target` is specified.\n   * @param {boolean} [params.isBackward] True if focus should move backward.\n   * @returns {Node|undefined} The next node, or `undefined` if a next node couldn't be\n   *  determined given the current state of the trap.\n   */\n  var findNextNavNode = function findNextNavNode(_ref2) {\n    var target = _ref2.target,\n      event = _ref2.event,\n      _ref2$isBackward = _ref2.isBackward,\n      isBackward = _ref2$isBackward === void 0 ? false : _ref2$isBackward;\n    target = target || getActualTarget(event);\n    updateTabbableNodes();\n    var destinationNode = null;\n    if (state.tabbableGroups.length > 0) {\n      // make sure the target is actually contained in a group\n      // NOTE: the target may also be the container itself if it's focusable\n      //  with tabIndex='-1' and was given initial focus\n      var containerIndex = findContainerIndex(target, event);\n      var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : undefined;\n      if (containerIndex < 0) {\n        // target not found in any group: quite possible focus has escaped the trap,\n        //  so bring it back into...\n        if (isBackward) {\n          // ...the last node in the last group\n          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;\n        } else {\n          // ...the first node in the first group\n          destinationNode = state.tabbableGroups[0].firstTabbableNode;\n        }\n      } else if (isBackward) {\n        // REVERSE\n\n        // is the target the first tabbable node in a group?\n        var startOfGroupIndex = findIndex(state.tabbableGroups, function (_ref3) {\n          var firstTabbableNode = _ref3.firstTabbableNode;\n          return target === firstTabbableNode;\n        });\n        if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {\n          // an exception case where the target is either the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle shift+tab as if focus were on the container's\n          //  first tabbable node, and go to the last tabbable node of the LAST group\n          startOfGroupIndex = containerIndex;\n        }\n        if (startOfGroupIndex >= 0) {\n          // YES: then shift+tab should go to the last tabbable node in the\n          //  previous group (and wrap around to the last tabbable node of\n          //  the LAST group if it's the first tabbable node of the FIRST group)\n          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;\n          var destinationGroup = state.tabbableGroups[destinationGroupIndex];\n          destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;\n        } else if (!isTabEvent(event)) {\n          // user must have customized the nav keys so we have to move focus manually _within_\n          //  the active group: do this based on the order determined by tabbable()\n          destinationNode = containerGroup.nextTabbableNode(target, false);\n        }\n      } else {\n        // FORWARD\n\n        // is the target the last tabbable node in a group?\n        var lastOfGroupIndex = findIndex(state.tabbableGroups, function (_ref4) {\n          var lastTabbableNode = _ref4.lastTabbableNode;\n          return target === lastTabbableNode;\n        });\n        if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {\n          // an exception case where the target is the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle tab as if focus were on the container's\n          //  last tabbable node, and go to the first tabbable node of the FIRST group\n          lastOfGroupIndex = containerIndex;\n        }\n        if (lastOfGroupIndex >= 0) {\n          // YES: then tab should go to the first tabbable node in the next\n          //  group (and wrap around to the first tabbable node of the FIRST\n          //  group if it's the last tabbable node of the LAST group)\n          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;\n          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];\n          destinationNode = getTabIndex(target) >= 0 ? _destinationGroup.firstTabbableNode : _destinationGroup.firstDomTabbableNode;\n        } else if (!isTabEvent(event)) {\n          // user must have customized the nav keys so we have to move focus manually _within_\n          //  the active group: do this based on the order determined by tabbable()\n          destinationNode = containerGroup.nextTabbableNode(target);\n        }\n      }\n    } else {\n      // no groups available\n      // NOTE: the fallbackFocus option does not support returning false to opt-out\n      destinationNode = getNodeForOption('fallbackFocus');\n    }\n    return destinationNode;\n  };\n\n  // This needs to be done on mousedown and touchstart instead of click\n  // so that it precedes the focus event.\n  var checkPointerDown = function checkPointerDown(e) {\n    var target = getActualTarget(e);\n    if (findContainerIndex(target, e) >= 0) {\n      // allow the click since it ocurred inside the trap\n      return;\n    }\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      // immediately deactivate the trap\n      trap.deactivate({\n        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,\n        //  which will result in the outside click setting focus to the node\n        //  that was clicked (and if not focusable, to \"nothing\"); by setting\n        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused\n        //  on activation (or the configured `setReturnFocus` node), whether the\n        //  outside click was on a focusable node or not\n        returnFocus: config.returnFocusOnDeactivate\n      });\n      return;\n    }\n\n    // This is needed for mobile devices.\n    // (If we'll only let `click` events through,\n    // then on mobile they will be blocked anyways if `touchstart` is blocked.)\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      // allow the click outside the trap to take place\n      return;\n    }\n\n    // otherwise, prevent the click\n    e.preventDefault();\n  };\n\n  // In case focus escapes the trap for some strange reason, pull it back in.\n  // NOTE: the focusIn event is NOT cancelable, so if focus escapes, it may cause unexpected\n  //  scrolling if the node that got focused was out of view; there's nothing we can do to\n  //  prevent that from happening by the time we discover that focus escaped\n  var checkFocusIn = function checkFocusIn(event) {\n    var target = getActualTarget(event);\n    var targetContained = findContainerIndex(target, event) >= 0;\n\n    // In Firefox when you Tab out of an iframe the Document is briefly focused.\n    if (targetContained || target instanceof Document) {\n      if (targetContained) {\n        state.mostRecentlyFocusedNode = target;\n      }\n    } else {\n      // escaped! pull it back in to where it just left\n      event.stopImmediatePropagation();\n\n      // focus will escape if the MRU node had a positive tab index and user tried to nav forward;\n      //  it will also escape if the MRU node had a 0 tab index and user tried to nav backward\n      //  toward a node with a positive tab index\n      var nextNode; // next node to focus, if we find one\n      var navAcrossContainers = true;\n      if (state.mostRecentlyFocusedNode) {\n        if (getTabIndex(state.mostRecentlyFocusedNode) > 0) {\n          // MRU container index must be >=0 otherwise we wouldn't have it as an MRU node...\n          var mruContainerIdx = findContainerIndex(state.mostRecentlyFocusedNode);\n          // there MAY not be any tabbable nodes in the container if there are at least 2 containers\n          //  and the MRU node is focusable but not tabbable (focus-trap requires at least 1 container\n          //  with at least one tabbable node in order to function, so this could be the other container\n          //  with nothing tabbable in it)\n          var tabbableNodes = state.containerGroups[mruContainerIdx].tabbableNodes;\n          if (tabbableNodes.length > 0) {\n            // MRU tab index MAY not be found if the MRU node is focusable but not tabbable\n            var mruTabIdx = tabbableNodes.findIndex(function (node) {\n              return node === state.mostRecentlyFocusedNode;\n            });\n            if (mruTabIdx >= 0) {\n              if (config.isKeyForward(state.recentNavEvent)) {\n                if (mruTabIdx + 1 < tabbableNodes.length) {\n                  nextNode = tabbableNodes[mruTabIdx + 1];\n                  navAcrossContainers = false;\n                }\n                // else, don't wrap within the container as focus should move to next/previous\n                //  container\n              } else {\n                if (mruTabIdx - 1 >= 0) {\n                  nextNode = tabbableNodes[mruTabIdx - 1];\n                  navAcrossContainers = false;\n                }\n                // else, don't wrap within the container as focus should move to next/previous\n                //  container\n              }\n              // else, don't find in container order without considering direction too\n            }\n          }\n          // else, no tabbable nodes in that container (which means we must have at least one other\n          //  container with at least one tabbable node in it, otherwise focus-trap would've thrown\n          //  an error the last time updateTabbableNodes() was run): find next node among all known\n          //  containers\n        } else {\n          // check to see if there's at least one tabbable node with a positive tab index inside\n          //  the trap because focus seems to escape when navigating backward from a tabbable node\n          //  with tabindex=0 when this is the case (instead of wrapping to the tabbable node with\n          //  the greatest positive tab index like it should)\n          if (!state.containerGroups.some(function (g) {\n            return g.tabbableNodes.some(function (n) {\n              return getTabIndex(n) > 0;\n            });\n          })) {\n            // no containers with tabbable nodes with positive tab indexes which means the focus\n            //  escaped for some other reason and we should just execute the fallback to the\n            //  MRU node or initial focus node, if any\n            navAcrossContainers = false;\n          }\n        }\n      } else {\n        // no MRU node means we're likely in some initial condition when the trap has just\n        //  been activated and initial focus hasn't been given yet, in which case we should\n        //  fall through to trying to focus the initial focus node, which is what should\n        //  happen below at this point in the logic\n        navAcrossContainers = false;\n      }\n      if (navAcrossContainers) {\n        nextNode = findNextNavNode({\n          // move FROM the MRU node, not event-related node (which will be the node that is\n          //  outside the trap causing the focus escape we're trying to fix)\n          target: state.mostRecentlyFocusedNode,\n          isBackward: config.isKeyBackward(state.recentNavEvent)\n        });\n      }\n      if (nextNode) {\n        tryFocus(nextNode);\n      } else {\n        tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());\n      }\n    }\n    state.recentNavEvent = undefined; // clear\n  };\n\n  // Hijack key nav events on the first and last focusable nodes of the trap,\n  // in order to prevent focus from escaping. If it escapes for even a\n  // moment it can end up scrolling the page and causing confusion so we\n  // kind of need to capture the action at the keydown phase.\n  var checkKeyNav = function checkKeyNav(event) {\n    var isBackward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    state.recentNavEvent = event;\n    var destinationNode = findNextNavNode({\n      event: event,\n      isBackward: isBackward\n    });\n    if (destinationNode) {\n      if (isTabEvent(event)) {\n        // since tab natively moves focus, we wouldn't have a destination node unless we\n        //  were on the edge of a container and had to move to the next/previous edge, in\n        //  which case we want to prevent default to keep the browser from moving focus\n        //  to where it normally would\n        event.preventDefault();\n      }\n      tryFocus(destinationNode);\n    }\n    // else, let the browser take care of [shift+]tab and move the focus\n  };\n\n  var checkKey = function checkKey(event) {\n    if (isEscapeEvent(event) && valueOrHandler(config.escapeDeactivates, event) !== false) {\n      event.preventDefault();\n      trap.deactivate();\n      return;\n    }\n    if (config.isKeyForward(event) || config.isKeyBackward(event)) {\n      checkKeyNav(event, config.isKeyBackward(event));\n    }\n  };\n  var checkClick = function checkClick(e) {\n    var target = getActualTarget(e);\n    if (findContainerIndex(target, e) >= 0) {\n      return;\n    }\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      return;\n    }\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      return;\n    }\n    e.preventDefault();\n    e.stopImmediatePropagation();\n  };\n\n  //\n  // EVENT LISTENERS\n  //\n\n  var addListeners = function addListeners() {\n    if (!state.active) {\n      return;\n    }\n\n    // There can be only one listening focus trap at a time\n    activeFocusTraps.activateTrap(trapStack, trap);\n\n    // Delay ensures that the focused element doesn't capture the event\n    // that caused the focus trap activation.\n    state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function () {\n      tryFocus(getInitialFocusNode());\n    }) : tryFocus(getInitialFocusNode());\n    doc.addEventListener('focusin', checkFocusIn, true);\n    doc.addEventListener('mousedown', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('touchstart', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('click', checkClick, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('keydown', checkKey, {\n      capture: true,\n      passive: false\n    });\n    return trap;\n  };\n  var removeListeners = function removeListeners() {\n    if (!state.active) {\n      return;\n    }\n    doc.removeEventListener('focusin', checkFocusIn, true);\n    doc.removeEventListener('mousedown', checkPointerDown, true);\n    doc.removeEventListener('touchstart', checkPointerDown, true);\n    doc.removeEventListener('click', checkClick, true);\n    doc.removeEventListener('keydown', checkKey, true);\n    return trap;\n  };\n\n  //\n  // MUTATION OBSERVER\n  //\n\n  var checkDomRemoval = function checkDomRemoval(mutations) {\n    var isFocusedNodeRemoved = mutations.some(function (mutation) {\n      var removedNodes = Array.from(mutation.removedNodes);\n      return removedNodes.some(function (node) {\n        return node === state.mostRecentlyFocusedNode;\n      });\n    });\n\n    // If the currently focused is removed then browsers will move focus to the\n    // <body> element. If this happens, try to move focus back into the trap.\n    if (isFocusedNodeRemoved) {\n      tryFocus(getInitialFocusNode());\n    }\n  };\n\n  // Use MutationObserver - if supported - to detect if focused node is removed\n  // from the DOM.\n  var mutationObserver = typeof window !== 'undefined' && 'MutationObserver' in window ? new MutationObserver(checkDomRemoval) : undefined;\n  var updateObservedNodes = function updateObservedNodes() {\n    if (!mutationObserver) {\n      return;\n    }\n    mutationObserver.disconnect();\n    if (state.active && !state.paused) {\n      state.containers.map(function (container) {\n        mutationObserver.observe(container, {\n          subtree: true,\n          childList: true\n        });\n      });\n    }\n  };\n\n  //\n  // TRAP DEFINITION\n  //\n\n  trap = {\n    get active() {\n      return state.active;\n    },\n    get paused() {\n      return state.paused;\n    },\n    activate: function activate(activateOptions) {\n      if (state.active) {\n        return this;\n      }\n      var onActivate = getOption(activateOptions, 'onActivate');\n      var onPostActivate = getOption(activateOptions, 'onPostActivate');\n      var checkCanFocusTrap = getOption(activateOptions, 'checkCanFocusTrap');\n      if (!checkCanFocusTrap) {\n        updateTabbableNodes();\n      }\n      state.active = true;\n      state.paused = false;\n      state.nodeFocusedBeforeActivation = doc.activeElement;\n      onActivate === null || onActivate === void 0 ? void 0 : onActivate();\n      var finishActivation = function finishActivation() {\n        if (checkCanFocusTrap) {\n          updateTabbableNodes();\n        }\n        addListeners();\n        updateObservedNodes();\n        onPostActivate === null || onPostActivate === void 0 ? void 0 : onPostActivate();\n      };\n      if (checkCanFocusTrap) {\n        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);\n        return this;\n      }\n      finishActivation();\n      return this;\n    },\n    deactivate: function deactivate(deactivateOptions) {\n      if (!state.active) {\n        return this;\n      }\n      var options = _objectSpread2({\n        onDeactivate: config.onDeactivate,\n        onPostDeactivate: config.onPostDeactivate,\n        checkCanReturnFocus: config.checkCanReturnFocus\n      }, deactivateOptions);\n      clearTimeout(state.delayInitialFocusTimer); // noop if undefined\n      state.delayInitialFocusTimer = undefined;\n      removeListeners();\n      state.active = false;\n      state.paused = false;\n      updateObservedNodes();\n      activeFocusTraps.deactivateTrap(trapStack, trap);\n      var onDeactivate = getOption(options, 'onDeactivate');\n      var onPostDeactivate = getOption(options, 'onPostDeactivate');\n      var checkCanReturnFocus = getOption(options, 'checkCanReturnFocus');\n      var returnFocus = getOption(options, 'returnFocus', 'returnFocusOnDeactivate');\n      onDeactivate === null || onDeactivate === void 0 ? void 0 : onDeactivate();\n      var finishDeactivation = function finishDeactivation() {\n        delay(function () {\n          if (returnFocus) {\n            tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));\n          }\n          onPostDeactivate === null || onPostDeactivate === void 0 ? void 0 : onPostDeactivate();\n        });\n      };\n      if (returnFocus && checkCanReturnFocus) {\n        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);\n        return this;\n      }\n      finishDeactivation();\n      return this;\n    },\n    pause: function pause(pauseOptions) {\n      if (state.paused || !state.active) {\n        return this;\n      }\n      var onPause = getOption(pauseOptions, 'onPause');\n      var onPostPause = getOption(pauseOptions, 'onPostPause');\n      state.paused = true;\n      onPause === null || onPause === void 0 ? void 0 : onPause();\n      removeListeners();\n      updateObservedNodes();\n      onPostPause === null || onPostPause === void 0 ? void 0 : onPostPause();\n      return this;\n    },\n    unpause: function unpause(unpauseOptions) {\n      if (!state.paused || !state.active) {\n        return this;\n      }\n      var onUnpause = getOption(unpauseOptions, 'onUnpause');\n      var onPostUnpause = getOption(unpauseOptions, 'onPostUnpause');\n      state.paused = false;\n      onUnpause === null || onUnpause === void 0 ? void 0 : onUnpause();\n      updateTabbableNodes();\n      addListeners();\n      updateObservedNodes();\n      onPostUnpause === null || onPostUnpause === void 0 ? void 0 : onPostUnpause();\n      return this;\n    },\n    updateContainerElements: function updateContainerElements(containerElements) {\n      var elementsAsArray = [].concat(containerElements).filter(Boolean);\n      state.containers = elementsAsArray.map(function (element) {\n        return typeof element === 'string' ? doc.querySelector(element) : element;\n      });\n      if (state.active) {\n        updateTabbableNodes();\n      }\n      updateObservedNodes();\n      return this;\n    }\n  };\n\n  // initialize container elements\n  trap.updateContainerElements(elements);\n  return trap;\n};\n\nexport { createFocusTrap };\n//# sourceMappingURL=focus-trap.esm.js.map\n","// Modified from Grail UI v0.9.6 (2023-06-10)\n// Source: https://github.com/grail-ui/grail-ui\n// https://github.com/grail-ui/grail-ui/tree/master/packages/grail-ui/src/focusTrap/focusTrap.ts\nimport { writable, readonly } from 'svelte/store';\nimport { createFocusTrap as _createFocusTrap } from 'focus-trap';\nexport function createFocusTrap(config = {}) {\n    let trap;\n    const { immediate, ...focusTrapOptions } = config;\n    const hasFocus = writable(false);\n    const isPaused = writable(false);\n    const activate = (opts) => trap?.activate(opts);\n    const deactivate = (opts) => {\n        trap?.deactivate(opts);\n    };\n    const pause = () => {\n        if (trap) {\n            trap.pause();\n            isPaused.set(true);\n        }\n    };\n    const unpause = () => {\n        if (trap) {\n            trap.unpause();\n            isPaused.set(false);\n        }\n    };\n    const useFocusTrap = (node) => {\n        trap = _createFocusTrap(node, {\n            ...focusTrapOptions,\n            onActivate() {\n                hasFocus.set(true);\n                config.onActivate?.();\n            },\n            onDeactivate() {\n                hasFocus.set(false);\n                config.onDeactivate?.();\n            },\n        });\n        if (immediate) {\n            activate();\n        }\n        return {\n            destroy() {\n                deactivate();\n                trap = undefined;\n            },\n        };\n    };\n    return {\n        useFocusTrap,\n        hasFocus: readonly(hasFocus),\n        isPaused: readonly(isPaused),\n        activate,\n        deactivate,\n        pause,\n        unpause,\n    };\n}\n","import { createFocusTrap, useClickOutside, useEscapeKeydown, useFloating, usePortal, } from '../index.js';\nimport { executeCallbacks, noop, isHTMLElement, } from '../../helpers/index.js';\nconst defaultConfig = {\n    floating: {},\n    focusTrap: {},\n    clickOutside: {},\n    escapeKeydown: {},\n    portal: 'body',\n};\nexport const usePopper = (popperElement, args) => {\n    popperElement.dataset.escapee = '';\n    const { anchorElement, open, options } = args;\n    if (!anchorElement || !open || !options) {\n        return { destroy: noop };\n    }\n    const opts = { ...defaultConfig, ...options };\n    const callbacks = [];\n    if (opts.portal !== null) {\n        const portal = usePortal(popperElement, opts.portal);\n        if (portal?.destroy) {\n            callbacks.push(portal.destroy);\n        }\n    }\n    callbacks.push(useFloating(anchorElement, popperElement, opts.floating).destroy);\n    if (opts.focusTrap !== null) {\n        const { useFocusTrap } = createFocusTrap({\n            immediate: true,\n            escapeDeactivates: false,\n            allowOutsideClick: true,\n            returnFocusOnDeactivate: false,\n            fallbackFocus: popperElement,\n            ...opts.focusTrap,\n        });\n        const usedFocusTrap = useFocusTrap(popperElement);\n        if (usedFocusTrap?.destroy) {\n            callbacks.push(usedFocusTrap.destroy);\n        }\n    }\n    if (opts.clickOutside !== null) {\n        callbacks.push(useClickOutside(popperElement, {\n            enabled: open,\n            handler: (e) => {\n                if (e.defaultPrevented)\n                    return;\n                if (isHTMLElement(anchorElement) && !anchorElement.contains(e.target)) {\n                    open.set(false);\n                    anchorElement.focus();\n                }\n            },\n            ...opts.clickOutside,\n        }).destroy);\n    }\n    if (opts.escapeKeydown !== null) {\n        callbacks.push(useEscapeKeydown(popperElement, {\n            enabled: open,\n            handler: (e) => {\n                if (e.defaultPrevented)\n                    return;\n                open.set(false);\n            },\n            ...opts.escapeKeydown,\n        }).destroy);\n    }\n    const unsubscribe = executeCallbacks(...callbacks);\n    return {\n        destroy() {\n            unsubscribe();\n        },\n    };\n};\n","import { tick } from 'svelte';\nimport { isHTMLElement, noop } from '../helpers/index.js';\nexport const usePortal = (el, target = 'body') => {\n    let targetEl;\n    if (!isHTMLElement(target) && typeof target !== 'string') {\n        return {\n            destroy: noop,\n        };\n    }\n    async function update(newTarget) {\n        target = newTarget;\n        if (typeof target === 'string') {\n            targetEl = document.querySelector(target);\n            if (targetEl === null) {\n                await tick();\n                targetEl = document.querySelector(target);\n            }\n            if (targetEl === null) {\n                throw new Error(`No element found matching css selector: \"${target}\"`);\n            }\n        }\n        else if (target instanceof HTMLElement) {\n            targetEl = target;\n        }\n        else {\n            throw new TypeError(`Unknown portal target type: ${target === null ? 'null' : typeof target}. Allowed types: string (CSS selector) or HTMLElement.`);\n        }\n        el.dataset.portal = '';\n        targetEl.appendChild(el);\n        el.hidden = false;\n    }\n    function destroy() {\n        el.remove();\n    }\n    update(target);\n    return {\n        update,\n        destroy,\n    };\n};\n","import { addMeltEventListener, builder } from '../../internal/helpers/index.js';\nexport function createLabel() {\n    const root = builder('label', {\n        action: (node) => {\n            const mouseDown = addMeltEventListener(node, 'mousedown', (e) => {\n                if (!e.defaultPrevented && e.detail > 1) {\n                    e.preventDefault();\n                }\n            });\n            return {\n                destroy: mouseDown,\n            };\n        },\n    });\n    return {\n        elements: {\n            root,\n        },\n    };\n}\n","import { useEscapeKeydown, usePopper } from '../../internal/actions/index.js';\nimport { FIRST_LAST_KEYS, addHighlight, addMeltEventListener, back, builder, createElHelpers, derivedVisible, effect, executeCallbacks, forward, generateId, getOptions, getPortalDestination, isBrowser, isElementDisabled, isHTMLElement, isHTMLInputElement, kbd, last, next, noop, omit, overridable, prev, removeHighlight, removeScroll, sleep, styleToString, toWritableStores, } from '../../internal/helpers/index.js';\nimport { debounceable } from '../../internal/helpers/store/index.js';\nimport { dequal as deepEqual } from 'dequal';\nimport { onMount, tick } from 'svelte';\nimport { derived, get, readonly, writable } from 'svelte/store';\nimport { createLabel } from '../label/create.js';\n// prettier-ignore\nexport const INTERACTION_KEYS = [kbd.ARROW_LEFT, kbd.ESCAPE, kbd.ARROW_RIGHT, kbd.SHIFT, kbd.CAPS_LOCK, kbd.CONTROL, kbd.ALT, kbd.META, kbd.ENTER, kbd.F1, kbd.F2, kbd.F3, kbd.F4, kbd.F5, kbd.F6, kbd.F7, kbd.F8, kbd.F9, kbd.F10, kbd.F11, kbd.F12];\nconst defaults = {\n    positioning: {\n        placement: 'bottom',\n        sameWidth: true,\n    },\n    scrollAlignment: 'nearest',\n    loop: true,\n    defaultOpen: false,\n    closeOnOutsideClick: true,\n    preventScroll: true,\n    closeOnEscape: true,\n    forceVisible: false,\n    portal: undefined,\n    filterFunction: () => true,\n    debounce: 0,\n};\nconst { name, selector } = createElHelpers('combobox');\n/**\n * Creates an ARIA-1.2-compliant combobox.\n *\n * @TODO expose a nice mechanism for clearing the input.\n * @TODO would it be useful to have a callback for when an item is selected?\n * @TODO multi-select using `tags-input` builder?\n */\nexport function createCombobox(props) {\n    const withDefaults = { ...defaults, ...props };\n    // Trigger element for the popper portal. This will be our input element.\n    const activeTrigger = writable(null);\n    // The currently highlighted menu item.\n    const highlightedItem = writable(null);\n    const selectedWritable = withDefaults.selected ??\n        writable(withDefaults.defaultSelected);\n    const selected = overridable(selectedWritable, withDefaults?.onSelectedChange);\n    // The current value of the input element.\n    const inputValue = debounceable(withDefaults.defaultSelected?.label ?? '', withDefaults.debounce);\n    // Either the provided open store or a store with the default open value\n    const openWritable = withDefaults.open ?? writable(false);\n    // The overridable open store which is the source of truth for the open state.\n    const open = overridable(openWritable, withDefaults?.onOpenChange);\n    const isEmpty = writable(false);\n    const options = toWritableStores(omit(withDefaults, 'open', 'defaultOpen', 'debounce'));\n    const { scrollAlignment, loop, filterFunction, closeOnOutsideClick, closeOnEscape, preventScroll, portal, forceVisible, positioning, } = options;\n    const touchedInput = debounceable(false, withDefaults.debounce);\n    const ids = {\n        input: generateId(),\n        menu: generateId(),\n        label: generateId(),\n    };\n    /** ------- */\n    /** HELPERS */\n    /** ------- */\n    function getOptionProps(el) {\n        const value = el.getAttribute('data-value');\n        const label = el.getAttribute('data-label');\n        const disabled = el.hasAttribute('data-disabled');\n        return {\n            value: value ? JSON.parse(value) : value,\n            label: label ?? el.textContent ?? undefined,\n            disabled: disabled ? true : false,\n        };\n    }\n    /** Resets the combobox inputValue and filteredItems back to the selectedItem */\n    function reset() {\n        const $selectedItem = get(selected);\n        // If no item is selected the input should be cleared and the filter reset.\n        if (!$selectedItem) {\n            inputValue.set('');\n        }\n        else {\n            inputValue.set(get(selected)?.label ?? '');\n        }\n        touchedInput.set(false);\n    }\n    /**\n     * Selects an item from the menu and updates the input value.\n     * @param index array index of the item to select.\n     */\n    function selectItem(item) {\n        const props = getOptionProps(item);\n        selected.set(props);\n        const activeTrigger = document.getElementById(ids.input);\n        if (activeTrigger) {\n            activeTrigger.focus();\n        }\n    }\n    async function handleIsEmpty() {\n        if (!isBrowser)\n            return;\n        await tick();\n        const menuElement = document.getElementById(ids.menu);\n        if (!isHTMLElement(menuElement))\n            return;\n        const options = getOptions(menuElement);\n        const visibleOptions = options.filter((opt) => {\n            const isHidden = opt.dataset.hidden !== undefined;\n            return !isHidden;\n        });\n        if (!visibleOptions.length) {\n            isEmpty.set(true);\n        }\n        else {\n            isEmpty.set(false);\n        }\n    }\n    /**\n     * Opens the menu, sets the active trigger, and highlights\n     * the selected item (if one exists). It also optionally accepts the current\n     * open state to prevent unnecessary updates if we know the menu is already open.\n     */\n    async function openMenu(currentOpenState = false) {\n        /**\n         * We're checking the open state here because the menu may have\n         * been programatically opened by the user using a controlled store.\n         * In that case we don't want to update the open state, but we do\n         * want to update the active trigger and highlighted item as normal.\n         */\n        if (!currentOpenState) {\n            open.set(true);\n        }\n        const triggerEl = document.getElementById(ids.input);\n        if (!triggerEl)\n            return;\n        // The active trigger is used to anchor the menu to the input element.\n        activeTrigger.set(triggerEl);\n        // Wait a tick for the menu to open then highlight the selected item.\n        await tick();\n        const menuElement = document.getElementById(ids.menu);\n        if (!isHTMLElement(menuElement))\n            return;\n        const selectedItem = menuElement.querySelector('[aria-selected=true]');\n        if (!isHTMLElement(selectedItem))\n            return;\n        highlightedItem.set(selectedItem);\n    }\n    /** Closes the menu & clears the active trigger */\n    function closeMenu() {\n        open.set(false);\n        touchedInput.set(false);\n    }\n    /**\n     * To properly anchor the popper to the input/trigger, we need to ensure both\n     * the open state is true and the activeTrigger is not null. This helper store's\n     * value is true when both of these conditions are met and keeps the code tidy.\n     */\n    const isVisible = derivedVisible({ open, forceVisible, activeTrigger });\n    /**\n     * Determines if a given item is selected.\n     * This is useful for displaying additional markup on the selected item.\n     */\n    const isSelected = derived([selected], ([$value]) => {\n        return (item) => deepEqual($value?.value, item);\n    });\n    /** -------- */\n    /** ELEMENTS */\n    /** -------- */\n    /** Action and attributes for the text input. */\n    const input = builder(name('input'), {\n        stores: [open, highlightedItem, inputValue],\n        returned: ([$open, $highlightedItem, $inputValue]) => {\n            return {\n                'aria-activedescendant': $highlightedItem?.id,\n                'aria-autocomplete': 'list',\n                'aria-controls': ids.menu,\n                'aria-expanded': $open,\n                'aria-labelledby': ids.label,\n                autocomplete: 'off',\n                id: ids.input,\n                role: 'combobox',\n                value: $inputValue.value,\n            };\n        },\n        action: (node) => {\n            const unsubscribe = executeCallbacks(addMeltEventListener(node, 'click', () => {\n                const $open = get(open);\n                if ($open) {\n                    return;\n                }\n                openMenu($open);\n            }), \n            // Handle all input key events including typing, meta, and navigation.\n            addMeltEventListener(node, 'keydown', (e) => {\n                const $open = get(open);\n                /**\n                 * When the menu is closed...\n                 */\n                if (!$open) {\n                    // Pressing one of the interaction keys shouldn't open the menu.\n                    if (INTERACTION_KEYS.includes(e.key)) {\n                        return;\n                    }\n                    // Tab should not open the menu.\n                    if (e.key === kbd.TAB) {\n                        return;\n                    }\n                    // Pressing backspace when the input is blank shouldn't open the menu.\n                    if (e.key === kbd.BACKSPACE && node.value === '') {\n                        return;\n                    }\n                    // All other events should open the menu.\n                    openMenu($open);\n                    tick().then(() => {\n                        const $selectedItem = get(selected);\n                        if ($selectedItem)\n                            return;\n                        const menuEl = document.getElementById(ids.menu);\n                        if (!isHTMLElement(menuEl))\n                            return;\n                        const enabledItems = Array.from(menuEl.querySelectorAll(`${selector('item')}:not([data-disabled]):not([data-hidden])`)).filter((item) => isHTMLElement(item));\n                        if (!enabledItems.length)\n                            return;\n                        if (e.key === kbd.ARROW_DOWN) {\n                            highlightedItem.set(enabledItems[0]);\n                        }\n                        else if (e.key === kbd.ARROW_UP) {\n                            highlightedItem.set(last(enabledItems));\n                        }\n                    });\n                }\n                /**\n                 * When the menu is open...\n                 */\n                // Pressing `esc` should close the menu.\n                if (e.key === kbd.TAB || e.key === kbd.ESCAPE) {\n                    closeMenu();\n                    reset();\n                    return;\n                }\n                // Pressing enter with a highlighted item should select it.\n                if (e.key === kbd.ENTER) {\n                    const $highlightedItem = get(highlightedItem);\n                    if ($highlightedItem) {\n                        selectItem($highlightedItem);\n                    }\n                    closeMenu();\n                }\n                // Pressing Alt + Up should close the menu.\n                if (e.key === kbd.ARROW_UP && e.altKey) {\n                    closeMenu();\n                    reset();\n                }\n                // Navigation (up, down, etc.) should change the highlighted item.\n                if (FIRST_LAST_KEYS.includes(e.key)) {\n                    e.preventDefault();\n                    // Get all the menu items.\n                    const menuElement = document.getElementById(ids.menu);\n                    if (!isHTMLElement(menuElement))\n                        return;\n                    const itemElements = getOptions(menuElement);\n                    if (!itemElements.length)\n                        return;\n                    // Disabled items can't be highlighted. Skip them.\n                    const candidateNodes = itemElements.filter((opt) => !isElementDisabled(opt) && opt.dataset.hidden === undefined);\n                    // Get the index of the currently highlighted item.\n                    const $currentItem = get(highlightedItem);\n                    const currentIndex = $currentItem ? candidateNodes.indexOf($currentItem) : -1;\n                    // Find the next menu item to highlight.\n                    const $loop = get(loop);\n                    const $scrollAlignment = get(scrollAlignment);\n                    let nextItem;\n                    switch (e.key) {\n                        case kbd.ARROW_DOWN:\n                            nextItem = next(candidateNodes, currentIndex, $loop);\n                            break;\n                        case kbd.ARROW_UP:\n                            nextItem = prev(candidateNodes, currentIndex, $loop);\n                            break;\n                        case kbd.PAGE_DOWN:\n                            nextItem = forward(candidateNodes, currentIndex, 10, $loop);\n                            break;\n                        case kbd.PAGE_UP:\n                            nextItem = back(candidateNodes, currentIndex, 10, $loop);\n                            break;\n                        case kbd.HOME:\n                            nextItem = candidateNodes[0];\n                            break;\n                        case kbd.END:\n                            nextItem = last(candidateNodes);\n                            break;\n                        default:\n                            return;\n                    }\n                    // Highlight the new item and scroll it into view.\n                    highlightedItem.set(nextItem);\n                    nextItem.scrollIntoView({ block: $scrollAlignment });\n                }\n            }), \n            // Listens to the input value and filters the items accordingly.\n            addMeltEventListener(node, 'input', (e) => {\n                if (!isHTMLInputElement(e.target))\n                    return;\n                const value = e.target.value;\n                inputValue.debouncedSet(value);\n                touchedInput.debouncedSet(true);\n                tick().then(() => {\n                    const $highlightedItem = get(highlightedItem);\n                    if ($highlightedItem?.dataset.hidden) {\n                        // Find next visible item\n                        const menuElement = document.getElementById(ids.menu);\n                        if (!isHTMLElement(menuElement))\n                            return;\n                        const itemElements = getOptions(menuElement);\n                        const candidateNodes = itemElements.filter((opt) => !isElementDisabled(opt) && !opt.dataset.hidden);\n                        highlightedItem.set(candidateNodes[0] ?? null);\n                    }\n                });\n            }));\n            let unsubEscapeKeydown = noop;\n            effect(open, ($open) => {\n                if ($open) {\n                    tick().then(() => {\n                        const escape = useEscapeKeydown(node, {\n                            handler: () => {\n                                closeMenu();\n                                reset();\n                            },\n                        });\n                        if (escape && escape.destroy) {\n                            unsubEscapeKeydown = escape.destroy;\n                        }\n                    });\n                }\n                else {\n                    unsubEscapeKeydown();\n                }\n            });\n            return {\n                destroy() {\n                    unsubscribe();\n                    unsubEscapeKeydown();\n                },\n            };\n        },\n    });\n    /**\n     * Action and attributes for the menu element.\n     */\n    const menu = builder(name('menu'), {\n        stores: [isVisible],\n        returned: ([$isVisible]) => {\n            return {\n                hidden: $isVisible ? undefined : true,\n                id: ids.menu,\n                role: 'listbox',\n                style: styleToString({ display: $isVisible ? undefined : 'none' }),\n            };\n        },\n        action: (node) => {\n            let unsubPopper = noop;\n            let unsubScroll = noop;\n            const unsubscribe = executeCallbacks(\n            //  Bind the popper portal to the input element.\n            effect([isVisible, preventScroll, closeOnEscape, portal, closeOnOutsideClick, positioning], ([$isVisible, $preventScroll, $closeOnEscape, $portal, $closeOnOutsideClick, $positioning,]) => {\n                unsubPopper();\n                unsubScroll();\n                const $activeTrigger = get(activeTrigger);\n                if (!($isVisible && $activeTrigger))\n                    return;\n                if ($preventScroll) {\n                    unsubScroll = removeScroll();\n                }\n                tick().then(() => {\n                    const popper = usePopper(node, {\n                        anchorElement: $activeTrigger,\n                        open,\n                        options: {\n                            floating: $positioning,\n                            focusTrap: null,\n                            clickOutside: $closeOnOutsideClick\n                                ? {\n                                    handler: (e) => {\n                                        const target = e.target;\n                                        if (target === $activeTrigger)\n                                            return;\n                                        closeMenu();\n                                        reset();\n                                    },\n                                }\n                                : null,\n                            escapeKeydown: $closeOnEscape\n                                ? {\n                                    handler: () => {\n                                        closeMenu();\n                                        reset();\n                                    },\n                                }\n                                : null,\n                            portal: getPortalDestination(node, $portal),\n                        },\n                    });\n                    if (popper && popper.destroy) {\n                        unsubPopper = popper.destroy;\n                    }\n                });\n            }), \n            // Remove highlight when the pointer leaves the menu.\n            addMeltEventListener(node, 'pointerleave', () => {\n                highlightedItem.set(null);\n            }));\n            return {\n                destroy: () => {\n                    unsubscribe();\n                    unsubPopper();\n                    unsubScroll();\n                },\n            };\n        },\n    });\n    // Use our existing label builder to create a label for the combobox input.\n    const { elements: { root: labelBuilder }, } = createLabel();\n    const { action: labelAction } = get(labelBuilder);\n    const label = builder(name('label'), {\n        returned: () => {\n            return {\n                id: ids.label,\n                for: ids.input,\n            };\n        },\n        action: labelAction,\n    });\n    const option = builder(name('option'), {\n        stores: [selected, filterFunction, inputValue, touchedInput],\n        returned: ([$value, $filterFunction, $inputValue, $touchedInput]) => (props) => {\n            let hidden = false;\n            if ($touchedInput.debounced &&\n                $filterFunction?.({ input: $inputValue.debounced, itemValue: props.value }) === false) {\n                hidden = true;\n            }\n            const selected = deepEqual(props.value, $value);\n            return {\n                'data-value': JSON.stringify(props.value),\n                'data-label': props.label,\n                'data-disabled': props.disabled ? '' : undefined,\n                'aria-disabled': props.disabled ? true : undefined,\n                'aria-selected': selected,\n                'data-selected': selected ? '' : undefined,\n                hidden: hidden ? true : undefined,\n                'data-hidden': hidden ? '' : undefined,\n                id: generateId(),\n                role: 'option',\n                style: styleToString({ cursor: props.disabled ? 'default' : 'pointer' }),\n            };\n        },\n        action: (node) => {\n            const unsubscribe = executeCallbacks(\n            // Handle highlighting items when the pointer moves over them.\n            addMeltEventListener(node, 'pointermove', () => {\n                // If the item is disabled, clear the highlight.\n                if (isElementDisabled(node)) {\n                    highlightedItem.set(null);\n                    return;\n                }\n                // Otherwise, proceed.\n                highlightedItem.set(node);\n            }), addMeltEventListener(node, 'click', (e) => {\n                // If the item is disabled, `preventDefault` to stop the input losing focus.\n                if (isElementDisabled(node)) {\n                    e.preventDefault();\n                    return;\n                }\n                // Otherwise, select the item and close the menu.\n                selectItem(node);\n                closeMenu();\n            }));\n            return { destroy: unsubscribe };\n        },\n    });\n    /** ------------------- */\n    /** LIFECYCLE & EFFECTS */\n    /** ------------------- */\n    onMount(() => {\n        open.set(withDefaults.defaultOpen);\n        if (!isBrowser)\n            return;\n        const menuEl = document.getElementById(ids.menu);\n        if (!menuEl)\n            return;\n        const triggerEl = document.getElementById(ids.input);\n        if (triggerEl) {\n            activeTrigger.set(triggerEl);\n        }\n        const selectedEl = menuEl.querySelector('[data-selected]');\n        if (!isHTMLElement(selectedEl))\n            return;\n        const dataLabel = selectedEl.getAttribute('data-label');\n        inputValue.debouncedSet(dataLabel ?? selectedEl.textContent ?? '');\n    });\n    effect(selected, function setInputValue($selected) {\n        inputValue.debouncedSet($selected?.label ?? '');\n    });\n    /**\n     * Handles moving the `data-highlighted` attribute between items when\n     * the user moves their pointer or navigates with their keyboard.\n     */\n    effect([highlightedItem, scrollAlignment], ([$highlightedItem, $scrollAlignment]) => {\n        if (!isBrowser)\n            return;\n        const menuElement = document.getElementById(ids.menu);\n        if (!isHTMLElement(menuElement))\n            return;\n        getOptions(menuElement).forEach((node) => {\n            if (node === $highlightedItem) {\n                addHighlight(node);\n            }\n            else {\n                removeHighlight(node);\n            }\n        });\n        if ($highlightedItem) {\n            sleep(1).then(() => $highlightedItem.scrollIntoView({ block: $scrollAlignment }));\n        }\n    });\n    effect([inputValue, touchedInput], () => {\n        handleIsEmpty();\n    });\n    return {\n        elements: {\n            input,\n            option,\n            menu,\n            label,\n        },\n        states: {\n            open,\n            selected,\n            inputValue: inputValue,\n            isEmpty: readonly(isEmpty),\n        },\n        helpers: {\n            isSelected,\n        },\n        options,\n    };\n}\n","import { client_method } from '../client/singletons.js';\n\n/**\n * If called when the page is being updated following a navigation (in `onMount` or `afterNavigate` or an action, for example), this disables SvelteKit's built-in scroll handling.\n * This is generally discouraged, since it breaks user expectations.\n * @returns {void}\n */\nexport const disableScrollHandling = /* @__PURE__ */ client_method('disable_scroll_handling');\n\n/**\n * Returns a Promise that resolves when SvelteKit navigates (or fails to navigate, in which case the promise rejects) to the specified `url`.\n * For external URLs, use `window.location = url` instead of calling `goto(url)`.\n *\n * @type {(url: string | URL, opts?: {\n *   replaceState?: boolean;\n *   noScroll?: boolean;\n *   keepFocus?: boolean;\n *   invalidateAll?: boolean;\n *   state?: any\n * }) => Promise<void>}\n * @param {string | URL} url Where to navigate to. Note that if you've set [`config.kit.paths.base`](https://kit.svelte.dev/docs/configuration#paths) and the URL is root-relative, you need to prepend the base path if you want to navigate within the app.\n * @param {Object} [opts] Options related to the navigation\n * @param {boolean} [opts.replaceState] If `true`, will replace the current `history` entry rather than creating a new one with `pushState`\n * @param {boolean} [opts.noScroll] If `true`, the browser will maintain its scroll position rather than scrolling to the top of the page after navigation\n * @param {boolean} [opts.keepFocus] If `true`, the currently focused element will retain focus after navigation. Otherwise, focus will be reset to the body\n * @param {boolean} [invalidateAll] If `true`, all `load` functions of the page will be rerun. See https://kit.svelte.dev/docs/load#rerunning-load-functions for more info on invalidation.\n * @param {any} [opts.state] The state of the new/updated history entry\n * @returns {Promise<void>}\n */\nexport const goto = /* @__PURE__ */ client_method('goto');\n\n/**\n * Causes any `load` functions belonging to the currently active page to re-run if they depend on the `url` in question, via `fetch` or `depends`. Returns a `Promise` that resolves when the page is subsequently updated.\n *\n * If the argument is given as a `string` or `URL`, it must resolve to the same URL that was passed to `fetch` or `depends` (including query parameters).\n * To create a custom identifier, use a string beginning with `[a-z]+:` (e.g. `custom:state`) â€” this is a valid URL.\n *\n * The `function` argument can be used define a custom predicate. It receives the full `URL` and causes `load` to rerun if `true` is returned.\n * This can be useful if you want to invalidate based on a pattern instead of a exact match.\n *\n * ```ts\n * // Example: Match '/path' regardless of the query parameters\n * import { invalidate } from '$app/navigation';\n *\n * invalidate((url) => url.pathname === '/path');\n * ```\n * @type {(url: string | URL | ((url: URL) => boolean)) => Promise<void>}\n * @param {string | URL | ((url: URL) => boolean)} url The invalidated URL\n * @returns {Promise<void>}\n */\nexport const invalidate = /* @__PURE__ */ client_method('invalidate');\n\n/**\n * Causes all `load` functions belonging to the currently active page to re-run. Returns a `Promise` that resolves when the page is subsequently updated.\n * @type {() => Promise<void>}\n * @returns {Promise<void>}\n */\nexport const invalidateAll = /* @__PURE__ */ client_method('invalidate_all');\n\n/**\n * Programmatically preloads the given page, which means\n *  1. ensuring that the code for the page is loaded, and\n *  2. calling the page's load function with the appropriate options.\n *\n * This is the same behaviour that SvelteKit triggers when the user taps or mouses over an `<a>` element with `data-sveltekit-preload-data`.\n * If the next navigation is to `href`, the values returned from load will be used, making navigation instantaneous.\n * Returns a Promise that resolves when the preload is complete.\n *\n * @type {(href: string) => Promise<void>}\n * @param {string} href Page to preload\n * @returns {Promise<void>}\n */\nexport const preloadData = /* @__PURE__ */ client_method('preload_data');\n\n/**\n * Programmatically imports the code for routes that haven't yet been fetched.\n * Typically, you might call this to speed up subsequent navigation.\n *\n * You can specify routes by any matching pathname such as `/about` (to match `src/routes/about/+page.svelte`) or `/blog/*` (to match `src/routes/blog/[slug]/+page.svelte`).\n *\n * Unlike `preloadData`, this won't call `load` functions.\n * Returns a Promise that resolves when the modules have been imported.\n *\n * @type {(...urls: string[]) => Promise<void>}\n * @param {...string[]} urls\n * @returns {Promise<void>}\n */\nexport const preloadCode = /* @__PURE__ */ client_method('preload_code');\n\n/**\n * A navigation interceptor that triggers before we navigate to a new URL, whether by clicking a link, calling `goto(...)`, or using the browser back/forward controls.\n * Calling `cancel()` will prevent the navigation from completing. If the navigation would have directly unloaded the current page, calling `cancel` will trigger the native\n * browser unload confirmation dialog. In these cases, `navigation.willUnload` is `true`.\n *\n * When a navigation isn't client side, `navigation.to.route.id` will be `null`.\n *\n * `beforeNavigate` must be called during a component initialization. It remains active as long as the component is mounted.\n * @type {(callback: (navigation: import('@sveltejs/kit').BeforeNavigate) => void) => void}\n * @param {(navigation: import('@sveltejs/kit').BeforeNavigate) => void} callback\n * @returns {void}\n */\nexport const beforeNavigate = /* @__PURE__ */ client_method('before_navigate');\n\n/**\n * A lifecycle function that runs the supplied `callback` when the current component mounts, and also whenever we navigate to a new URL.\n *\n * `afterNavigate` must be called during a component initialization. It remains active as long as the component is mounted.\n * @type {(callback: (navigation: import('@sveltejs/kit').AfterNavigate) => void) => void}\n * @param {(navigation: import('@sveltejs/kit').AfterNavigate) => void} callback\n * @returns {void}\n */\nexport const afterNavigate = /* @__PURE__ */ client_method('after_navigate');\n","<script lang=\"ts\">\r\n    import { LL, locale } from \"$i18n/i18n-svelte\";\r\n    import type { Produits, Restaurants } from \"$lib/client.types\";\r\n    import Fuse from \"fuse.js\";\r\n    import { createCombobox, melt } from \"@melt-ui/svelte\";\r\n    import { goto } from \"$app/navigation\";\r\n\r\n    export let restaurants: Restaurants[];\r\n    export let products: Produits[];\r\n\r\n    type UnFuse<T> = T extends Fuse<infer K> ? K : never;\r\n\r\n    type IndexType = \"restaurant\" | \"product\";\r\n    const index = new Fuse(\r\n        [\r\n            ...restaurants.map((r) => ({\r\n                ...r,\r\n                type: \"restaurant\" satisfies IndexType as IndexType,\r\n            })),\r\n            ...products.map((p) => ({\r\n                ...p,\r\n                type: \"product\" satisfies IndexType as IndexType,\r\n            })),\r\n        ],\r\n        {\r\n            includeMatches: true,\r\n            keys: [\"name\"],\r\n        }\r\n    );\r\n\r\n    const {\r\n        elements: { menu, input, option, label },\r\n        states: { open },\r\n    } = createCombobox<UnFuse<typeof index>>({\r\n        forceVisible: false,\r\n        closeOnEscape: true,\r\n        closeOnOutsideClick: true,\r\n        onSelectedChange: ({ curr, next }) => {\r\n            if (next?.value?.type === \"restaurant\") {\r\n                goto(`/${$locale}/restaurants/${next.value.id}`);\r\n                return undefined;\r\n            }\r\n            if (next?.value) {\r\n                alert(\"Selection du produit: \" + next.value.name);\r\n            }\r\n            return next;\r\n        },\r\n    });\r\n\r\n    $: searchResult = index.search($input.value, {\r\n        limit: 5,\r\n    });\r\n</script>\r\n\r\n<div>\r\n    <label use:melt={$label} for=\"search\" style=\"display: block;\">\r\n        {$LL.search()}\r\n    </label>\r\n    <input autocomplete=\"off\" type=\"search\" id=\"search\" use:melt={$input} />\r\n</div>\r\n<ul class=\"search-result\" use:melt={$menu}>\r\n    {#if open}\r\n        {#each searchResult as result}\r\n            <li\r\n                use:melt={$option({\r\n                    value: result.item,\r\n                    label: result.item.name ?? \"\",\r\n                    disabled: false,\r\n                })}\r\n            >\r\n                {#if result.item.type === \"restaurant\"}\r\n                    <span class=\"avatar restaurant\">R</span>\r\n                {:else if result.item.type === \"product\"}\r\n                    <span class=\"avatar product\">P</span>\r\n                {/if}\r\n                <div style=\"display: flex; flex-wrap: nowrap\">\r\n                    {result.item.name}\r\n                </div>\r\n            </li>\r\n        {/each}\r\n    {/if}\r\n</ul>\r\n\r\n<style>\r\n    input[type=\"search\"] {\r\n        padding: 0.75rem;\r\n    }\r\n\r\n    .search-result:empty {\r\n        display: none;\r\n    }\r\n\r\n    .search-result {\r\n        border: 1px solid #dedede;\r\n        background: white;\r\n        padding: 0.25em;\r\n        box-shadow: 1px 1px 4px 1px #dedede;\r\n        margin: 0;\r\n    }\r\n\r\n    .search-result li {\r\n        display: flex;\r\n        gap: 1rem;\r\n        padding: 0.5em;\r\n    }\r\n\r\n    .avatar {\r\n        width: 24px;\r\n        height: 24px;\r\n        align-self: center;\r\n        aspect-ratio: 1;\r\n        background-color: green;\r\n        border-color: lightgreen;\r\n        display: flex;\r\n        justify-content: center;\r\n        align-items: center;\r\n        border-radius: 50%;\r\n        color: white;\r\n        font-weight: bold;\r\n    }\r\n\r\n    .avatar.restaurant {\r\n        background-color: purple;\r\n    }\r\n\r\n    :global([data-highlighted]) {\r\n        background-color: #0000cc33;\r\n    }\r\n</style>\r\n","<script lang=\"ts\">\r\n    import { browser } from \"$app/environment\";\r\n    import { LL, locale, setLocale } from \"$i18n/i18n-svelte\";\r\n    import type { Restaurants } from \"$lib/client.types.js\";\r\n    import {\r\n        getAffluence,\r\n        getFranceTime,\r\n        isRestaurantOpen,\r\n    } from \"$lib/client/restaurants.js\";\r\n    import Searchbar from \"./Searchbar.svelte\";\r\n\r\n    export let data;\r\n\r\n    const checkOpened = (restaurant: Restaurants) => {\r\n        return isRestaurantOpen(restaurant, getFranceTime()) ? \"OPEN\" : \"CLOSE\";\r\n    };\r\n\r\n    function localeToFlag(code: string) {\r\n        return code\r\n            .split(\"\")\r\n            .map((letter) => (letter.charCodeAt(0) % 32) + 0x1f1e5)\r\n            .map((emojiCode) => String.fromCodePoint(emojiCode))\r\n            .join(\"\");\r\n    }\r\n</script>\r\n\r\n<svelte:head>\r\n    <title>{$LL.title()}</title>\r\n    <meta name=\"description\" content={$LL.title()} />\r\n</svelte:head>\r\n\r\n<h1>[{$locale.toUpperCase()}] {$LL.title()}</h1>\r\n<p>{$LL.hi({ name: \"John\" })}</p>\r\n\r\n<section>\r\n    <Searchbar restaurants={data.restaurants} products={data.products} />\r\n</section>\r\n\r\n<h2>{$LL.restaurants()}</h2>\r\n<ul class=\"restaurants\">\r\n    {#each data.restaurants as restaurant}\r\n        <li class=\"restaurant\" aria-label={restaurant.name}>\r\n            <a href=\"/{$locale}/restaurants/{restaurant.id}\">\r\n                <span>{restaurant.name}</span>\r\n            </a>\r\n            <small>{restaurant.open_hour} - {restaurant.close_hour}</small>\r\n            <div class=\"restaurant__status\">\r\n                {#if browser}\r\n                    {@const open = checkOpened(restaurant)}\r\n                    {#if open === \"CLOSE\"}\r\n                        {$LL.close()}\r\n                    {:else}\r\n                        {#await getAffluence(restaurant.id)}\r\n                            {$LL.open()}\r\n                        {:then affluence}\r\n                            {affluence} mn\r\n                        {/await}\r\n                    {/if}\r\n                {:else}\r\n                    &nbsp;\r\n                {/if}\r\n            </div>\r\n        </li>\r\n    {/each}\r\n</ul>\r\n\r\n<h2>{$LL.products()}</h2>\r\n\r\n<ul class=\"products\">\r\n    {#each data.products as product}\r\n        <li aria-label={product.name}>\r\n            {product.name}\r\n        </li>\r\n    {/each}\r\n</ul>\r\n\r\n<div class=\"languages\">\r\n    {#each data.languages as language}\r\n        {@const adjusted = language === \"en\" ? \"us\" : \"fr\"}\r\n        <a\r\n            href=\"/{language}\"\r\n            class=\"language\"\r\n            data-sveltekit-reload\r\n            class:active={$locale === language}\r\n            tabindex={$locale === language ? -1 : undefined}\r\n        >\r\n            {@html localeToFlag(adjusted)}\r\n        </a>\r\n    {/each}\r\n</div>\r\n\r\n<style>\r\n    ul {\r\n        list-style: none;\r\n        padding: 0;\r\n        margin: 0;\r\n    }\r\n\r\n    .restaurants li + li,\r\n    .products li + li {\r\n        border-top: 1px solid #dedede;\r\n    }\r\n\r\n    .restaurants li,\r\n    .products li {\r\n        margin-block: 0.25rem;\r\n    }\r\n\r\n    ul a {\r\n        display: inline-block;\r\n        padding-block: 0.5rem;\r\n    }\r\n\r\n    small {\r\n        font-size: 0.75rem;\r\n        display: block;\r\n    }\r\n\r\n    .restaurant__status {\r\n        text-transform: lowercase;\r\n        border: 1px solid #ccc;\r\n        display: inline-block;\r\n        background-color: #ccc;\r\n    }\r\n\r\n    .languages {\r\n        display: flex;\r\n        gap: 2rem;\r\n        justify-content: center;\r\n    }\r\n\r\n    .language {\r\n        text-decoration: none;\r\n    }\r\n\r\n    .language.active {\r\n        outline: 1px solid #0000cc33;\r\n        outline-offset: 0.25rem;\r\n    }\r\n</style>\r\n"],"names":["ensure_array_like","array_like_or_iterator","get_spread_update","levels","updates","update","to_null_out","accounted_for","i","n","key","isRestaurantOpen","restaurant","currentTime","getFranceTime","date","getAffluence","restaurantId","resolve","reject","isArray","value","getTag","INFINITY","baseToString","result","toString","isString","isNumber","isBoolean","isObjectLike","isObject","isDefined","isBlank","INCORRECT_INDEX_TYPE","LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY","PATTERN_LENGTH_TOO_LARGE","max","MISSING_KEY_PROPERTY","name","INVALID_KEY_WEIGHT_VALUE","hasOwn","KeyStore","keys","totalWeight","obj","createKey","keyId","path","id","src","weight","getFn","createKeyPath","createKeyId","get","list","arr","deepGet","index","len","MatchOptions","BasicOptions","a","b","FuzzyOptions","AdvancedOptions","Config","SPACE","norm","mantissa","cache","m","numTokens","FuseIndex","fieldNormWeight","docs","records","idx","doc","docIndex","item","record","keyIndex","subRecords","stack","nestedArrIndex","subRecord","k","createIndex","myIndex","parseIndex","data","computeScore$1","pattern","errors","currentLocation","expectedLocation","distance","ignoreLocation","accuracy","proximity","convertMaskToIndices","matchmask","minMatchCharLength","indices","start","end","match","MAX_BITS","search","text","patternAlphabet","location","threshold","findAllMatches","includeMatches","patternLen","textLen","currentThreshold","bestLocation","computeMatches","matchMask","score","lastBitArr","finalScore","binMax","mask","binMin","binMid","finish","bitArr","j","charMatch","createPatternAlphabet","char","BitapSearch","isCaseSensitive","addChunk","startIndex","remainder","allIndices","totalScore","hasMatches","alphabet","isMatch","BaseMatch","getMatch","exp","matches","ExactMatch","InverseExactMatch","PrefixExactMatch","InversePrefixExactMatch","SuffixExactMatch","InverseSuffixExactMatch","FuzzyMatch","IncludeMatch","searchers","searchersLen","SPACE_RE","OR_TOKEN","parseQuery","options","query","results","queryItem","found","searcher","token","MultiMatchSet","ExtendedSearch","_","numMatches","qLen","pLen","type","registeredSearchers","register","args","createSearcher","searcherClass","LogicalOperator","KeyType","isExpression","isPath","isLeaf","convertToExplicit","parse","auto","next","isQueryPath","node","computeScore","ignoreFieldNorm","transformMatches","transformScore","format","includeScore","transformers","transformer","Fuse","predicate","limit","shouldSort","sortFn","expression","evaluate","res","child","resultMap","expResults","has","find","iter","tar","dequal","foo","bar","ctor","tmp","back","array","increment","loop","previousIndex","forward","nextIndex","prev","currentIndex","last","lightable","subscribe","run","hiddenAction","target","prop","receiver","isFunctionWithParams","fn","builder","stores","action","returned","derivedStore","derived","values","noop","returnedFn","resultFn","actionFn","createElHelpers","prefix","part","attribute","selector","isBrowser","isFunction","v","isHTMLElement","element","isHTMLInputElement","isElementDisabled","ariaDisabled","disabled","dataDisabled","executeCallbacks","callbacks","callback","addEventListener","event","handler","events","_event","addMeltEventListener","handlerWithMelt","withMelt","dispatchMeltEvent","originalEvent","customMeltEvent","customEvent","addHighlight","removeHighlight","getOptions","el","omit","overridable","store","onChange","updater","sideEffect","curr","sleep","ms","styleToString","style","str","urlAlphabet","nanoid","size","generateId","kbd","FIRST_KEYS","LAST_KEYS","FIRST_LAST_KEYS","isDom","getPlatform","agent","pt","isTouchDevice","isMac","isApple","isIos","LOCK_CLASSNAME","assignStyle","previousStyle","setCSSProperty","property","previousValue","getPaddingProperty","documentElement","documentLeft","removeScroll","_document","win","body","scrollbarWidth","setScrollbarWidthProperty","paddingProperty","scrollbarSidePadding","setStyle","setIOSStyle","scrollX","scrollY","visualViewport","offsetLeft","offsetTop","restoreStyle","cleanups","derivedVisible","open","forceVisible","activeTrigger","$open","$forceVisible","$activeTrigger","derivedWithUnsubscribe","unsubscribers","onUnsubscribe","cb","unsubscribe","$storeValues","onDestroy","unsub","effect","debounceable","initialValue","wait","writable","timeout","debouncedSet","state","debouncedUpdate","set","toWritableStores","properties","propertyKey","getPortalParent","parent","getPortalDestination","portalProp","portalParent","documentClickStore","readable","clicked","useClickOutside","config","isEnabled","e","composedPath","ignoreEl","_a","params","documentEscapeKeyStore","keydown","useEscapeKeydown","min","round","floor","createCoords","oppositeSideMap","oppositeAlignmentMap","clamp","param","getSide","placement","getAlignment","getOppositeAxis","axis","getAxisLength","getSideAxis","getAlignmentAxis","getAlignmentSides","rects","rtl","alignment","alignmentAxis","length","mainAlignmentSide","getOppositePlacement","getExpandedPlacements","oppositePlacement","getOppositeAlignmentPlacement","getSideList","side","isStart","lr","rl","tb","bt","getOppositeAxisPlacements","flipAlignment","direction","expandPaddingObject","padding","getPaddingObject","rectToClientRect","rect","computeCoordsFromPlacement","_ref","reference","floating","sideAxis","alignLength","isVertical","commonX","commonY","commonAlign","coords","computePosition","strategy","middleware","platform","validMiddleware","x","y","statefulPlacement","middlewareData","resetCount","nextX","nextY","reset","detectOverflow","_await$platform$isEle","elements","boundary","rootBoundary","elementContext","altBoundary","paddingObject","clippingClientRect","offsetParent","offsetScale","elementClientRect","arrow","arrowDimensions","isYAxis","minProp","maxProp","clientProp","endDiff","startDiff","arrowOffsetParent","clientSize","centerToReference","largestPossiblePadding","minPadding","maxPadding","min$1","center","offset","alignmentOffset","flip","_middlewareData$flip","initialPlacement","checkMainAxis","checkCrossAxis","specifiedFallbackPlacements","fallbackStrategy","fallbackAxisSideDirection","detectOverflowOptions","isBasePlacement","fallbackPlacements","placements","overflow","overflows","overflowsData","sides","_middlewareData$flip2","_overflowsData$filter","nextPlacement","resetPlacement","d","_overflowsData$map$so","acc","convertValueToCoords","mainAxisMulti","crossAxisMulti","rawValue","mainAxis","crossAxis","diffCoords","shift","limiter","mainAxisCoord","crossAxisCoord","minSide","maxSide","limitedCoords","apply","width","height","heightSide","widthSide","overflowAvailableHeight","overflowAvailableWidth","noShift","availableHeight","availableWidth","maximumClippingWidth","maximumClippingHeight","xMin","xMax","yMin","yMax","nextDimensions","getNodeName","isNode","getWindow","_node$ownerDocument","getDocumentElement","isElement","isShadowRoot","isOverflowElement","overflowX","overflowY","display","getComputedStyle","isTableElement","isContainingBlock","webkit","isWebKit","css","getContainingBlock","currentNode","getParentNode","isLastTraversableNode","getNodeScroll","getNearestOverflowAncestor","parentNode","getOverflowAncestors","_node$ownerDocument2","scrollableAncestor","isBody","getCssDimensions","hasOffset","offsetWidth","offsetHeight","shouldFallback","unwrapElement","getScale","domElement","$","noOffsets","getVisualOffsets","shouldAddVisualOffsets","isFixed","floatingOffsetParent","getBoundingClientRect","includeScale","isFixedStrategy","clientRect","scale","visualOffsets","offsetWin","currentIFrame","iframeScale","iframeRect","left","top","convertOffsetParentRelativeRectToViewportRelativeRect","isOffsetParentAnElement","scroll","offsets","offsetRect","getClientRects","getWindowScrollBarX","getDocumentRect","html","getViewportRect","visualViewportBased","getInnerBoundingClientRect","getClientRectFromClippingAncestor","clippingAncestor","hasFixedPositionAncestor","stopNode","getClippingElementAncestors","cachedResult","currentContainingBlockComputedStyle","elementIsFixed","computedStyle","currentNodeIsContaining","ancestor","getClippingRect","clippingAncestors","firstClippingAncestor","clippingRect","accRect","getDimensions","getRectRelativeToOffsetParent","getTrueOffsetParent","polyfill","getOffsetParent","window","getElementRects","getOffsetParentFn","getDimensionsFn","isRTL","observeMove","onMove","io","timeoutId","root","cleanup","refresh","skip","insetTop","insetRight","insetBottom","insetLeft","isFirstUpdate","handleObserve","entries","ratio","autoUpdate","ancestorScroll","ancestorResize","elementResize","layoutShift","animationFrame","referenceEl","ancestors","cleanupIo","reobserveFrame","resizeObserver","firstEntry","frameId","prevRefRect","frameLoop","nextRefRect","mergedOptions","platformWithCache","computePosition$1","defaultConfig","ARROW_TRANSFORM","useFloating","opts","arrowEl","arrowOffset","compute","dir","candidateSelectors","candidateSelector","NoElement","getRootNode","_element$getRootNode","isInert","lookUp","_node$getAttribute","inertAtt","inert","isContentEditable","_node$getAttribute2","attValue","getCandidates","includeContainer","filter","candidates","getCandidatesIteratively","elementsToCheck","assigned","content","nestedCandidates","validCandidate","shadowRoot","validShadowRoot","_nestedCandidates","hasTabIndex","getTabIndex","getSortOrderTabIndex","isScope","tabIndex","sortOrderedTabbables","isInput","isHiddenInput","isDetailsWithSummary","r","getCheckedRadio","nodes","form","isTabbableRadio","radioScope","queryRadios","radioSet","err","checked","isRadio","isNonTabbableRadio","isNodeAttached","_nodeRoot","nodeRoot","nodeRootHost","attached","_nodeRootHost","_nodeRootHost$ownerDo","_nodeRoot2","_nodeRootHost2","_nodeRootHost2$ownerD","isZeroArea","_node$getBoundingClie","isHidden","displayCheck","getShadowRoot","isDirectSummary","nodeUnderDetails","originalNode","parentElement","rootNode","isDisabledFromFieldset","isNodeMatchingSelectorFocusable","isNodeMatchingSelectorTabbable","isValidShadowRootTabbable","shadowHostNode","sortByOrder","regularTabbables","orderedTabbables","candidateTabindex","sortable","tabbable","container","focusable","isTabbable","focusableCandidateSelector","isFocusable","ownKeys","object","enumerableOnly","symbols","sym","_objectSpread2","source","_defineProperty","_toPropertyKey","_toPrimitive","input","hint","prim","arg","activeFocusTraps","trapStack","trap","activeTrap","trapIndex","isSelectableInput","isEscapeEvent","isTabEvent","isKeyForward","isKeyBackward","delay","findIndex","valueOrHandler","_len","_key","getActualTarget","internalTrapStack","createFocusTrap","userOptions","getOption","configOverrideOptions","optionName","configOptionName","findContainerIndex","tabbableNodes","getNodeForOption","optionValue","_len2","_key2","getInitialFocusNode","firstTabbableGroup","firstTabbableNode","updateTabbableNodes","focusableNodes","lastTabbableNode","firstDomTabbableNode","lastDomTabbableNode","posTabIndexesFound","nodeIdx","group","g","tryFocus","getReturnFocusNode","previousActiveElement","findNextNavNode","_ref2","_ref2$isBackward","isBackward","destinationNode","containerIndex","containerGroup","startOfGroupIndex","_ref3","destinationGroupIndex","destinationGroup","lastOfGroupIndex","_ref4","_destinationGroupIndex","_destinationGroup","checkPointerDown","checkFocusIn","targetContained","nextNode","navAcrossContainers","mruContainerIdx","mruTabIdx","checkKeyNav","checkKey","checkClick","addListeners","removeListeners","checkDomRemoval","mutations","isFocusedNodeRemoved","mutation","removedNodes","mutationObserver","updateObservedNodes","activateOptions","onActivate","onPostActivate","checkCanFocusTrap","finishActivation","deactivateOptions","onDeactivate","onPostDeactivate","checkCanReturnFocus","returnFocus","finishDeactivation","pauseOptions","onPause","onPostPause","unpauseOptions","onUnpause","onPostUnpause","containerElements","elementsAsArray","immediate","focusTrapOptions","hasFocus","isPaused","activate","deactivate","pause","unpause","_createFocusTrap","readonly","usePopper","popperElement","anchorElement","portal","usePortal","useFocusTrap","usedFocusTrap","targetEl","newTarget","tick","destroy","createLabel","INTERACTION_KEYS","defaults","createCombobox","props","withDefaults","highlightedItem","selectedWritable","selected","inputValue","openWritable","isEmpty","scrollAlignment","filterFunction","closeOnOutsideClick","closeOnEscape","preventScroll","positioning","touchedInput","ids","getOptionProps","label","selectItem","handleIsEmpty","menuElement","opt","openMenu","currentOpenState","triggerEl","selectedItem","closeMenu","isVisible","isSelected","$value","deepEqual","$highlightedItem","$inputValue","menuEl","enabledItems","itemElements","candidateNodes","$currentItem","$loop","$scrollAlignment","nextItem","unsubEscapeKeydown","escape","menu","$isVisible","unsubPopper","unsubScroll","$preventScroll","$closeOnEscape","$portal","$closeOnOutsideClick","$positioning","popper","labelBuilder","labelAction","option","$filterFunction","$touchedInput","hidden","onMount","selectedEl","dataLabel","$selected","goto","client_method","child_ctx","ctx","insert_hydration","span","anchor","create_if_block_1","create_if_block_2","li","append_hydration","div","set_data","t1","t1_value","t0_value","create_if_block","label_1","input_1","ul","dirty","set_data_maybe_contenteditable","t0","label_data","if_block","restaurants","$$props","products","p","$locale","$$invalidate","searchResult","$input","constants_0","info","handle_promise","promise","t_value","t","t2_value","t4_value","attr","li_aria_label_value","small","t2","t4","raw_value","localeToFlag","a_tabindex_value","toggle_class","html_tag","t6_value","t9_value","t12_value","title_value","each_value_2","each_value_1","each_value","meta","meta_content_value","h1","section","h20","ul0","h21","ul1","current","t6","searchbar_changes","t9","t12","code","letter","emojiCode","checkOpened"],"mappings":"2oBAKO,SAASA,GAAkBC,EAAwB,CACzD,OAAOA,GAAA,YAAAA,EAAwB,UAAW,OACvCA,EACA,MAAM,KAAKA,CAAsB,CACrC,CCRO,SAASC,GAAkBC,EAAQC,EAAS,CAClD,MAAMC,EAAS,CAAA,EACTC,EAAc,CAAA,EACdC,EAAgB,CAAE,QAAS,GACjC,IAAIC,EAAIL,EAAO,OACf,KAAOK,KAAK,CACX,MAAM,EAAIL,EAAOK,CAAC,EACZC,EAAIL,EAAQI,CAAC,EACnB,GAAIC,EAAG,CACN,UAAWC,KAAO,EACXA,KAAOD,IAAIH,EAAYI,CAAG,EAAI,GAErC,UAAWA,KAAOD,EACZF,EAAcG,CAAG,IACrBL,EAAOK,CAAG,EAAID,EAAEC,CAAG,EACnBH,EAAcG,CAAG,EAAI,GAGvBP,EAAOK,CAAC,EAAIC,CACf,KACG,WAAWC,KAAO,EACjBH,EAAcG,CAAG,EAAI,CAGvB,CACD,UAAWA,KAAOJ,EACXI,KAAOL,IAASA,EAAOK,CAAG,EAAI,QAErC,OAAOL,CACR,CC5BgB,SAAAM,GAAiBC,EAAuEC,EAAkB,IAAA,KAAA,EAAO,YAAA,EAAc,UAAU,GAAI,EAAE,EAAG,CAC9J,MAAI,CAACD,EAAW,YAAc,CAACA,EAAW,UAC/B,GAEPA,EAAW,UAAU,cAAcA,EAAW,UAAU,EAAI,EAExDA,EAAW,WAAW,cAAcC,CAAW,GAAK,GACpDD,EAAW,UAAU,cAAcC,CAAW,GAAK,EAInDD,EAAW,WAAW,cAAcC,CAAW,GAAK,GACpDD,EAAW,UAAU,cAAcC,CAAW,GAAK,CAG/D,CAEO,SAASC,GAAcC,EAAiB,IAAA,KAAQ,CAO5C,OANW,IAAI,KAAK,eAAe,CAAA,EAAI,CAC1C,SAAU,eACV,KAAM,UACN,OAAQ,UACR,OAAQ,SAAA,CACX,EACgB,OAAOA,CAAI,CAChC,CAEA,eAAsBC,GAAaC,EAAkD,CACjF,OAAO,IAAI,QAAQ,CAACC,EAASC,IAAW,CACpC,WAAW,IAAM,CACbD,EAAQ,KAAK,KAAK,KAAK,OAAO,EAAI,EAAE,CAAC,GACtC,GAAI,CAAA,CACV,CACL,CC1BA,SAASE,GAAQC,EAAO,CACtB,OAAQ,MAAM,QAEV,MAAM,QAAQA,CAAK,EADnBC,GAAOD,CAAK,IAAM,gBAExB,CAGA,MAAME,GAAW,EAAI,EACrB,SAASC,GAAaH,EAAO,CAE3B,GAAI,OAAOA,GAAS,SAClB,OAAOA,EAET,IAAII,EAASJ,EAAQ,GACrB,OAAOI,GAAU,KAAO,EAAIJ,GAAS,CAACE,GAAW,KAAOE,CAC1D,CAEA,SAASC,GAASL,EAAO,CACvB,OAAOA,GAAS,KAAO,GAAKG,GAAaH,CAAK,CAChD,CAEA,SAASM,GAASN,EAAO,CACvB,OAAO,OAAOA,GAAU,QAC1B,CAEA,SAASO,GAASP,EAAO,CACvB,OAAO,OAAOA,GAAU,QAC1B,CAGA,SAASQ,GAAUR,EAAO,CACxB,OACEA,IAAU,IACVA,IAAU,IACTS,GAAaT,CAAK,GAAKC,GAAOD,CAAK,GAAK,kBAE7C,CAEA,SAASU,GAASV,EAAO,CACvB,OAAO,OAAOA,GAAU,QAC1B,CAGA,SAASS,GAAaT,EAAO,CAC3B,OAAOU,GAASV,CAAK,GAAKA,IAAU,IACtC,CAEA,SAASW,GAAUX,EAAO,CACxB,OAA8BA,GAAU,IAC1C,CAEA,SAASY,GAAQZ,EAAO,CACtB,MAAO,CAACA,EAAM,KAAI,EAAG,MACvB,CAIA,SAASC,GAAOD,EAAO,CACrB,OAAOA,GAAS,KACZA,IAAU,OACR,qBACA,gBACF,OAAO,UAAU,SAAS,KAAKA,CAAK,CAC1C,CAIA,MAAMa,GAAuB,yBAEvBC,GAAwCzB,GAC5C,yBAAyBA,CAAG,GAExB0B,GAA4BC,GAChC,iCAAiCA,CAAG,IAEhCC,GAAwBC,GAAS,WAAWA,CAAI,mBAEhDC,GAA4B9B,GAChC,6BAA6BA,CAAG,+BAE5B+B,GAAS,OAAO,UAAU,eAEhC,MAAMC,EAAS,CACb,YAAYC,EAAM,CAChB,KAAK,MAAQ,GACb,KAAK,QAAU,GAEf,IAAIC,EAAc,EAElBD,EAAK,QAASjC,GAAQ,CACpB,IAAImC,EAAMC,GAAUpC,CAAG,EAEvBkC,GAAeC,EAAI,OAEnB,KAAK,MAAM,KAAKA,CAAG,EACnB,KAAK,QAAQA,EAAI,EAAE,EAAIA,EAEvBD,GAAeC,EAAI,MACzB,CAAK,EAGD,KAAK,MAAM,QAASnC,GAAQ,CAC1BA,EAAI,QAAUkC,CACpB,CAAK,CACF,CACD,IAAIG,EAAO,CACT,OAAO,KAAK,QAAQA,CAAK,CAC1B,CACD,MAAO,CACL,OAAO,KAAK,KACb,CACD,QAAS,CACP,OAAO,KAAK,UAAU,KAAK,KAAK,CACjC,CACH,CAEA,SAASD,GAAUpC,EAAK,CACtB,IAAIsC,EAAO,KACPC,EAAK,KACLC,EAAM,KACNC,EAAS,EACTC,EAAQ,KAEZ,GAAIzB,GAASjB,CAAG,GAAKU,GAAQV,CAAG,EAC9BwC,EAAMxC,EACNsC,EAAOK,GAAc3C,CAAG,EACxBuC,EAAKK,GAAY5C,CAAG,MACf,CACL,GAAI,CAAC+B,GAAO,KAAK/B,EAAK,MAAM,EAC1B,MAAM,IAAI,MAAM4B,GAAqB,MAAM,CAAC,EAG9C,MAAMC,EAAO7B,EAAI,KAGjB,GAFAwC,EAAMX,EAEFE,GAAO,KAAK/B,EAAK,QAAQ,IAC3ByC,EAASzC,EAAI,OAETyC,GAAU,GACZ,MAAM,IAAI,MAAMX,GAAyBD,CAAI,CAAC,EAIlDS,EAAOK,GAAcd,CAAI,EACzBU,EAAKK,GAAYf,CAAI,EACrBa,EAAQ1C,EAAI,KACb,CAED,MAAO,CAAE,KAAAsC,EAAM,GAAAC,EAAI,OAAAE,EAAQ,IAAAD,EAAK,MAAAE,CAAO,CACzC,CAEA,SAASC,GAAc3C,EAAK,CAC1B,OAAOU,GAAQV,CAAG,EAAIA,EAAMA,EAAI,MAAM,GAAG,CAC3C,CAEA,SAAS4C,GAAY5C,EAAK,CACxB,OAAOU,GAAQV,CAAG,EAAIA,EAAI,KAAK,GAAG,EAAIA,CACxC,CAEA,SAAS6C,GAAIV,EAAKG,EAAM,CACtB,IAAIQ,EAAO,CAAA,EACPC,EAAM,GAEV,MAAMC,EAAU,CAACb,EAAKG,EAAMW,IAAU,CACpC,GAAK3B,GAAUa,CAAG,EAGlB,GAAI,CAACG,EAAKW,CAAK,EAEbH,EAAK,KAAKX,CAAG,MACR,CACL,IAAInC,EAAMsC,EAAKW,CAAK,EAEpB,MAAMtC,EAAQwB,EAAInC,CAAG,EAErB,GAAI,CAACsB,GAAUX,CAAK,EAClB,OAKF,GACEsC,IAAUX,EAAK,OAAS,IACvBrB,GAASN,CAAK,GAAKO,GAASP,CAAK,GAAKQ,GAAUR,CAAK,GAEtDmC,EAAK,KAAK9B,GAASL,CAAK,CAAC,UAChBD,GAAQC,CAAK,EAAG,CACzBoC,EAAM,GAEN,QAASjD,EAAI,EAAGoD,EAAMvC,EAAM,OAAQb,EAAIoD,EAAKpD,GAAK,EAChDkD,EAAQrC,EAAMb,CAAC,EAAGwC,EAAMW,EAAQ,CAAC,CAE3C,MAAiBX,EAAK,QAEdU,EAAQrC,EAAO2B,EAAMW,EAAQ,CAAC,CAEjC,CACL,EAGE,OAAAD,EAAQb,EAAKlB,GAASqB,CAAI,EAAIA,EAAK,MAAM,GAAG,EAAIA,EAAM,CAAC,EAEhDS,EAAMD,EAAOA,EAAK,CAAC,CAC5B,CAEA,MAAMK,GAAe,CAInB,eAAgB,GAGhB,eAAgB,GAEhB,mBAAoB,CACtB,EAEMC,GAAe,CAGnB,gBAAiB,GAEjB,aAAc,GAEd,KAAM,CAAE,EAER,WAAY,GAEZ,OAAQ,CAACC,EAAGC,IACVD,EAAE,QAAUC,EAAE,MAASD,EAAE,IAAMC,EAAE,IAAM,GAAK,EAAKD,EAAE,MAAQC,EAAE,MAAQ,GAAK,CAC9E,EAEMC,GAAe,CAEnB,SAAU,EAGV,UAAW,GAMX,SAAU,GACZ,EAEMC,GAAkB,CAEtB,kBAAmB,GAGnB,MAAOX,GAIP,eAAgB,GAIhB,gBAAiB,GAEjB,gBAAiB,CACnB,EAEA,IAAIY,EAAS,CACX,GAAGL,GACH,GAAGD,GACH,GAAGI,GACH,GAAGC,EACL,EAEA,MAAME,GAAQ,SAId,SAASC,GAAKlB,EAAS,EAAGmB,EAAW,EAAG,CACtC,MAAMC,EAAQ,IAAI,IACZC,EAAI,KAAK,IAAI,GAAIF,CAAQ,EAE/B,MAAO,CACL,IAAIjD,EAAO,CACT,MAAMoD,EAAYpD,EAAM,MAAM+C,EAAK,EAAE,OAErC,GAAIG,EAAM,IAAIE,CAAS,EACrB,OAAOF,EAAM,IAAIE,CAAS,EAI5B,MAAMJ,EAAO,EAAI,KAAK,IAAII,EAAW,GAAMtB,CAAM,EAG3C1C,EAAI,WAAW,KAAK,MAAM4D,EAAOG,CAAC,EAAIA,CAAC,EAE7C,OAAAD,EAAM,IAAIE,EAAWhE,CAAC,EAEfA,CACR,EACD,OAAQ,CACN8D,EAAM,MAAK,CACZ,CACF,CACH,CAEA,MAAMG,EAAU,CACd,YAAY,CACV,MAAAtB,EAAQe,EAAO,MACf,gBAAAQ,EAAkBR,EAAO,eAC1B,EAAG,GAAI,CACN,KAAK,KAAOE,GAAKM,EAAiB,CAAC,EACnC,KAAK,MAAQvB,EACb,KAAK,UAAY,GAEjB,KAAK,gBAAe,CACrB,CACD,WAAWwB,EAAO,GAAI,CACpB,KAAK,KAAOA,CACb,CACD,gBAAgBC,EAAU,GAAI,CAC5B,KAAK,QAAUA,CAChB,CACD,QAAQlC,EAAO,GAAI,CACjB,KAAK,KAAOA,EACZ,KAAK,SAAW,GAChBA,EAAK,QAAQ,CAACjC,EAAKoE,IAAQ,CACzB,KAAK,SAASpE,EAAI,EAAE,EAAIoE,CAC9B,CAAK,CACF,CACD,QAAS,CACH,KAAK,WAAa,CAAC,KAAK,KAAK,SAIjC,KAAK,UAAY,GAGbnD,GAAS,KAAK,KAAK,CAAC,CAAC,EACvB,KAAK,KAAK,QAAQ,CAACoD,EAAKC,IAAa,CACnC,KAAK,WAAWD,EAAKC,CAAQ,CACrC,CAAO,EAGD,KAAK,KAAK,QAAQ,CAACD,EAAKC,IAAa,CACnC,KAAK,WAAWD,EAAKC,CAAQ,CACrC,CAAO,EAGH,KAAK,KAAK,QACX,CAED,IAAID,EAAK,CACP,MAAMD,EAAM,KAAK,OAEbnD,GAASoD,CAAG,EACd,KAAK,WAAWA,EAAKD,CAAG,EAExB,KAAK,WAAWC,EAAKD,CAAG,CAE3B,CAED,SAASA,EAAK,CACZ,KAAK,QAAQ,OAAOA,EAAK,CAAC,EAG1B,QAAStE,EAAIsE,EAAKlB,EAAM,KAAK,KAAM,EAAEpD,EAAIoD,EAAKpD,GAAK,EACjD,KAAK,QAAQA,CAAC,EAAE,GAAK,CAExB,CACD,uBAAuByE,EAAMlC,EAAO,CAClC,OAAOkC,EAAK,KAAK,SAASlC,CAAK,CAAC,CACjC,CACD,MAAO,CACL,OAAO,KAAK,QAAQ,MACrB,CACD,WAAWgC,EAAKC,EAAU,CACxB,GAAI,CAAChD,GAAU+C,CAAG,GAAK9C,GAAQ8C,CAAG,EAChC,OAGF,IAAIG,EAAS,CACX,EAAGH,EACH,EAAGC,EACH,EAAG,KAAK,KAAK,IAAID,CAAG,CAC1B,EAEI,KAAK,QAAQ,KAAKG,CAAM,CACzB,CACD,WAAWH,EAAKC,EAAU,CACxB,IAAIE,EAAS,CAAE,EAAGF,EAAU,EAAG,CAAE,CAAA,EAGjC,KAAK,KAAK,QAAQ,CAACtE,EAAKyE,IAAa,CACnC,IAAI9D,EAAQX,EAAI,MAAQA,EAAI,MAAMqE,CAAG,EAAI,KAAK,MAAMA,EAAKrE,EAAI,IAAI,EAEjE,GAAKsB,GAAUX,CAAK,GAIpB,GAAID,GAAQC,CAAK,EAAG,CAClB,IAAI+D,EAAa,CAAA,EACjB,MAAMC,EAAQ,CAAC,CAAE,eAAgB,GAAI,MAAAhE,CAAK,CAAE,EAE5C,KAAOgE,EAAM,QAAQ,CACnB,KAAM,CAAE,eAAAC,EAAgB,MAAAjE,CAAO,EAAGgE,EAAM,IAAG,EAE3C,GAAKrD,GAAUX,CAAK,EAIpB,GAAIM,GAASN,CAAK,GAAK,CAACY,GAAQZ,CAAK,EAAG,CACtC,IAAIkE,EAAY,CACd,EAAGlE,EACH,EAAGiE,EACH,EAAG,KAAK,KAAK,IAAIjE,CAAK,CACpC,EAEY+D,EAAW,KAAKG,CAAS,CACrC,MAAqBnE,GAAQC,CAAK,GACtBA,EAAM,QAAQ,CAAC4D,EAAMO,IAAM,CACzBH,EAAM,KAAK,CACT,eAAgBG,EAChB,MAAOP,CACvB,CAAe,CACf,CAAa,CAEJ,CACDC,EAAO,EAAEC,CAAQ,EAAIC,CAC7B,SAAiBzD,GAASN,CAAK,GAAK,CAACY,GAAQZ,CAAK,EAAG,CAC7C,IAAIkE,EAAY,CACd,EAAGlE,EACH,EAAG,KAAK,KAAK,IAAIA,CAAK,CAChC,EAEQ6D,EAAO,EAAEC,CAAQ,EAAII,CACtB,EACP,CAAK,EAED,KAAK,QAAQ,KAAKL,CAAM,CACzB,CACD,QAAS,CACP,MAAO,CACL,KAAM,KAAK,KACX,QAAS,KAAK,OACf,CACF,CACH,CAEA,SAASO,GACP9C,EACAiC,EACA,CAAE,MAAAxB,EAAQe,EAAO,MAAO,gBAAAQ,EAAkBR,EAAO,eAAe,EAAK,CAAE,EACvE,CACA,MAAMuB,EAAU,IAAIhB,GAAU,CAAE,MAAAtB,EAAO,gBAAAuB,CAAiB,CAAA,EACxD,OAAAe,EAAQ,QAAQ/C,EAAK,IAAIG,EAAS,CAAC,EACnC4C,EAAQ,WAAWd,CAAI,EACvBc,EAAQ,OAAM,EACPA,CACT,CAEA,SAASC,GACPC,EACA,CAAE,MAAAxC,EAAQe,EAAO,MAAO,gBAAAQ,EAAkBR,EAAO,eAAe,EAAK,CAAE,EACvE,CACA,KAAM,CAAE,KAAAxB,EAAM,QAAAkC,CAAS,EAAGe,EACpBF,EAAU,IAAIhB,GAAU,CAAE,MAAAtB,EAAO,gBAAAuB,CAAiB,CAAA,EACxD,OAAAe,EAAQ,QAAQ/C,CAAI,EACpB+C,EAAQ,gBAAgBb,CAAO,EACxBa,CACT,CAEA,SAASG,GACPC,EACA,CACE,OAAAC,EAAS,EACT,gBAAAC,EAAkB,EAClB,iBAAAC,EAAmB,EACnB,SAAAC,EAAW/B,EAAO,SAClB,eAAAgC,EAAiBhC,EAAO,cAC5B,EAAM,CAAE,EACN,CACA,MAAMiC,EAAWL,EAASD,EAAQ,OAElC,GAAIK,EACF,OAAOC,EAGT,MAAMC,EAAY,KAAK,IAAIJ,EAAmBD,CAAe,EAE7D,OAAKE,EAKEE,EAAWC,EAAYH,EAHrBG,EAAY,EAAMD,CAI7B,CAEA,SAASE,GACPC,EAAY,CAAE,EACdC,EAAqBrC,EAAO,mBAC5B,CACA,IAAIsC,EAAU,CAAA,EACVC,EAAQ,GACRC,EAAM,GACNnG,EAAI,EAER,QAASoD,EAAM2C,EAAU,OAAQ/F,EAAIoD,EAAKpD,GAAK,EAAG,CAChD,IAAIoG,EAAQL,EAAU/F,CAAC,EACnBoG,GAASF,IAAU,GACrBA,EAAQlG,EACC,CAACoG,GAASF,IAAU,KAC7BC,EAAMnG,EAAI,EACNmG,EAAMD,EAAQ,GAAKF,GACrBC,EAAQ,KAAK,CAACC,EAAOC,CAAG,CAAC,EAE3BD,EAAQ,GAEX,CAGD,OAAIH,EAAU/F,EAAI,CAAC,GAAKA,EAAIkG,GAASF,GACnCC,EAAQ,KAAK,CAACC,EAAOlG,EAAI,CAAC,CAAC,EAGtBiG,CACT,CAGA,MAAMI,GAAW,GAEjB,SAASC,GACPC,EACAjB,EACAkB,EACA,CACE,SAAAC,EAAW9C,EAAO,SAClB,SAAA+B,EAAW/B,EAAO,SAClB,UAAA+C,EAAY/C,EAAO,UACnB,eAAAgD,EAAiBhD,EAAO,eACxB,mBAAAqC,EAAqBrC,EAAO,mBAC5B,eAAAiD,EAAiBjD,EAAO,eACxB,eAAAgC,EAAiBhC,EAAO,cAC5B,EAAM,CAAE,EACN,CACA,GAAI2B,EAAQ,OAASe,GACnB,MAAM,IAAI,MAAMzE,GAAyByE,EAAQ,CAAC,EAGpD,MAAMQ,EAAavB,EAAQ,OAErBwB,EAAUP,EAAK,OAEfd,EAAmB,KAAK,IAAI,EAAG,KAAK,IAAIgB,EAAUK,CAAO,CAAC,EAEhE,IAAIC,EAAmBL,EAEnBM,EAAevB,EAInB,MAAMwB,EAAiBjB,EAAqB,GAAKY,EAE3CM,EAAYD,EAAiB,MAAMH,CAAO,EAAI,CAAA,EAEpD,IAAI3D,EAGJ,MAAQA,EAAQoD,EAAK,QAAQjB,EAAS0B,CAAY,GAAK,IAAI,CACzD,IAAIG,EAAQ9B,GAAeC,EAAS,CAClC,gBAAiBnC,EACjB,iBAAAsC,EACA,SAAAC,EACA,eAAAC,CACN,CAAK,EAKD,GAHAoB,EAAmB,KAAK,IAAII,EAAOJ,CAAgB,EACnDC,EAAe7D,EAAQ0D,EAEnBI,EAAgB,CAClB,IAAIjH,EAAI,EACR,KAAOA,EAAI6G,GACTK,EAAU/D,EAAQnD,CAAC,EAAI,EACvBA,GAAK,CAER,CACF,CAGDgH,EAAe,GAEf,IAAII,EAAa,CAAA,EACbC,EAAa,EACbC,EAAST,EAAaC,EAE1B,MAAMS,EAAO,GAAMV,EAAa,EAEhC,QAAS7G,EAAI,EAAGA,EAAI6G,EAAY7G,GAAK,EAAG,CAItC,IAAIwH,EAAS,EACTC,EAASH,EAEb,KAAOE,EAASC,GACApC,GAAeC,EAAS,CACpC,OAAQtF,EACR,gBAAiByF,EAAmBgC,EACpC,iBAAAhC,EACA,SAAAC,EACA,eAAAC,CACR,CAAO,GAEYoB,EACXS,EAASC,EAETH,EAASG,EAGXA,EAAS,KAAK,OAAOH,EAASE,GAAU,EAAIA,CAAM,EAIpDF,EAASG,EAET,IAAIvB,EAAQ,KAAK,IAAI,EAAGT,EAAmBgC,EAAS,CAAC,EACjDC,EAASf,EACTG,EACA,KAAK,IAAIrB,EAAmBgC,EAAQX,CAAO,EAAID,EAG/Cc,EAAS,MAAMD,EAAS,CAAC,EAE7BC,EAAOD,EAAS,CAAC,GAAK,GAAK1H,GAAK,EAEhC,QAAS4H,EAAIF,EAAQE,GAAK1B,EAAO0B,GAAK,EAAG,CACvC,IAAIpC,EAAkBoC,EAAI,EACtBC,EAAYrB,EAAgBD,EAAK,OAAOf,CAAe,CAAC,EAgB5D,GAdIyB,IAEFC,EAAU1B,CAAe,EAAI,CAAC,CAAC,CAACqC,GAIlCF,EAAOC,CAAC,GAAMD,EAAOC,EAAI,CAAC,GAAK,EAAK,GAAKC,EAGrC7H,IACF2H,EAAOC,CAAC,IACJR,EAAWQ,EAAI,CAAC,EAAIR,EAAWQ,CAAC,IAAM,EAAK,EAAIR,EAAWQ,EAAI,CAAC,GAGjED,EAAOC,CAAC,EAAIL,IACdF,EAAahC,GAAeC,EAAS,CACnC,OAAQtF,EACR,gBAAAwF,EACA,iBAAAC,EACA,SAAAC,EACA,eAAAC,CACV,CAAS,EAIG0B,GAAcN,GAAkB,CAMlC,GAJAA,EAAmBM,EACnBL,EAAexB,EAGXwB,GAAgBvB,EAClB,MAIFS,EAAQ,KAAK,IAAI,EAAG,EAAIT,EAAmBuB,CAAY,CACxD,CAEJ,CAWD,GARc3B,GAAeC,EAAS,CACpC,OAAQtF,EAAI,EACZ,gBAAiByF,EACjB,iBAAAA,EACA,SAAAC,EACA,eAAAC,CACN,CAAK,EAEWoB,EACV,MAGFK,EAAaO,CACd,CAED,MAAM1G,EAAS,CACb,QAAS+F,GAAgB,EAEzB,MAAO,KAAK,IAAI,KAAOK,CAAU,CACrC,EAEE,GAAIJ,EAAgB,CAClB,MAAMhB,EAAUH,GAAqBoB,EAAWlB,CAAkB,EAC7DC,EAAQ,OAEFW,IACT3F,EAAO,QAAUgF,GAFjBhF,EAAO,QAAU,EAIpB,CAED,OAAOA,CACT,CAEA,SAAS6G,GAAsBxC,EAAS,CACtC,IAAIiC,EAAO,CAAA,EAEX,QAASvH,EAAI,EAAGoD,EAAMkC,EAAQ,OAAQtF,EAAIoD,EAAKpD,GAAK,EAAG,CACrD,MAAM+H,EAAOzC,EAAQ,OAAOtF,CAAC,EAC7BuH,EAAKQ,CAAI,GAAKR,EAAKQ,CAAI,GAAK,GAAM,GAAM3E,EAAMpD,EAAI,CACnD,CAED,OAAOuH,CACT,CAEA,MAAMS,EAAY,CAChB,YACE1C,EACA,CACE,SAAAmB,EAAW9C,EAAO,SAClB,UAAA+C,EAAY/C,EAAO,UACnB,SAAA+B,EAAW/B,EAAO,SAClB,eAAAiD,EAAiBjD,EAAO,eACxB,eAAAgD,EAAiBhD,EAAO,eACxB,mBAAAqC,EAAqBrC,EAAO,mBAC5B,gBAAAsE,EAAkBtE,EAAO,gBACzB,eAAAgC,EAAiBhC,EAAO,cAC9B,EAAQ,CAAE,EACN,CAgBA,GAfA,KAAK,QAAU,CACb,SAAA8C,EACA,UAAAC,EACA,SAAAhB,EACA,eAAAkB,EACA,eAAAD,EACA,mBAAAX,EACA,gBAAAiC,EACA,eAAAtC,CACN,EAEI,KAAK,QAAUsC,EAAkB3C,EAAUA,EAAQ,YAAW,EAE9D,KAAK,OAAS,GAEV,CAAC,KAAK,QAAQ,OAChB,OAGF,MAAM4C,EAAW,CAAC5C,EAAS6C,IAAe,CACxC,KAAK,OAAO,KAAK,CACf,QAAA7C,EACA,SAAUwC,GAAsBxC,CAAO,EACvC,WAAA6C,CACR,CAAO,CACP,EAEU/E,EAAM,KAAK,QAAQ,OAEzB,GAAIA,EAAMiD,GAAU,CAClB,IAAIrG,EAAI,EACR,MAAMoI,EAAYhF,EAAMiD,GAClBF,EAAM/C,EAAMgF,EAElB,KAAOpI,EAAImG,GACT+B,EAAS,KAAK,QAAQ,OAAOlI,EAAGqG,EAAQ,EAAGrG,CAAC,EAC5CA,GAAKqG,GAGP,GAAI+B,EAAW,CACb,MAAMD,EAAa/E,EAAMiD,GACzB6B,EAAS,KAAK,QAAQ,OAAOC,CAAU,EAAGA,CAAU,CACrD,CACP,MACMD,EAAS,KAAK,QAAS,CAAC,CAE3B,CAED,SAAS3B,EAAM,CACb,KAAM,CAAE,gBAAA0B,EAAiB,eAAArB,GAAmB,KAAK,QAOjD,GALKqB,IACH1B,EAAOA,EAAK,eAIV,KAAK,UAAYA,EAAM,CACzB,IAAItF,EAAS,CACX,QAAS,GACT,MAAO,CACf,EAEM,OAAI2F,IACF3F,EAAO,QAAU,CAAC,CAAC,EAAGsF,EAAK,OAAS,CAAC,CAAC,GAGjCtF,CACR,CAGD,KAAM,CACJ,SAAAwF,EACA,SAAAf,EACA,UAAAgB,EACA,eAAAC,EACA,mBAAAX,EACA,eAAAL,CACN,EAAQ,KAAK,QAET,IAAI0C,EAAa,CAAA,EACbC,EAAa,EACbC,EAAa,GAEjB,KAAK,OAAO,QAAQ,CAAC,CAAE,QAAAjD,EAAS,SAAAkD,EAAU,WAAAL,KAAiB,CACzD,KAAM,CAAE,QAAAM,EAAS,MAAAtB,EAAO,QAAAlB,CAAO,EAAKK,GAAOC,EAAMjB,EAASkD,EAAU,CAClE,SAAU/B,EAAW0B,EACrB,SAAAzC,EACA,UAAAgB,EACA,eAAAC,EACA,mBAAAX,EACA,eAAAY,EACA,eAAAjB,CACR,CAAO,EAEG8C,IACFF,EAAa,IAGfD,GAAcnB,EAEVsB,GAAWxC,IACboC,EAAa,CAAC,GAAGA,EAAY,GAAGpC,CAAO,EAE/C,CAAK,EAED,IAAIhF,EAAS,CACX,QAASsH,EACT,MAAOA,EAAaD,EAAa,KAAK,OAAO,OAAS,CAC5D,EAEI,OAAIC,GAAc3B,IAChB3F,EAAO,QAAUoH,GAGZpH,CACR,CACH,CAEA,MAAMyH,EAAU,CACd,YAAYpD,EAAS,CACnB,KAAK,QAAUA,CAChB,CACD,OAAO,aAAaA,EAAS,CAC3B,OAAOqD,GAASrD,EAAS,KAAK,UAAU,CACzC,CACD,OAAO,cAAcA,EAAS,CAC5B,OAAOqD,GAASrD,EAAS,KAAK,WAAW,CAC1C,CACD,QAAiB,CAAE,CACrB,CAEA,SAASqD,GAASrD,EAASsD,EAAK,CAC9B,MAAMC,EAAUvD,EAAQ,MAAMsD,CAAG,EACjC,OAAOC,EAAUA,EAAQ,CAAC,EAAI,IAChC,CAIA,MAAMC,WAAmBJ,EAAU,CACjC,YAAYpD,EAAS,CACnB,MAAMA,CAAO,CACd,CACD,WAAW,MAAO,CAChB,MAAO,OACR,CACD,WAAW,YAAa,CACtB,MAAO,WACR,CACD,WAAW,aAAc,CACvB,MAAO,SACR,CACD,OAAOiB,EAAM,CACX,MAAMkC,EAAUlC,IAAS,KAAK,QAE9B,MAAO,CACL,QAAAkC,EACA,MAAOA,EAAU,EAAI,EACrB,QAAS,CAAC,EAAG,KAAK,QAAQ,OAAS,CAAC,CACrC,CACF,CACH,CAIA,MAAMM,WAA0BL,EAAU,CACxC,YAAYpD,EAAS,CACnB,MAAMA,CAAO,CACd,CACD,WAAW,MAAO,CAChB,MAAO,eACR,CACD,WAAW,YAAa,CACtB,MAAO,WACR,CACD,WAAW,aAAc,CACvB,MAAO,SACR,CACD,OAAOiB,EAAM,CAEX,MAAMkC,EADQlC,EAAK,QAAQ,KAAK,OAAO,IACb,GAE1B,MAAO,CACL,QAAAkC,EACA,MAAOA,EAAU,EAAI,EACrB,QAAS,CAAC,EAAGlC,EAAK,OAAS,CAAC,CAC7B,CACF,CACH,CAIA,MAAMyC,WAAyBN,EAAU,CACvC,YAAYpD,EAAS,CACnB,MAAMA,CAAO,CACd,CACD,WAAW,MAAO,CAChB,MAAO,cACR,CACD,WAAW,YAAa,CACtB,MAAO,YACR,CACD,WAAW,aAAc,CACvB,MAAO,UACR,CACD,OAAOiB,EAAM,CACX,MAAMkC,EAAUlC,EAAK,WAAW,KAAK,OAAO,EAE5C,MAAO,CACL,QAAAkC,EACA,MAAOA,EAAU,EAAI,EACrB,QAAS,CAAC,EAAG,KAAK,QAAQ,OAAS,CAAC,CACrC,CACF,CACH,CAIA,MAAMQ,WAAgCP,EAAU,CAC9C,YAAYpD,EAAS,CACnB,MAAMA,CAAO,CACd,CACD,WAAW,MAAO,CAChB,MAAO,sBACR,CACD,WAAW,YAAa,CACtB,MAAO,aACR,CACD,WAAW,aAAc,CACvB,MAAO,WACR,CACD,OAAOiB,EAAM,CACX,MAAMkC,EAAU,CAAClC,EAAK,WAAW,KAAK,OAAO,EAE7C,MAAO,CACL,QAAAkC,EACA,MAAOA,EAAU,EAAI,EACrB,QAAS,CAAC,EAAGlC,EAAK,OAAS,CAAC,CAC7B,CACF,CACH,CAIA,MAAM2C,WAAyBR,EAAU,CACvC,YAAYpD,EAAS,CACnB,MAAMA,CAAO,CACd,CACD,WAAW,MAAO,CAChB,MAAO,cACR,CACD,WAAW,YAAa,CACtB,MAAO,YACR,CACD,WAAW,aAAc,CACvB,MAAO,UACR,CACD,OAAOiB,EAAM,CACX,MAAMkC,EAAUlC,EAAK,SAAS,KAAK,OAAO,EAE1C,MAAO,CACL,QAAAkC,EACA,MAAOA,EAAU,EAAI,EACrB,QAAS,CAAClC,EAAK,OAAS,KAAK,QAAQ,OAAQA,EAAK,OAAS,CAAC,CAC7D,CACF,CACH,CAIA,MAAM4C,WAAgCT,EAAU,CAC9C,YAAYpD,EAAS,CACnB,MAAMA,CAAO,CACd,CACD,WAAW,MAAO,CAChB,MAAO,sBACR,CACD,WAAW,YAAa,CACtB,MAAO,aACR,CACD,WAAW,aAAc,CACvB,MAAO,WACR,CACD,OAAOiB,EAAM,CACX,MAAMkC,EAAU,CAAClC,EAAK,SAAS,KAAK,OAAO,EAC3C,MAAO,CACL,QAAAkC,EACA,MAAOA,EAAU,EAAI,EACrB,QAAS,CAAC,EAAGlC,EAAK,OAAS,CAAC,CAC7B,CACF,CACH,CAEA,MAAM6C,WAAmBV,EAAU,CACjC,YACEpD,EACA,CACE,SAAAmB,EAAW9C,EAAO,SAClB,UAAA+C,EAAY/C,EAAO,UACnB,SAAA+B,EAAW/B,EAAO,SAClB,eAAAiD,EAAiBjD,EAAO,eACxB,eAAAgD,EAAiBhD,EAAO,eACxB,mBAAAqC,EAAqBrC,EAAO,mBAC5B,gBAAAsE,EAAkBtE,EAAO,gBACzB,eAAAgC,EAAiBhC,EAAO,cAC9B,EAAQ,CAAE,EACN,CACA,MAAM2B,CAAO,EACb,KAAK,aAAe,IAAI0C,GAAY1C,EAAS,CAC3C,SAAAmB,EACA,UAAAC,EACA,SAAAhB,EACA,eAAAkB,EACA,eAAAD,EACA,mBAAAX,EACA,gBAAAiC,EACA,eAAAtC,CACN,CAAK,CACF,CACD,WAAW,MAAO,CAChB,MAAO,OACR,CACD,WAAW,YAAa,CACtB,MAAO,UACR,CACD,WAAW,aAAc,CACvB,MAAO,QACR,CACD,OAAOY,EAAM,CACX,OAAO,KAAK,aAAa,SAASA,CAAI,CACvC,CACH,CAIA,MAAM8C,WAAqBX,EAAU,CACnC,YAAYpD,EAAS,CACnB,MAAMA,CAAO,CACd,CACD,WAAW,MAAO,CAChB,MAAO,SACR,CACD,WAAW,YAAa,CACtB,MAAO,WACR,CACD,WAAW,aAAc,CACvB,MAAO,SACR,CACD,OAAOiB,EAAM,CACX,IAAIE,EAAW,EACXtD,EAEJ,MAAM8C,EAAU,CAAA,EACVY,EAAa,KAAK,QAAQ,OAGhC,MAAQ1D,EAAQoD,EAAK,QAAQ,KAAK,QAASE,CAAQ,GAAK,IACtDA,EAAWtD,EAAQ0D,EACnBZ,EAAQ,KAAK,CAAC9C,EAAOsD,EAAW,CAAC,CAAC,EAGpC,MAAMgC,EAAU,CAAC,CAACxC,EAAQ,OAE1B,MAAO,CACL,QAAAwC,EACA,MAAOA,EAAU,EAAI,EACrB,QAAAxC,CACD,CACF,CACH,CAGA,MAAMqD,GAAY,CAChBR,GACAO,GACAL,GACAC,GACAE,GACAD,GACAH,GACAK,EACF,EAEMG,GAAeD,GAAU,OAGzBE,GAAW,qCACXC,GAAW,IAKjB,SAASC,GAAWpE,EAASqE,EAAU,GAAI,CACzC,OAAOrE,EAAQ,MAAMmE,EAAQ,EAAE,IAAKhF,GAAS,CAC3C,IAAImF,EAAQnF,EACT,KAAM,EACN,MAAM+E,EAAQ,EACd,OAAQ/E,GAASA,GAAQ,CAAC,CAACA,EAAK,KAAI,CAAE,EAErCoF,EAAU,CAAA,EACd,QAAS7J,EAAI,EAAGoD,EAAMwG,EAAM,OAAQ5J,EAAIoD,EAAKpD,GAAK,EAAG,CACnD,MAAM8J,EAAYF,EAAM5J,CAAC,EAGzB,IAAI+J,EAAQ,GACRzF,EAAM,GACV,KAAO,CAACyF,GAAS,EAAEzF,EAAMiF,IAAc,CACrC,MAAMS,EAAWV,GAAUhF,CAAG,EAC9B,IAAI2F,EAAQD,EAAS,aAAaF,CAAS,EACvCG,IACFJ,EAAQ,KAAK,IAAIG,EAASC,EAAON,CAAO,CAAC,EACzCI,EAAQ,GAEX,CAED,GAAI,CAAAA,EAMJ,IADAzF,EAAM,GACC,EAAEA,EAAMiF,IAAc,CAC3B,MAAMS,EAAWV,GAAUhF,CAAG,EAC9B,IAAI2F,EAAQD,EAAS,cAAcF,CAAS,EAC5C,GAAIG,EAAO,CACTJ,EAAQ,KAAK,IAAIG,EAASC,EAAON,CAAO,CAAC,EACzC,KACD,CACF,CACF,CAED,OAAOE,CACX,CAAG,CACH,CAIA,MAAMK,GAAgB,IAAI,IAAI,CAACd,GAAW,KAAMC,GAAa,IAAI,CAAC,EA8BlE,MAAMc,EAAe,CACnB,YACE7E,EACA,CACE,gBAAA2C,EAAkBtE,EAAO,gBACzB,eAAAiD,EAAiBjD,EAAO,eACxB,mBAAAqC,EAAqBrC,EAAO,mBAC5B,eAAAgC,EAAiBhC,EAAO,eACxB,eAAAgD,EAAiBhD,EAAO,eACxB,SAAA8C,EAAW9C,EAAO,SAClB,UAAA+C,EAAY/C,EAAO,UACnB,SAAA+B,EAAW/B,EAAO,QACxB,EAAQ,CAAE,EACN,CACA,KAAK,MAAQ,KACb,KAAK,QAAU,CACb,gBAAAsE,EACA,eAAArB,EACA,mBAAAZ,EACA,eAAAW,EACA,eAAAhB,EACA,SAAAc,EACA,UAAAC,EACA,SAAAhB,CACN,EAEI,KAAK,QAAUuC,EAAkB3C,EAAUA,EAAQ,YAAW,EAC9D,KAAK,MAAQoE,GAAW,KAAK,QAAS,KAAK,OAAO,CACnD,CAED,OAAO,UAAUU,EAAGT,EAAS,CAC3B,OAAOA,EAAQ,iBAChB,CAED,SAASpD,EAAM,CACb,MAAMqD,EAAQ,KAAK,MAEnB,GAAI,CAACA,EACH,MAAO,CACL,QAAS,GACT,MAAO,CACR,EAGH,KAAM,CAAE,eAAAhD,EAAgB,gBAAAqB,GAAoB,KAAK,QAEjD1B,EAAO0B,EAAkB1B,EAAOA,EAAK,YAAW,EAEhD,IAAI8D,EAAa,EACbhC,EAAa,CAAA,EACbC,EAAa,EAGjB,QAAStI,EAAI,EAAGsK,EAAOV,EAAM,OAAQ5J,EAAIsK,EAAMtK,GAAK,EAAG,CACrD,MAAMsJ,EAAYM,EAAM5J,CAAC,EAGzBqI,EAAW,OAAS,EACpBgC,EAAa,EAGb,QAASzC,EAAI,EAAG2C,EAAOjB,EAAU,OAAQ1B,EAAI2C,EAAM3C,GAAK,EAAG,CACzD,MAAMoC,EAAWV,EAAU1B,CAAC,EACtB,CAAE,QAAAa,EAAS,QAAAxC,EAAS,MAAAkB,CAAO,EAAG6C,EAAS,OAAOzD,CAAI,EAExD,GAAIkC,GAGF,GAFA4B,GAAc,EACd/B,GAAcnB,EACVP,EAAgB,CAClB,MAAM4D,EAAOR,EAAS,YAAY,KAC9BE,GAAc,IAAIM,CAAI,EACxBnC,EAAa,CAAC,GAAGA,EAAY,GAAGpC,CAAO,EAEvCoC,EAAW,KAAKpC,CAAO,CAE1B,MACI,CACLqC,EAAa,EACb+B,EAAa,EACbhC,EAAW,OAAS,EACpB,KACD,CACF,CAGD,GAAIgC,EAAY,CACd,IAAIpJ,EAAS,CACX,QAAS,GACT,MAAOqH,EAAa+B,CAC9B,EAEQ,OAAIzD,IACF3F,EAAO,QAAUoH,GAGZpH,CACR,CACF,CAGD,MAAO,CACL,QAAS,GACT,MAAO,CACR,CACF,CACH,CAEA,MAAMwJ,GAAsB,CAAA,EAE5B,SAASC,MAAYC,EAAM,CACzBF,GAAoB,KAAK,GAAGE,CAAI,CAClC,CAEA,SAASC,GAAetF,EAASqE,EAAS,CACxC,QAAS3J,EAAI,EAAGoD,EAAMqH,GAAoB,OAAQzK,EAAIoD,EAAKpD,GAAK,EAAG,CACjE,IAAI6K,EAAgBJ,GAAoBzK,CAAC,EACzC,GAAI6K,EAAc,UAAUvF,EAASqE,CAAO,EAC1C,OAAO,IAAIkB,EAAcvF,EAASqE,CAAO,CAE5C,CAED,OAAO,IAAI3B,GAAY1C,EAASqE,CAAO,CACzC,CAEA,MAAMmB,GAAkB,CACtB,IAAK,OACL,GAAI,KACN,EAEMC,GAAU,CACd,KAAM,QACN,QAAS,MACX,EAEMC,GAAgBpB,GACpB,CAAC,EAAEA,EAAMkB,GAAgB,GAAG,GAAKlB,EAAMkB,GAAgB,EAAE,GAErDG,GAAUrB,GAAU,CAAC,CAACA,EAAMmB,GAAQ,IAAI,EAExCG,GAAUtB,GACd,CAAChJ,GAAQgJ,CAAK,GAAKrI,GAASqI,CAAK,GAAK,CAACoB,GAAapB,CAAK,EAErDuB,GAAqBvB,IAAW,CACpC,CAACkB,GAAgB,GAAG,EAAG,OAAO,KAAKlB,CAAK,EAAE,IAAK1J,IAAS,CACtD,CAACA,CAAG,EAAG0J,EAAM1J,CAAG,CACpB,EAAI,CACJ,GAIA,SAASkL,GAAMxB,EAAOD,EAAS,CAAE,KAAA0B,EAAO,EAAM,EAAG,GAAI,CACnD,MAAMC,EAAQ1B,GAAU,CACtB,IAAIzH,EAAO,OAAO,KAAKyH,CAAK,EAE5B,MAAM2B,EAAcN,GAAOrB,CAAK,EAEhC,GAAI,CAAC2B,GAAepJ,EAAK,OAAS,GAAK,CAAC6I,GAAapB,CAAK,EACxD,OAAO0B,EAAKH,GAAkBvB,CAAK,CAAC,EAGtC,GAAIsB,GAAOtB,CAAK,EAAG,CACjB,MAAM1J,EAAMqL,EAAc3B,EAAMmB,GAAQ,IAAI,EAAI5I,EAAK,CAAC,EAEhDmD,EAAUiG,EAAc3B,EAAMmB,GAAQ,OAAO,EAAInB,EAAM1J,CAAG,EAEhE,GAAI,CAACiB,GAASmE,CAAO,EACnB,MAAM,IAAI,MAAM3D,GAAqCzB,CAAG,CAAC,EAG3D,MAAMmC,EAAM,CACV,MAAOS,GAAY5C,CAAG,EACtB,QAAAoF,CACR,EAEM,OAAI+F,IACFhJ,EAAI,SAAWuI,GAAetF,EAASqE,CAAO,GAGzCtH,CACR,CAED,IAAImJ,EAAO,CACT,SAAU,CAAE,EACZ,SAAUrJ,EAAK,CAAC,CACtB,EAEI,OAAAA,EAAK,QAASjC,GAAQ,CACpB,MAAMW,EAAQ+I,EAAM1J,CAAG,EAEnBU,GAAQC,CAAK,GACfA,EAAM,QAAS4D,GAAS,CACtB+G,EAAK,SAAS,KAAKF,EAAK7G,CAAI,CAAC,CACvC,CAAS,CAET,CAAK,EAEM+G,CACX,EAEE,OAAKR,GAAapB,CAAK,IACrBA,EAAQuB,GAAkBvB,CAAK,GAG1B0B,EAAK1B,CAAK,CACnB,CAGA,SAAS6B,GACP5B,EACA,CAAE,gBAAA6B,EAAkB/H,EAAO,eAAiB,EAC5C,CACAkG,EAAQ,QAAS5I,GAAW,CAC1B,IAAIqH,EAAa,EAEjBrH,EAAO,QAAQ,QAAQ,CAAC,CAAE,IAAAf,EAAK,KAAA2D,EAAM,MAAAsD,KAAY,CAC/C,MAAMxE,EAASzC,EAAMA,EAAI,OAAS,KAElCoI,GAAc,KAAK,IACjBnB,IAAU,GAAKxE,EAAS,OAAO,QAAUwE,GACxCxE,GAAU,IAAM+I,EAAkB,EAAI7H,EAC/C,CACA,CAAK,EAED5C,EAAO,MAAQqH,CACnB,CAAG,CACH,CAEA,SAASqD,GAAiB1K,EAAQmE,EAAM,CACtC,MAAMyD,EAAU5H,EAAO,QACvBmE,EAAK,QAAU,GAEV5D,GAAUqH,CAAO,GAItBA,EAAQ,QAASzC,GAAU,CACzB,GAAI,CAAC5E,GAAU4E,EAAM,OAAO,GAAK,CAACA,EAAM,QAAQ,OAC9C,OAGF,KAAM,CAAE,QAAAH,EAAS,MAAApF,CAAO,EAAGuF,EAE3B,IAAI/D,EAAM,CACR,QAAA4D,EACA,MAAApF,CACN,EAEQuF,EAAM,MACR/D,EAAI,IAAM+D,EAAM,IAAI,KAGlBA,EAAM,IAAM,KACd/D,EAAI,SAAW+D,EAAM,KAGvBhB,EAAK,QAAQ,KAAK/C,CAAG,CACzB,CAAG,CACH,CAEA,SAASuJ,GAAe3K,EAAQmE,EAAM,CACpCA,EAAK,MAAQnE,EAAO,KACtB,CAEA,SAAS4K,GACPhC,EACAzF,EACA,CACE,eAAAwC,EAAiBjD,EAAO,eACxB,aAAAmI,EAAenI,EAAO,YAC1B,EAAM,CAAE,EACN,CACA,MAAMoI,EAAe,CAAA,EAErB,OAAInF,GAAgBmF,EAAa,KAAKJ,EAAgB,EAClDG,GAAcC,EAAa,KAAKH,EAAc,EAE3C/B,EAAQ,IAAK5I,GAAW,CAC7B,KAAM,CAAE,IAAAqD,CAAK,EAAGrD,EAEVmE,EAAO,CACX,KAAMhB,EAAKE,CAAG,EACd,SAAUA,CAChB,EAEI,OAAIyH,EAAa,QACfA,EAAa,QAASC,GAAgB,CACpCA,EAAY/K,EAAQmE,CAAI,CAChC,CAAO,EAGIA,CACX,CAAG,CACH,CAEA,MAAM6G,EAAK,CACT,YAAY7H,EAAMuF,EAAU,CAAA,EAAIxG,EAAO,CACrC,KAAK,QAAU,CAAE,GAAGQ,EAAQ,GAAGgG,CAAO,EAGpC,KAAK,QAAQ,kBAMf,KAAK,UAAY,IAAIzH,GAAS,KAAK,QAAQ,IAAI,EAE/C,KAAK,cAAckC,EAAMjB,CAAK,CAC/B,CAED,cAAciB,EAAMjB,EAAO,CAGzB,GAFA,KAAK,MAAQiB,EAETjB,GAAS,EAAEA,aAAiBe,IAC9B,MAAM,IAAI,MAAMxC,EAAoB,EAGtC,KAAK,SACHyB,GACA8B,GAAY,KAAK,QAAQ,KAAM,KAAK,MAAO,CACzC,MAAO,KAAK,QAAQ,MACpB,gBAAiB,KAAK,QAAQ,eACtC,CAAO,CACJ,CAED,IAAIV,EAAK,CACF/C,GAAU+C,CAAG,IAIlB,KAAK,MAAM,KAAKA,CAAG,EACnB,KAAK,SAAS,IAAIA,CAAG,EACtB,CAED,OAAO2H,EAAY,IAAoB,GAAO,CAC5C,MAAMrC,EAAU,CAAA,EAEhB,QAAS7J,EAAI,EAAGoD,EAAM,KAAK,MAAM,OAAQpD,EAAIoD,EAAKpD,GAAK,EAAG,CACxD,MAAMuE,EAAM,KAAK,MAAMvE,CAAC,EACpBkM,EAAU3H,EAAKvE,CAAC,IAClB,KAAK,SAASA,CAAC,EACfA,GAAK,EACLoD,GAAO,EAEPyG,EAAQ,KAAKtF,CAAG,EAEnB,CAED,OAAOsF,CACR,CAED,SAASvF,EAAK,CACZ,KAAK,MAAM,OAAOA,EAAK,CAAC,EACxB,KAAK,SAAS,SAASA,CAAG,CAC3B,CAED,UAAW,CACT,OAAO,KAAK,QACb,CAED,OAAOsF,EAAO,CAAE,MAAAuC,EAAQ,EAAE,EAAK,CAAA,EAAI,CACjC,KAAM,CACJ,eAAAvF,EACA,aAAAkF,EACA,WAAAM,EACA,OAAAC,EACA,gBAAAX,CACN,EAAQ,KAAK,QAET,IAAI7B,EAAU1I,GAASyI,CAAK,EACxBzI,GAAS,KAAK,MAAM,CAAC,CAAC,EACpB,KAAK,kBAAkByI,CAAK,EAC5B,KAAK,kBAAkBA,CAAK,EAC9B,KAAK,eAAeA,CAAK,EAE7B,OAAA6B,GAAa5B,EAAS,CAAE,gBAAA6B,CAAe,CAAE,EAErCU,GACFvC,EAAQ,KAAKwC,CAAM,EAGjBjL,GAAS+K,CAAK,GAAKA,EAAQ,KAC7BtC,EAAUA,EAAQ,MAAM,EAAGsC,CAAK,GAG3BN,GAAOhC,EAAS,KAAK,MAAO,CACjC,eAAAjD,EACA,aAAAkF,CACN,CAAK,CACF,CAED,kBAAkBlC,EAAO,CACvB,MAAMI,EAAWY,GAAehB,EAAO,KAAK,OAAO,EAC7C,CAAE,QAAAvF,CAAO,EAAK,KAAK,SACnBwF,EAAU,CAAA,EAGhB,OAAAxF,EAAQ,QAAQ,CAAC,CAAE,EAAGkC,EAAM,EAAGjC,EAAK,EAAGT,KAAW,CAChD,GAAI,CAACrC,GAAU+E,CAAI,EACjB,OAGF,KAAM,CAAE,QAAAkC,EAAS,MAAAtB,EAAO,QAAAlB,CAAS,EAAG+D,EAAS,SAASzD,CAAI,EAEtDkC,GACFoB,EAAQ,KAAK,CACX,KAAMtD,EACN,IAAAjC,EACA,QAAS,CAAC,CAAE,MAAA6C,EAAO,MAAOZ,EAAM,KAAA1C,EAAM,QAAAoC,EAAS,CACzD,CAAS,CAET,CAAK,EAEM4D,CACR,CAED,eAAeD,EAAO,CAEpB,MAAM0C,EAAalB,GAAMxB,EAAO,KAAK,OAAO,EAEtC2C,EAAW,CAACf,EAAM/G,EAAMH,IAAQ,CACpC,GAAI,CAACkH,EAAK,SAAU,CAClB,KAAM,CAAE,MAAAjJ,EAAO,SAAAyH,CAAU,EAAGwB,EAEtB3C,EAAU,KAAK,aAAa,CAChC,IAAK,KAAK,UAAU,IAAItG,CAAK,EAC7B,MAAO,KAAK,SAAS,uBAAuBkC,EAAMlC,CAAK,EACvD,SAAAyH,CACV,CAAS,EAED,OAAInB,GAAWA,EAAQ,OACd,CACL,CACE,IAAAvE,EACA,KAAAG,EACA,QAAAoE,CACD,CACF,EAGI,CAAE,CACV,CAED,MAAM2D,EAAM,CAAA,EACZ,QAASxM,EAAI,EAAGoD,EAAMoI,EAAK,SAAS,OAAQxL,EAAIoD,EAAKpD,GAAK,EAAG,CAC3D,MAAMyM,EAAQjB,EAAK,SAASxL,CAAC,EACvBiB,EAASsL,EAASE,EAAOhI,EAAMH,CAAG,EACxC,GAAIrD,EAAO,OACTuL,EAAI,KAAK,GAAGvL,CAAM,UACTuK,EAAK,WAAaV,GAAgB,IAC3C,MAAO,CAAE,CAEZ,CACD,OAAO0B,CACb,EAEUnI,EAAU,KAAK,SAAS,QACxBqI,EAAY,CAAA,EACZ7C,EAAU,CAAA,EAEhB,OAAAxF,EAAQ,QAAQ,CAAC,CAAE,EAAGI,EAAM,EAAGH,KAAU,CACvC,GAAI9C,GAAUiD,CAAI,EAAG,CACnB,IAAIkI,EAAaJ,EAASD,EAAY7H,EAAMH,CAAG,EAE3CqI,EAAW,SAERD,EAAUpI,CAAG,IAChBoI,EAAUpI,CAAG,EAAI,CAAE,IAAAA,EAAK,KAAAG,EAAM,QAAS,CAAA,GACvCoF,EAAQ,KAAK6C,EAAUpI,CAAG,CAAC,GAE7BqI,EAAW,QAAQ,CAAC,CAAE,QAAA9D,KAAc,CAClC6D,EAAUpI,CAAG,EAAE,QAAQ,KAAK,GAAGuE,CAAO,CAClD,CAAW,EAEJ,CACP,CAAK,EAEMgB,CACR,CAED,kBAAkBD,EAAO,CACvB,MAAMI,EAAWY,GAAehB,EAAO,KAAK,OAAO,EAC7C,CAAE,KAAAzH,EAAM,QAAAkC,GAAY,KAAK,SACzBwF,EAAU,CAAA,EAGhB,OAAAxF,EAAQ,QAAQ,CAAC,CAAE,EAAGI,EAAM,EAAGH,KAAU,CACvC,GAAI,CAAC9C,GAAUiD,CAAI,EACjB,OAGF,IAAIoE,EAAU,CAAA,EAGd1G,EAAK,QAAQ,CAACjC,EAAKyE,IAAa,CAC9BkE,EAAQ,KACN,GAAG,KAAK,aAAa,CACnB,IAAA3I,EACA,MAAOuE,EAAKE,CAAQ,EACpB,SAAAqF,CACZ,CAAW,CACX,CACA,CAAO,EAEGnB,EAAQ,QACVgB,EAAQ,KAAK,CACX,IAAAvF,EACA,KAAAG,EACA,QAAAoE,CACV,CAAS,CAET,CAAK,EAEMgB,CACR,CACD,aAAa,CAAE,IAAA3J,EAAK,MAAAW,EAAO,SAAAmJ,CAAQ,EAAI,CACrC,GAAI,CAACxI,GAAUX,CAAK,EAClB,MAAO,CAAE,EAGX,IAAIgI,EAAU,CAAA,EAEd,GAAIjI,GAAQC,CAAK,EACfA,EAAM,QAAQ,CAAC,CAAE,EAAG0F,EAAM,EAAGjC,EAAK,EAAGT,KAAW,CAC9C,GAAI,CAACrC,GAAU+E,CAAI,EACjB,OAGF,KAAM,CAAE,QAAAkC,EAAS,MAAAtB,EAAO,QAAAlB,CAAS,EAAG+D,EAAS,SAASzD,CAAI,EAEtDkC,GACFI,EAAQ,KAAK,CACX,MAAA1B,EACA,IAAAjH,EACA,MAAOqG,EACP,IAAAjC,EACA,KAAAT,EACA,QAAAoC,CACZ,CAAW,CAEX,CAAO,MACI,CACL,KAAM,CAAE,EAAGM,EAAM,EAAG1C,CAAI,EAAKhD,EAEvB,CAAE,QAAA4H,EAAS,MAAAtB,EAAO,QAAAlB,CAAS,EAAG+D,EAAS,SAASzD,CAAI,EAEtDkC,GACFI,EAAQ,KAAK,CAAE,MAAA1B,EAAO,IAAAjH,EAAK,MAAOqG,EAAM,KAAA1C,EAAM,QAAAoC,CAAO,CAAE,CAE1D,CAED,OAAO4C,CACR,CACH,CAEAoD,GAAK,QAAU,QACfA,GAAK,YAAchH,GACnBgH,GAAK,WAAa9G,GAClB8G,GAAK,OAAStI,EAGZsI,GAAK,WAAab,GAIlBV,GAASP,EAAc,EChvDzB,IAAIyC,GAAM,OAAO,UAAU,eAE3B,SAASC,GAAKC,EAAMC,EAAK7M,EAAK,CAC7B,IAAKA,KAAO4M,EAAK,OAChB,GAAIE,GAAO9M,EAAK6M,CAAG,EAAG,OAAO7M,CAE/B,CAEO,SAAS8M,GAAOC,EAAKC,EAAK,CAChC,IAAIC,EAAM/J,EAAKgK,EACf,GAAIH,IAAQC,EAAK,MAAO,GAExB,GAAID,GAAOC,IAAQC,EAAKF,EAAI,eAAiBC,EAAI,YAAa,CAC7D,GAAIC,IAAS,KAAM,OAAOF,EAAI,YAAcC,EAAI,UAChD,GAAIC,IAAS,OAAQ,OAAOF,EAAI,aAAeC,EAAI,WAEnD,GAAIC,IAAS,MAAO,CACnB,IAAK/J,EAAI6J,EAAI,UAAYC,EAAI,OAC5B,KAAO9J,KAAS4J,GAAOC,EAAI7J,CAAG,EAAG8J,EAAI9J,CAAG,CAAC,GAAE,CAE5C,OAAOA,IAAQ,EACf,CAED,GAAI+J,IAAS,IAAK,CACjB,GAAIF,EAAI,OAASC,EAAI,KACpB,MAAO,GAER,IAAK9J,KAAO6J,EAMX,GALAG,EAAMhK,EACFgK,GAAO,OAAOA,GAAQ,WACzBA,EAAMP,GAAKK,EAAKE,CAAG,EACf,CAACA,IAEF,CAACF,EAAI,IAAIE,CAAG,EAAG,MAAO,GAE3B,MAAO,EACP,CAED,GAAID,IAAS,IAAK,CACjB,GAAIF,EAAI,OAASC,EAAI,KACpB,MAAO,GAER,IAAK9J,KAAO6J,EAMX,GALAG,EAAMhK,EAAI,CAAC,EACPgK,GAAO,OAAOA,GAAQ,WACzBA,EAAMP,GAAKK,EAAKE,CAAG,EACf,CAACA,IAEF,CAACJ,GAAO5J,EAAI,CAAC,EAAG8J,EAAI,IAAIE,CAAG,CAAC,EAC/B,MAAO,GAGT,MAAO,EACP,CAED,GAAID,IAAS,YACZF,EAAM,IAAI,WAAWA,CAAG,EACxBC,EAAM,IAAI,WAAWA,CAAG,UACdC,IAAS,SAAU,CAC7B,IAAK/J,EAAI6J,EAAI,cAAgBC,EAAI,WAChC,KAAO9J,KAAS6J,EAAI,QAAQ7J,CAAG,IAAM8J,EAAI,QAAQ9J,CAAG,GAAE,CAEvD,OAAOA,IAAQ,EACf,CAED,GAAI,YAAY,OAAO6J,CAAG,EAAG,CAC5B,IAAK7J,EAAI6J,EAAI,cAAgBC,EAAI,WAChC,KAAO9J,KAAS6J,EAAI7J,CAAG,IAAM8J,EAAI9J,CAAG,GAAE,CAEvC,OAAOA,IAAQ,EACf,CAED,GAAI,CAAC+J,GAAQ,OAAOF,GAAQ,SAAU,CACrC7J,EAAM,EACN,IAAK+J,KAAQF,EAEZ,GADIL,GAAI,KAAKK,EAAKE,CAAI,GAAK,EAAE/J,GAAO,CAACwJ,GAAI,KAAKM,EAAKC,CAAI,GACnD,EAAEA,KAAQD,IAAQ,CAACF,GAAOC,EAAIE,CAAI,EAAGD,EAAIC,CAAI,CAAC,EAAG,MAAO,GAE7D,OAAO,OAAO,KAAKD,CAAG,EAAE,SAAW9J,CACnC,CACD,CAED,OAAO6J,IAAQA,GAAOC,IAAQA,CAC/B,CCzEO,SAASG,GAAKC,EAAOnK,EAAOoK,EAAWC,EAAO,GAAM,CACvD,MAAMC,EAAgBtK,EAAQoK,EAC9B,OAAIE,GAAiB,EACVD,EAAOF,EAAMA,EAAM,OAAS,CAAC,EAAIA,EAAM,CAAC,EAE5CA,EAAMG,CAAa,CAC9B,CAUO,SAASC,GAAQJ,EAAOnK,EAAOoK,EAAWC,EAAO,GAAM,CAC1D,MAAMG,EAAYxK,EAAQoK,EAC1B,OAAII,EAAYL,EAAM,OAAS,EACpBE,EAAOF,EAAM,CAAC,EAAIA,EAAMA,EAAM,OAAS,CAAC,EAE5CA,EAAMK,CAAS,CAC1B,CAOO,SAASrC,GAAKgC,EAAOnK,EAAOqK,EAAO,GAAM,CAC5C,OAAIrK,IAAUmK,EAAM,OAAS,EAClBE,EAAOF,EAAM,CAAC,EAAIA,EAAMnK,CAAK,EAEjCmK,EAAMnK,EAAQ,CAAC,CAC1B,CAOO,SAASyK,GAAKN,EAAOO,EAAcL,EAAO,GAAM,CACnD,OAAIK,GAAgB,EACTL,EAAOF,EAAMA,EAAM,OAAS,CAAC,EAAIA,EAAM,CAAC,EAE5CA,EAAMO,EAAe,CAAC,CACjC,CAKO,SAASC,GAAKR,EAAO,CACxB,OAAOA,EAAMA,EAAM,OAAS,CAAC,CACjC,CC/DO,SAASS,GAAUlN,EAAO,CAC7B,SAASmN,EAAUC,EAAK,CACpB,OAAAA,EAAIpN,CAAK,EACF,IAAM,CAErB,CACK,CACD,MAAO,CAAE,UAAAmN,CAAS,CACtB,CCCO,MAAME,GAAgB7L,GAClB,IAAI,MAAMA,EAAK,CAClB,IAAI8L,EAAQC,EAAMC,EAAU,CACxB,OAAO,QAAQ,IAAIF,EAAQC,EAAMC,CAAQ,CAC5C,EACD,QAAQF,EAAQ,CACZ,OAAO,QAAQ,QAAQA,CAAM,EAAE,OAAQjO,GAAQA,IAAQ,QAAQ,CAClE,CACT,CAAK,EAECoO,GAAwBC,GACnB,OAAOA,GAAO,WAElB,SAASC,GAAQzM,EAAM4I,EAAM,CAChC,KAAM,CAAE,OAAA8D,EAAQ,OAAAC,EAAQ,SAAAC,CAAQ,EAAKhE,GAAQ,CAAA,EACvCiE,GAAgB,IAAM,CACxB,GAAIH,GAAUE,EAEV,OAAOE,GAAQJ,EAASK,GAAW,CAC/B,MAAM7N,EAAS0N,EAASG,CAAM,EAC9B,GAAIR,GAAqBrN,CAAM,EAAG,CAC9B,MAAMsN,EAAK,IAAI5D,IACJuD,GAAa,CAChB,GAAGjN,EAAO,GAAG0J,CAAI,EACjB,CAAC,aAAa5I,CAAI,EAAE,EAAG,GACvB,OAAQ2M,GAAUK,EAC9C,CAAyB,EAEL,OAAAR,EAAG,OAASG,GAAUK,GACfR,CACV,CACD,OAAOL,GAAa,CAChB,GAAGjN,EACH,CAAC,aAAac,CAAI,EAAE,EAAG,GACvB,OAAQ2M,GAAUK,EACtC,CAAiB,CACjB,CAAa,EAEA,CAED,MAAMC,EAAaL,EACb1N,EAAS+N,GAAA,YAAAA,IACf,GAAIV,GAAqBrN,CAAM,EAAG,CAC9B,MAAMgO,EAAW,IAAItE,IACVuD,GAAa,CAChB,GAAGjN,EAAO,GAAG0J,CAAI,EACjB,CAAC,aAAa5I,CAAI,EAAE,EAAG,GACvB,OAAQ2M,GAAUK,EAC1C,CAAqB,EAEL,OAAAE,EAAS,OAASP,GAAUK,GACrBhB,GAAUkB,CAAQ,CAC5B,CACD,OAAOlB,GAAUG,GAAa,CAC1B,GAAGjN,EACH,CAAC,aAAac,CAAI,EAAE,EAAG,GACvB,OAAQ2M,GAAUK,EACrB,CAAA,CAAC,CACL,CACT,KACUG,EAAYR,IACb,IAAM,CAEN,GACL,OAAAQ,EAAS,UAAYN,EAAa,UAC3BM,CACX,CACO,SAASC,GAAgBC,EAAQ,CACpC,MAAMrN,EAAQsN,GAAUA,EAAO,GAAGD,CAAM,IAAIC,CAAI,GAAKD,EAC/CE,EAAaD,GAAS,aAAaD,CAAM,GAAGC,EAAO,IAAIA,CAAI,GAAK,EAAE,GAClEE,EAAYF,GAAS,cAAcD,CAAM,GAAGC,EAAO,IAAIA,CAAI,GAAK,EAAE,IAExE,MAAO,CACH,KAAAtN,EACA,UAAAuN,EACA,SAAAC,EACA,MALWF,GAAS,SAAS,cAAcE,EAASF,CAAI,CAAC,CAMjE,CACA,CCvFO,MAAMG,GAAY,OAAO,SAAa,IAEhCC,GAAcC,GAAM,OAAOA,GAAM,WAIvC,SAASC,GAAcC,EAAS,CACnC,OAAOA,aAAmB,WAC9B,CACO,SAASC,GAAmBD,EAAS,CACxC,OAAOA,aAAmB,gBAC9B,CACO,SAASE,GAAkBF,EAAS,CACvC,MAAMG,EAAeH,EAAQ,aAAa,eAAe,EACnDI,EAAWJ,EAAQ,aAAa,UAAU,EAC1CK,EAAeL,EAAQ,aAAa,eAAe,EACzD,MAAI,GAAAG,IAAiB,QAAUC,IAAa,MAAQC,EAIxD,CCdO,SAASC,MAAoBC,EAAW,CAC3C,MAAO,IAAIxF,IAAS,CAChB,UAAWyF,KAAYD,EACf,OAAOC,GAAa,YACpBA,EAAS,GAAGzF,CAAI,CAGhC,CACA,CAIO,SAASoE,IAAO,CAEvB,CCVO,SAASsB,GAAiBlC,EAAQmC,EAAOC,EAAS5G,EAAS,CAC9D,MAAM6G,EAAS,MAAM,QAAQF,CAAK,EAAIA,EAAQ,CAACA,CAAK,EAEpD,OAAAE,EAAO,QAASC,GAAWtC,EAAO,iBAAiBsC,EAAQF,EAAS5G,CAAO,CAAC,EAErE,IAAM,CACT6G,EAAO,QAASC,GAAWtC,EAAO,oBAAoBsC,EAAQF,EAAS5G,CAAO,CAAC,CACvF,CACA,CACO,SAAS+G,GAAqBvC,EAAQmC,EAAOC,EAAS5G,EAAS,CAClE,MAAM6G,EAAS,MAAM,QAAQF,CAAK,EAAIA,EAAQ,CAACA,CAAK,EACpD,GAAI,OAAOC,GAAY,WAAY,CAC/B,MAAMI,EAAkBC,GAAUH,GAAWF,EAAQE,CAAM,CAAC,EAE5D,OAAAD,EAAO,QAASC,GAAWtC,EAAO,iBAAiBsC,EAAQE,EAAiBhH,CAAO,CAAC,EAE7E,IAAM,CACT6G,EAAO,QAASC,GAAWtC,EAAO,oBAAoBsC,EAAQE,EAAiBhH,CAAO,CAAC,CACnG,CACK,CACD,MAAO,IAAM,MACjB,CACO,SAASkH,GAAkBC,EAAe,CAC7C,MAAMtF,EAAOsF,EAAc,cAC3B,GAAI,CAACnB,GAAcnE,CAAI,EACnB,OAAO,KACX,MAAMuF,EAAkB,IAAI,YAAY,KAAKD,EAAc,IAAI,GAAI,CAC/D,OAAQ,CACJ,cAAAA,CACH,EACD,WAAY,EACpB,CAAK,EACD,OAAAtF,EAAK,cAAcuF,CAAe,EAC3BA,CACX,CACO,SAASH,GAASL,EAAS,CAC9B,OAAQD,GAAU,CACd,MAAMU,EAAcH,GAAkBP,CAAK,EAC3C,GAAI,EAAAU,GAAA,MAAAA,EAAa,kBAEjB,OAAOT,EAAQD,CAAK,CAC5B,CACA,CCpDO,SAASW,GAAarB,EAAS,CAClCA,EAAQ,aAAa,mBAAoB,EAAE,CAC/C,CACO,SAASsB,GAAgBtB,EAAS,CACrCA,EAAQ,gBAAgB,kBAAkB,CAC9C,CCHO,SAASuB,GAAWC,EAAI,CAC3B,OAAO,MAAM,KAAKA,EAAG,iBAAiB,sCAAsC,CAAC,EAAE,OAAQA,GAAOzB,GAAcyB,CAAE,CAAC,CACnH,CCJO,SAASC,GAAKhP,KAAQF,EAAM,CAC/B,MAAMlB,EAAS,CAAA,EACf,UAAWf,KAAO,OAAO,KAAKmC,CAAG,EACxBF,EAAK,SAASjC,CAAG,IAClBe,EAAOf,CAAG,EAAImC,EAAInC,CAAG,GAG7B,OAAOe,CACX,CCRO,MAAMqQ,GAAc,CAACC,EAAOC,IAAa,CAC5C,MAAM3R,EAAS,CAAC4R,EAASC,IAAe,CACpCH,EAAM,OAAQI,GAAS,CACnB,MAAMrG,EAAOmG,EAAQE,CAAI,EACzB,IAAInF,EAAMlB,EACV,OAAIkG,IACAhF,EAAMgF,EAAS,CAAE,KAAAG,EAAM,KAAArG,CAAM,CAAA,GAEjCoG,GAAA,MAAAA,EAAalF,GACNA,CACnB,CAAS,CACT,EAII,MAAO,CACH,GAAG+E,EACH,OAAA1R,EACA,IANS8R,GAAS,CAClB9R,EAAO,IAAM8R,CAAI,CACzB,CAKA,CACA,ECpBO,SAASC,GAAMC,EAAI,CACtB,OAAO,IAAI,QAASnR,GAAY,WAAWA,EAASmR,CAAE,CAAC,CAC3D,CCIO,SAASC,GAAcC,EAAO,CACjC,OAAO,OAAO,KAAKA,CAAK,EAAE,OAAO,CAACC,EAAK9R,IAC/B6R,EAAM7R,CAAG,IAAM,OACR8R,EACJA,EAAM,GAAG9R,CAAG,IAAI6R,EAAM7R,CAAG,CAAC,IAClC,EAAE,CACT,CCZA,IAAI+R,GACF,mEAWSC,GAAS,CAACC,EAAO,KAAO,CACjC,IAAI1P,EAAK,GACLzC,EAAImS,EACR,KAAOnS,KACLyC,GAAMwP,GAAa,KAAK,OAAQ,EAAG,GAAM,CAAC,EAE5C,OAAOxP,CACT,ECdO,SAAS2P,IAAa,CACzB,OAAOF,GAAO,EAAE,CACpB,CCFO,MAAMG,EAAM,CACf,IAAK,MACL,WAAY,YACZ,WAAY,YACZ,YAAa,aACb,SAAU,UACV,UAAW,YACX,UAAW,WACX,QAAS,UACT,OAAQ,SACR,IAAK,MACL,MAAO,QACP,OAAQ,SACR,GAAI,KACJ,IAAK,MACL,IAAK,MACL,IAAK,MACL,GAAI,KACJ,GAAI,KACJ,GAAI,KACJ,GAAI,KACJ,GAAI,KACJ,GAAI,KACJ,GAAI,KACJ,GAAI,KACJ,KAAM,OACN,KAAM,OACN,UAAW,WACX,QAAS,SACT,MAAO,QACP,MAAO,IACP,IAAK,MACL,KAAM,SACV,EAEaC,GAAa,CAACD,EAAI,WAAYA,EAAI,QAASA,EAAI,IAAI,EACnDE,GAAY,CAACF,EAAI,SAAUA,EAAI,UAAWA,EAAI,GAAG,EACjDG,GAAkB,CAAC,GAAGF,GAAY,GAAGC,EAAS,EC1C9CE,GAAQ,IAAM,OAAO,OAAW,IACtC,SAASC,IAAc,CAE1B,MAAMC,EAAQ,UAAU,cACxB,OAAOA,GAAA,YAAAA,EAAO,WAAY,UAAU,QACxC,CACA,MAAMC,GAAMlD,GAAM+C,GAAK,GAAM/C,EAAE,KAAKgD,GAAW,CAAE,EAGpCG,GAAgB,IAAMJ,GAAK,GAAM,CAAC,CAAC,UAAU,eAC7CK,GAAQ,IAAMF,GAAG,MAAM,GAAK,CAACC,GAAa,EAI1CE,GAAU,IAAMH,GAAG,uBAAuB,EAC1CI,GAAQ,IAAMD,MAAa,CAACD,GAAO,ECV1CG,GAAiB,wBACvB,SAASC,GAAY9B,EAAIW,EAAO,CAC5B,GAAI,CAACX,EACD,OACJ,MAAM+B,EAAgB/B,EAAG,MAAM,QAC/B,cAAO,OAAOA,EAAG,MAAOW,CAAK,EACtB,IAAM,CACTX,EAAG,MAAM,QAAU+B,CAC3B,CACA,CACA,SAASC,GAAehC,EAAIiC,EAAUxS,EAAO,CACzC,GAAI,CAACuQ,EACD,OACJ,MAAMkC,EAAgBlC,EAAG,MAAM,iBAAiBiC,CAAQ,EACxD,OAAAjC,EAAG,MAAM,YAAYiC,EAAUxS,CAAK,EAC7B,IAAM,CACLyS,EACAlC,EAAG,MAAM,YAAYiC,EAAUC,CAAa,EAG5ClC,EAAG,MAAM,eAAeiC,CAAQ,CAE5C,CACA,CACA,SAASE,GAAmBC,EAAiB,CAEzC,MAAMC,EAAeD,EAAgB,sBAAqB,EAAG,KAE7D,OADmB,KAAK,MAAMC,CAAY,EAAID,EAAgB,WAC1C,cAAgB,cACxC,CACO,SAASE,GAAaC,EAAW,CACpC,MAAMpP,EAAMoP,GAAa,SACnBC,EAAMrP,EAAI,aAAe,OACzB,CAAE,gBAAAiP,EAAiB,KAAAK,CAAM,EAAGtP,EAElC,GADesP,EAAK,aAAaZ,EAAc,EAE3C,OAAOlE,GACX8E,EAAK,aAAaZ,GAAgB,EAAE,EACpC,MAAMa,EAAiBF,EAAI,WAAaJ,EAAgB,YAClDO,EAA4B,IAAMX,GAAeI,EAAiB,oBAAqB,GAAGM,CAAc,IAAI,EAC5GE,EAAkBT,GAAmBC,CAAe,EACpDS,EAAuBL,EAAI,iBAAiBC,CAAI,EAAEG,CAAe,EACjEE,EAAW,IAAMhB,GAAYW,EAAM,CACrC,SAAU,SACV,CAACG,CAAe,EAAG,QAAQC,CAAoB,MAAMH,CAAc,KAC3E,CAAK,EAEKK,EAAc,IAAM,CACtB,KAAM,CAAE,QAAAC,EAAS,QAAAC,EAAS,eAAAC,CAAc,EAAKV,EAEvCW,GAAaD,GAAA,YAAAA,EAAgB,aAAc,EAC3CE,GAAYF,GAAA,YAAAA,EAAgB,YAAa,EACzCG,EAAevB,GAAYW,EAAM,CACnC,SAAU,QACV,SAAU,SACV,IAAK,GAAG,EAAEQ,EAAU,KAAK,MAAMG,CAAS,EAAE,KAC1C,KAAM,GAAG,EAAEJ,EAAU,KAAK,MAAMG,CAAU,EAAE,KAC5C,MAAO,IACP,CAACP,CAAe,EAAG,QAAQC,CAAoB,MAAMH,CAAc,KAC/E,CAAS,EACD,MAAO,IAAM,CACTW,GAAA,MAAAA,IACAb,EAAI,SAASQ,EAASC,CAAO,CACzC,CACA,EACUK,EAAW,CAACX,IAA6Bf,GAAO,EAAGmB,EAAa,EAAGD,EAAQ,CAAE,EACnF,MAAO,IAAM,CACTQ,EAAS,QAASnG,GAAOA,GAAA,YAAAA,GAAM,EAC/BsF,EAAK,gBAAgBZ,EAAc,CAC3C,CACA,CCtEO,SAAS0B,GAAetS,EAAK,CAChC,KAAM,CAAE,KAAAuS,EAAM,aAAAC,EAAc,cAAAC,CAAa,EAAKzS,EAC9C,OAAOwM,GAAQ,CAAC+F,EAAMC,EAAcC,CAAa,EAAG,CAAC,CAACC,EAAOC,EAAeC,CAAc,KAAOF,GAASC,IAAkBC,IAAmB,IAAI,CACvJ,CCIO,SAASC,GAAuBzG,EAAQF,EAAI,CAC/C,IAAI4G,EAAgB,CAAA,EACpB,MAAMC,EAAiBC,GAAO,CAC1BF,EAAc,KAAKE,CAAE,CAC7B,EACUC,EAAc,IAAM,CAGtBH,EAAc,QAAS5G,GAAOA,EAAI,CAAA,EAElC4G,EAAgB,CAAA,CACxB,EACUvG,EAAeC,GAAQJ,EAAS8G,IAClCD,IACO/G,EAAGgH,EAAcH,CAAa,EACxC,EACD,OAAAI,GAAUF,CAAW,EAQd,CACH,GAAG1G,EACH,UATc,IAAIjE,IAAS,CAC3B,MAAM8K,EAAQ7G,EAAa,UAAU,GAAGjE,CAAI,EAC5C,MAAO,IAAM,CACT8K,IACAH,GACZ,CACA,CAIA,CACA,CC7BO,SAASI,GAAOjH,EAAQF,EAAI,CAE/B,MAAMkH,EAAQP,GAAuBzG,EAAQ,CAACA,EAAQ2G,KAC3C,CACH,OAAA3G,EACA,cAAA2G,CACZ,EACK,EAAE,UAAU,CAAC,CAAE,OAAA3G,EAAQ,cAAA2G,CAAa,IAAO,CACxC,MAAMzG,EAAWJ,EAAGE,CAAM,EAEtBE,GACAyG,EAAczG,CAAQ,CAElC,CAAK,EAED,OAAA6G,GAAUC,CAAK,EACRA,CACX,CC3BO,SAASE,GAAaC,EAAcC,EAAO,EAAG,CACjD,MAAMtE,EAAQuE,GAAS,CAAE,MAAOF,EAAc,UAAWA,CAAY,CAAE,EACvE,IAAIG,EACJ,SAASC,EAAanV,EAAO,CACzB0Q,EAAM,OAAQ0E,IACVA,EAAM,MAAQpV,EACPoV,EACV,EACGF,GACA,aAAaA,CAAO,EAExBA,EAAU,WAAW,IAAM,CACvBxE,EAAM,OAAQ0E,IACVA,EAAM,UAAYA,EAAM,MACjBA,EACV,CACJ,EAAEJ,CAAI,CACV,CACD,SAASK,EAAgB3H,EAAI,CACzBgD,EAAM,OAAQ0E,IACVA,EAAM,MAAQ1H,EAAG0H,EAAM,KAAK,EACrBA,EACV,EACGF,GACA,aAAaA,CAAO,EAExBA,EAAU,WAAW,IAAM,CACvBxE,EAAM,OAAQ0E,IACVA,EAAM,UAAYA,EAAM,MACjBA,EACV,CACJ,EAAEJ,CAAI,CACV,CACD,SAASM,EAAItV,EAAO,CAChB0Q,EAAM,OAAQ0E,IACVA,EAAM,MAAQpV,EACdoV,EAAM,UAAYpV,EACXoV,EACV,CACJ,CACD,SAASpW,EAAO0O,EAAI,CAChBgD,EAAM,OAAQ0E,IACVA,EAAM,MAAQ1H,EAAG0H,EAAM,KAAK,EAC5BA,EAAM,UAAYA,EAAM,MACjBA,EACV,CACJ,CACD,MAAO,CACH,GAAG1E,EACH,aAAAyE,EACA,gBAAAE,EACA,IAAAC,EACA,OAAAtW,CACR,CACA,CClDO,SAASuW,GAAiBC,EAAY,CACzC,MAAMpV,EAAS,CAAA,EACf,cAAO,KAAKoV,CAAU,EAAE,QAASnW,GAAQ,CACrC,MAAMoW,EAAcpW,EACdW,EAAQwV,EAAWC,CAAW,EACpCrV,EAAOqV,CAAW,EAAIR,GAASjV,CAAK,CAC5C,CAAK,EACMI,CACX,CCRA,SAASsV,GAAgB/K,EAAM,CAC3B,IAAIgL,EAAShL,EAAK,cAClB,KAAOmE,GAAc6G,CAAM,GAAK,CAACA,EAAO,aAAa,aAAa,GAC9DA,EAASA,EAAO,cAEpB,OAAOA,GAAU,MACrB,CACO,SAASC,GAAqBjL,EAAMkL,EAAY,CACnD,MAAMC,EAAeJ,GAAgB/K,CAAI,EACzC,OAAIkL,IAAe,OACRA,EACPC,IAAiB,OACV,SAAS,KACb,IACX,CCPA,MAAMC,GAAqBC,GAAS,OAAYV,GAAQ,CAKpD,SAASW,EAAQxG,EAAO,CACpB6F,EAAI7F,CAAK,EAET6F,EAAI,MAAS,CAChB,CAOD,OALoB9F,GAAiB,SAAU,cAAeyG,EAAS,CACnE,QAAS,GACT,QAAS,EACjB,CAAK,CAGL,CAAC,EACYC,GAAkB,CAACvL,EAAMwL,EAAS,KAAO,CAClD,IAAIrN,EAAU,CAAE,QAAS,GAAM,GAAGqN,CAAM,EAExC,SAASC,GAAY,CACjB,OAAO,OAAOtN,EAAQ,SAAY,UAAYA,EAAQ,QAAU5G,GAAI4G,EAAQ,OAAO,CACtF,CAED,MAAM2L,EAAcsB,GAAmB,UAAWM,GAAM,OAEpD,GAAI,CAACD,EAAS,GAAM,CAACC,GAAKA,EAAE,SAAW1L,EACnC,OAEJ,MAAM2L,EAAeD,EAAE,eAEvB,GAAI,CAAAC,EAAa,SAAS3L,CAAI,EAG9B,IAAI7B,EAAQ,QACR,GAAI8F,GAAW9F,EAAQ,MAAM,GACzB,GAAIA,EAAQ,OAAOuN,CAAC,EAChB,eAGC,MAAM,QAAQvN,EAAQ,MAAM,GAC7BA,EAAQ,OAAO,OAAS,GACxBA,EAAQ,OAAO,KAAMyN,GACVA,IAAaF,EAAE,SAAWE,GAAYD,EAAa,SAASC,CAAQ,EAC9E,EACD,QAIZC,EAAA1N,EAAQ,UAAR,MAAA0N,EAAA,KAAA1N,EAAkBuN,GAC1B,CAAK,EACD,MAAO,CACH,OAAOI,EAAQ,CACX3N,EAAU,CAAE,GAAGA,EAAS,GAAG2N,CAAM,CACpC,EACD,SAAU,CACNhC,GACH,CACT,CACA,EC9DMiC,GAAyBV,GAAS,OAAYV,GAAQ,CAKxD,SAASqB,EAAQlH,EAAO,CAChBA,GAASA,EAAM,MAAQ+B,EAAI,QAC3B8D,EAAI7F,CAAK,EAGb6F,EAAI,MAAS,CAChB,CAOD,OALoB9F,GAAiB,SAAU,UAAWmH,EAAS,CAC/D,QAAS,GACT,QAAS,EACjB,CAAK,CAGL,CAAC,EACYC,GAAmB,CAACjM,EAAMwL,EAAS,KAAO,CACnDxL,EAAK,QAAQ,QAAU,GACvB,IAAI7B,EAAU,CAAE,QAAS,GAAM,GAAGqN,CAAM,EAExC,SAASC,GAAY,CACjB,OAAO,OAAOtN,EAAQ,SAAY,UAAYA,EAAQ,QAAU5G,GAAI4G,EAAQ,OAAO,CACtF,CAED,MAAM2L,EAAciC,GAAuB,UAAWL,GAAM,OACxD,GAAI,CAACA,GAAK,CAACD,EAAW,EAClB,OACJ,MAAM9I,EAAS+I,EAAE,OACjB,GAAI,GAACvH,GAAcxB,CAAM,GAAKA,EAAO,QAAQ,gBAAgB,IAAM3C,GAInE,IAAI7B,EAAQ,QACR,GAAI8F,GAAW9F,EAAQ,MAAM,GACzB,GAAIA,EAAQ,OAAOuN,CAAC,EAChB,eAGC,MAAM,QAAQvN,EAAQ,MAAM,GAC7BA,EAAQ,OAAO,OAAS,GACxBA,EAAQ,OAAO,KAAMyN,GACVA,GAAYjJ,IAAWiJ,CACjC,EACD,QAIZC,EAAA1N,EAAQ,UAAR,MAAA0N,EAAA,KAAA1N,EAAkBuN,GAC1B,CAAK,EACD,MAAO,CACH,OAAOI,EAAQ,CACX3N,EAAU,CAAE,GAAGA,EAAS,GAAG2N,CAAM,CACpC,EACD,SAAU,CACN9L,EAAK,gBAAgB,cAAc,EACnC8J,GACH,CACT,CACA,ECrEMoC,GAAM,KAAK,IACX7V,GAAM,KAAK,IACX8V,GAAQ,KAAK,MACbC,GAAQ,KAAK,MACbC,GAAenI,IAAM,CACzB,EAAGA,EACH,EAAGA,CACL,GACMoI,GAAkB,CACtB,KAAM,QACN,MAAO,OACP,OAAQ,MACR,IAAK,QACP,EACMC,GAAuB,CAC3B,MAAO,MACP,IAAK,OACP,EACA,SAASC,GAAM9R,EAAOrF,EAAOsF,EAAK,CAChC,OAAOtE,GAAIqE,EAAOwR,GAAI7W,EAAOsF,CAAG,CAAC,CACnC,CACA,SAASoG,GAAS1L,EAAOoX,EAAO,CAC9B,OAAO,OAAOpX,GAAU,WAAaA,EAAMoX,CAAK,EAAIpX,CACtD,CACA,SAASqX,GAAQC,EAAW,CAC1B,OAAOA,EAAU,MAAM,GAAG,EAAE,CAAC,CAC/B,CACA,SAASC,GAAaD,EAAW,CAC/B,OAAOA,EAAU,MAAM,GAAG,EAAE,CAAC,CAC/B,CACA,SAASE,GAAgBC,EAAM,CAC7B,OAAOA,IAAS,IAAM,IAAM,GAC9B,CACA,SAASC,GAAcD,EAAM,CAC3B,OAAOA,IAAS,IAAM,SAAW,OACnC,CACA,SAASE,GAAYL,EAAW,CAC9B,MAAO,CAAC,MAAO,QAAQ,EAAE,SAASD,GAAQC,CAAS,CAAC,EAAI,IAAM,GAChE,CACA,SAASM,GAAiBN,EAAW,CACnC,OAAOE,GAAgBG,GAAYL,CAAS,CAAC,CAC/C,CACA,SAASO,GAAkBP,EAAWQ,EAAOC,EAAK,CAC5CA,IAAQ,SACVA,EAAM,IAER,MAAMC,EAAYT,GAAaD,CAAS,EAClCW,EAAgBL,GAAiBN,CAAS,EAC1CY,EAASR,GAAcO,CAAa,EAC1C,IAAIE,EAAoBF,IAAkB,IAAMD,KAAeD,EAAM,MAAQ,SAAW,QAAU,OAASC,IAAc,QAAU,SAAW,MAC9I,OAAIF,EAAM,UAAUI,CAAM,EAAIJ,EAAM,SAASI,CAAM,IACjDC,EAAoBC,GAAqBD,CAAiB,GAErD,CAACA,EAAmBC,GAAqBD,CAAiB,CAAC,CACpE,CACA,SAASE,GAAsBf,EAAW,CACxC,MAAMgB,EAAoBF,GAAqBd,CAAS,EACxD,MAAO,CAACiB,GAA8BjB,CAAS,EAAGgB,EAAmBC,GAA8BD,CAAiB,CAAC,CACvH,CACA,SAASC,GAA8BjB,EAAW,CAChD,OAAOA,EAAU,QAAQ,aAAcU,GAAad,GAAqBc,CAAS,CAAC,CACrF,CACA,SAASQ,GAAYC,EAAMC,EAASX,EAAK,CACvC,MAAMY,EAAK,CAAC,OAAQ,OAAO,EACrBC,EAAK,CAAC,QAAS,MAAM,EACrBC,EAAK,CAAC,MAAO,QAAQ,EACrBC,EAAK,CAAC,SAAU,KAAK,EAC3B,OAAQL,EAAI,CACV,IAAK,MACL,IAAK,SACH,OAAIV,EAAYW,EAAUE,EAAKD,EACxBD,EAAUC,EAAKC,EACxB,IAAK,OACL,IAAK,QACH,OAAOF,EAAUG,EAAKC,EACxB,QACE,MAAO,EACV,CACH,CACA,SAASC,GAA0BzB,EAAW0B,EAAeC,EAAWlB,EAAK,CAC3E,MAAMC,EAAYT,GAAaD,CAAS,EACxC,IAAInV,EAAOqW,GAAYnB,GAAQC,CAAS,EAAG2B,IAAc,QAASlB,CAAG,EACrE,OAAIC,IACF7V,EAAOA,EAAK,IAAIsW,GAAQA,EAAO,IAAMT,CAAS,EAC1CgB,IACF7W,EAAOA,EAAK,OAAOA,EAAK,IAAIoW,EAA6B,CAAC,IAGvDpW,CACT,CACA,SAASiW,GAAqBd,EAAW,CACvC,OAAOA,EAAU,QAAQ,yBAA0BmB,GAAQxB,GAAgBwB,CAAI,CAAC,CAClF,CACA,SAASS,GAAoBC,EAAS,CACpC,MAAO,CACL,IAAK,EACL,MAAO,EACP,OAAQ,EACR,KAAM,EACN,GAAGA,CACP,CACA,CACA,SAASC,GAAiBD,EAAS,CACjC,OAAO,OAAOA,GAAY,SAAWD,GAAoBC,CAAO,EAAI,CAClE,IAAKA,EACL,MAAOA,EACP,OAAQA,EACR,KAAMA,CACV,CACA,CACA,SAASE,GAAiBC,EAAM,CAC9B,MAAO,CACL,GAAGA,EACH,IAAKA,EAAK,EACV,KAAMA,EAAK,EACX,MAAOA,EAAK,EAAIA,EAAK,MACrB,OAAQA,EAAK,EAAIA,EAAK,MAC1B,CACA,CCtHA,SAASC,GAA2BC,EAAMlC,EAAWS,EAAK,CACxD,GAAI,CACF,UAAA0B,EACA,SAAAC,CACD,EAAGF,EACJ,MAAMG,EAAWhC,GAAYL,CAAS,EAChCW,EAAgBL,GAAiBN,CAAS,EAC1CsC,EAAclC,GAAcO,CAAa,EACzCQ,EAAOpB,GAAQC,CAAS,EACxBuC,EAAaF,IAAa,IAC1BG,EAAUL,EAAU,EAAIA,EAAU,MAAQ,EAAIC,EAAS,MAAQ,EAC/DK,EAAUN,EAAU,EAAIA,EAAU,OAAS,EAAIC,EAAS,OAAS,EACjEM,EAAcP,EAAUG,CAAW,EAAI,EAAIF,EAASE,CAAW,EAAI,EACzE,IAAIK,EACJ,OAAQxB,EAAI,CACV,IAAK,MACHwB,EAAS,CACP,EAAGH,EACH,EAAGL,EAAU,EAAIC,EAAS,MAClC,EACM,MACF,IAAK,SACHO,EAAS,CACP,EAAGH,EACH,EAAGL,EAAU,EAAIA,EAAU,MACnC,EACM,MACF,IAAK,QACHQ,EAAS,CACP,EAAGR,EAAU,EAAIA,EAAU,MAC3B,EAAGM,CACX,EACM,MACF,IAAK,OACHE,EAAS,CACP,EAAGR,EAAU,EAAIC,EAAS,MAC1B,EAAGK,CACX,EACM,MACF,QACEE,EAAS,CACP,EAAGR,EAAU,EACb,EAAGA,EAAU,CACrB,CACG,CACD,OAAQlC,GAAaD,CAAS,EAAC,CAC7B,IAAK,QACH2C,EAAOhC,CAAa,GAAK+B,GAAejC,GAAO8B,EAAa,GAAK,GACjE,MACF,IAAK,MACHI,EAAOhC,CAAa,GAAK+B,GAAejC,GAAO8B,EAAa,GAAK,GACjE,KACH,CACD,OAAOI,CACT,CASA,MAAMC,GAAkB,MAAOT,EAAWC,EAAUvD,IAAW,CAC7D,KAAM,CACJ,UAAAmB,EAAY,SACZ,SAAA6C,EAAW,WACX,WAAAC,EAAa,CAAE,EACf,SAAAC,CACD,EAAGlE,EACEmE,EAAkBF,EAAW,OAAO,OAAO,EAC3CrC,EAAM,MAAOsC,EAAS,OAAS,KAAO,OAASA,EAAS,MAAMX,CAAQ,GAC5E,IAAI5B,EAAQ,MAAMuC,EAAS,gBAAgB,CACzC,UAAAZ,EACA,SAAAC,EACA,SAAAS,CACJ,CAAG,EACG,CACF,EAAAI,EACA,EAAAC,CACD,EAAGjB,GAA2BzB,EAAOR,EAAWS,CAAG,EAChD0C,EAAoBnD,EACpBoD,EAAiB,CAAA,EACjBC,EAAa,EACjB,QAASxb,EAAI,EAAGA,EAAImb,EAAgB,OAAQnb,IAAK,CAC/C,KAAM,CACJ,KAAA+B,EACA,GAAAwM,CACN,EAAQ4M,EAAgBnb,CAAC,EACf,CACJ,EAAGyb,EACH,EAAGC,EACH,KAAAtW,EACA,MAAAuW,CACD,EAAG,MAAMpN,EAAG,CACX,EAAA6M,EACA,EAAAC,EACA,iBAAkBlD,EAClB,UAAWmD,EACX,SAAAN,EACA,eAAAO,EACA,MAAA5C,EACA,SAAAuC,EACA,SAAU,CACR,UAAAZ,EACA,SAAAC,CACD,CACP,CAAK,EAUD,GATAa,EAAIK,GAAwBL,EAC5BC,EAAIK,GAAwBL,EAC5BE,EAAiB,CACf,GAAGA,EACH,CAACxZ,CAAI,EAAG,CACN,GAAGwZ,EAAexZ,CAAI,EACtB,GAAGqD,CACJ,CACP,EACQuW,GAASH,GAAc,GAAI,CAC7BA,IACI,OAAOG,GAAU,WACfA,EAAM,YACRL,EAAoBK,EAAM,WAExBA,EAAM,QACRhD,EAAQgD,EAAM,QAAU,GAAO,MAAMT,EAAS,gBAAgB,CAC5D,UAAAZ,EACA,SAAAC,EACA,SAAAS,CACZ,CAAW,EAAIW,EAAM,OAEZ,CACC,EAAAP,EACA,EAAAC,CACD,EAAGjB,GAA2BzB,EAAO2C,EAAmB1C,CAAG,GAE9D5Y,EAAI,GACJ,QACD,CACF,CACD,MAAO,CACL,EAAAob,EACA,EAAAC,EACA,UAAWC,EACX,SAAAN,EACA,eAAAO,CACJ,CACA,EAUA,eAAeK,GAAe3F,EAAOtM,EAAS,CAC5C,IAAIkS,EACAlS,IAAY,SACdA,EAAU,CAAA,GAEZ,KAAM,CACJ,EAAAyR,EACA,EAAAC,EACA,SAAAH,EACA,MAAAvC,EACA,SAAAmD,EACA,SAAAd,CACD,EAAG/E,EACE,CACJ,SAAA8F,EAAW,oBACX,aAAAC,EAAe,WACf,eAAAC,EAAiB,WACjB,YAAAC,EAAc,GACd,QAAAlC,EAAU,CACd,EAAMzN,GAAS5C,EAASsM,CAAK,EACrBkG,EAAgBlC,GAAiBD,CAAO,EAExCpK,EAAUkM,EAASI,EADND,IAAmB,WAAa,YAAc,WACbA,CAAc,EAC5DG,EAAqBlC,GAAiB,MAAMgB,EAAS,gBAAgB,CACzE,SAAWW,EAAwB,MAAOX,EAAS,WAAa,KAAO,OAASA,EAAS,UAAUtL,CAAO,KAAO,MAAOiM,EAAgCjM,EAAUA,EAAQ,gBAAmB,MAAOsL,EAAS,oBAAsB,KAAO,OAASA,EAAS,mBAAmBY,EAAS,QAAQ,GAChS,SAAAC,EACA,aAAAC,EACA,SAAAhB,CACD,CAAA,CAAC,EACIb,EAAO8B,IAAmB,WAAa,CAC3C,GAAGtD,EAAM,SACT,EAAAyC,EACA,EAAAC,CACJ,EAAM1C,EAAM,UACJ0D,EAAe,MAAOnB,EAAS,iBAAmB,KAAO,OAASA,EAAS,gBAAgBY,EAAS,QAAQ,GAC5GQ,EAAe,MAAOpB,EAAS,WAAa,KAAO,OAASA,EAAS,UAAUmB,CAAY,GAAO,MAAOnB,EAAS,UAAY,KAAO,OAASA,EAAS,SAASmB,CAAY,IAAO,CACvL,EAAG,EACH,EAAG,CACP,EAAM,CACF,EAAG,EACH,EAAG,CACP,EACQE,EAAoBrC,GAAiBgB,EAAS,sDAAwD,MAAMA,EAAS,sDAAsD,CAC/K,KAAAf,EACA,aAAAkC,EACA,SAAArB,CACJ,CAAG,EAAIb,CAAI,EACT,MAAO,CACL,KAAMiC,EAAmB,IAAMG,EAAkB,IAAMJ,EAAc,KAAOG,EAAY,EACxF,QAASC,EAAkB,OAASH,EAAmB,OAASD,EAAc,QAAUG,EAAY,EACpG,MAAOF,EAAmB,KAAOG,EAAkB,KAAOJ,EAAc,MAAQG,EAAY,EAC5F,OAAQC,EAAkB,MAAQH,EAAmB,MAAQD,EAAc,OAASG,EAAY,CACpG,CACA,CAOA,MAAME,GAAQ7S,IAAY,CACxB,KAAM,QACN,QAAAA,EACA,MAAM,GAAGsM,EAAO,CACd,KAAM,CACJ,EAAAmF,EACA,EAAAC,EACA,UAAAlD,EACA,MAAAQ,EACA,SAAAuC,EACA,SAAAY,CACD,EAAG7F,EAEE,CACJ,QAAArG,EACA,QAAAoK,EAAU,CACX,EAAGzN,GAAS5C,EAASsM,CAAK,GAAK,CAAA,EAChC,GAAIrG,GAAW,KACb,MAAO,GAET,MAAMuM,EAAgBlC,GAAiBD,CAAO,EACxCc,EAAS,CACb,EAAAM,EACA,EAAAC,CACN,EACU/C,EAAOG,GAAiBN,CAAS,EACjCY,EAASR,GAAcD,CAAI,EAC3BmE,EAAkB,MAAMvB,EAAS,cAActL,CAAO,EACtD8M,EAAUpE,IAAS,IACnBqE,EAAUD,EAAU,MAAQ,OAC5BE,EAAUF,EAAU,SAAW,QAC/BG,EAAaH,EAAU,eAAiB,cACxCI,EAAUnE,EAAM,UAAUI,CAAM,EAAIJ,EAAM,UAAUL,CAAI,EAAIwC,EAAOxC,CAAI,EAAIK,EAAM,SAASI,CAAM,EAChGgE,EAAYjC,EAAOxC,CAAI,EAAIK,EAAM,UAAUL,CAAI,EAC/C0E,EAAoB,MAAO9B,EAAS,iBAAmB,KAAO,OAASA,EAAS,gBAAgBtL,CAAO,GAC7G,IAAIqN,EAAaD,EAAoBA,EAAkBH,CAAU,EAAI,GAGjE,CAACI,GAAc,CAAE,MAAO/B,EAAS,WAAa,KAAO,OAASA,EAAS,UAAU8B,CAAiB,MACpGC,EAAanB,EAAS,SAASe,CAAU,GAAKlE,EAAM,SAASI,CAAM,GAErE,MAAMmE,EAAoBJ,EAAU,EAAIC,EAAY,EAI9CI,EAAyBF,EAAa,EAAIR,EAAgB1D,CAAM,EAAI,EAAI,EACxEqE,EAAa1F,GAAIyE,EAAcQ,CAAO,EAAGQ,CAAsB,EAC/DE,EAAa3F,GAAIyE,EAAcS,CAAO,EAAGO,CAAsB,EAI/DG,EAAQF,EACRvb,EAAMob,EAAaR,EAAgB1D,CAAM,EAAIsE,EAC7CE,EAASN,EAAa,EAAIR,EAAgB1D,CAAM,EAAI,EAAImE,EACxDM,EAASxF,GAAMsF,EAAOC,EAAQ1b,CAAG,EAOjC4b,EADkBrF,GAAaD,CAAS,GAAK,MAAQoF,GAAUC,GAAU7E,EAAM,UAAUI,CAAM,EAAI,GAAKwE,EAASD,EAAQF,EAAaC,GAAcZ,EAAgB1D,CAAM,EAAI,EAAI,EAC9IwE,EAASD,EAAQA,EAAQC,EAAS1b,EAAM0b,EAAS,EAC3F,MAAO,CACL,CAACjF,CAAI,EAAGwC,EAAOxC,CAAI,EAAImF,EACvB,KAAM,CACJ,CAACnF,CAAI,EAAGkF,EACR,aAAcD,EAASC,EAASC,CACjC,CACP,CACG,CACH,GA+GMC,GAAO,SAAU/T,EAAS,CAC9B,OAAIA,IAAY,SACdA,EAAU,CAAA,GAEL,CACL,KAAM,OACN,QAAAA,EACA,MAAM,GAAGsM,EAAO,CACd,IAAI0H,EACJ,KAAM,CACJ,UAAAxF,EACA,eAAAoD,EACA,MAAA5C,EACA,iBAAAiF,EACA,SAAA1C,EACA,SAAAY,CACD,EAAG7F,EACE,CACJ,SAAU4H,EAAgB,GAC1B,UAAWC,EAAiB,GAC5B,mBAAoBC,EACpB,iBAAAC,EAAmB,UACnB,0BAAAC,EAA4B,OAC5B,cAAApE,EAAgB,GAChB,GAAGqE,CACX,EAAU3R,GAAS5C,EAASsM,CAAK,EACrBqD,EAAOpB,GAAQC,CAAS,EACxBgG,EAAkBjG,GAAQ0F,CAAgB,IAAMA,EAChDhF,EAAM,MAAOsC,EAAS,OAAS,KAAO,OAASA,EAAS,MAAMY,EAAS,QAAQ,GAC/EsC,EAAqBL,IAAgCI,GAAmB,CAACtE,EAAgB,CAACZ,GAAqB2E,CAAgB,CAAC,EAAI1E,GAAsB0E,CAAgB,GAC5K,CAACG,GAA+BE,IAA8B,QAChEG,EAAmB,KAAK,GAAGxE,GAA0BgE,EAAkB/D,EAAeoE,EAA2BrF,CAAG,CAAC,EAEvH,MAAMyF,EAAa,CAACT,EAAkB,GAAGQ,CAAkB,EACrDE,EAAW,MAAM1C,GAAe3F,EAAOiI,CAAqB,EAC5DK,EAAY,CAAA,EAClB,IAAIC,IAAkBb,EAAuBpC,EAAe,OAAS,KAAO,OAASoC,EAAqB,YAAc,CAAA,EAIxH,GAHIE,GACFU,EAAU,KAAKD,EAAShF,CAAI,CAAC,EAE3BwE,EAAgB,CAClB,MAAMW,EAAQ/F,GAAkBP,EAAWQ,EAAOC,CAAG,EACrD2F,EAAU,KAAKD,EAASG,EAAM,CAAC,CAAC,EAAGH,EAASG,EAAM,CAAC,CAAC,CAAC,CACtD,CAOD,GANAD,EAAgB,CAAC,GAAGA,EAAe,CACjC,UAAArG,EACA,UAAAoG,CACR,CAAO,EAGG,CAACA,EAAU,MAAMjF,GAAQA,GAAQ,CAAC,EAAG,CACvC,IAAIoF,EAAuBC,EAC3B,MAAMhR,KAAe+Q,EAAwBnD,EAAe,OAAS,KAAO,OAASmD,EAAsB,QAAU,GAAK,EACpHE,EAAgBP,EAAW1Q,CAAS,EAC1C,GAAIiR,EAEF,MAAO,CACL,KAAM,CACJ,MAAOjR,EACP,UAAW6Q,CACZ,EACD,MAAO,CACL,UAAWI,CACZ,CACb,EAKQ,IAAIC,GAAkBF,EAAwBH,EAAc,OAAOM,GAAKA,EAAE,UAAU,CAAC,GAAK,CAAC,EAAE,KAAK,CAACvb,EAAGC,IAAMD,EAAE,UAAU,CAAC,EAAIC,EAAE,UAAU,CAAC,CAAC,EAAE,CAAC,IAAM,KAAO,OAASmb,EAAsB,UAG1L,GAAI,CAACE,EACH,OAAQb,EAAgB,CACtB,IAAK,UACH,CACE,IAAIe,EACJ,MAAM5G,GAAa4G,EAAwBP,EAAc,IAAIM,GAAK,CAACA,EAAE,UAAWA,EAAE,UAAU,OAAOR,GAAYA,EAAW,CAAC,EAAE,OAAO,CAACU,EAAKV,IAAaU,EAAMV,EAAU,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC/a,EAAGC,IAAMD,EAAE,CAAC,EAAIC,EAAE,CAAC,CAAC,EAAE,CAAC,IAAM,KAAO,OAASub,EAAsB,CAAC,EAClP5G,IACF0G,EAAiB1G,GAEnB,KACD,CACH,IAAK,mBACH0G,EAAiBjB,EACjB,KACH,CAEH,GAAIzF,IAAc0G,EAChB,MAAO,CACL,MAAO,CACL,UAAWA,CACZ,CACb,CAEO,CACD,MAAO,EACR,CACL,CACA,EA4MA,eAAeI,GAAqBhJ,EAAOtM,EAAS,CAClD,KAAM,CACJ,UAAAwO,EACA,SAAA+C,EACA,SAAAY,CACD,EAAG7F,EACE2C,EAAM,MAAOsC,EAAS,OAAS,KAAO,OAASA,EAAS,MAAMY,EAAS,QAAQ,GAC/ExC,EAAOpB,GAAQC,CAAS,EACxBU,EAAYT,GAAaD,CAAS,EAClCuC,EAAalC,GAAYL,CAAS,IAAM,IACxC+G,EAAgB,CAAC,OAAQ,KAAK,EAAE,SAAS5F,CAAI,EAAI,GAAK,EACtD6F,EAAiBvG,GAAO8B,EAAa,GAAK,EAC1C0E,EAAW7S,GAAS5C,EAASsM,CAAK,EAGxC,GAAI,CACF,SAAAoJ,EACA,UAAAC,EACA,cAAAxG,CACJ,EAAM,OAAOsG,GAAa,SAAW,CACjC,SAAUA,EACV,UAAW,EACX,cAAe,IACnB,EAAM,CACF,SAAU,EACV,UAAW,EACX,cAAe,KACf,GAAGA,CACP,EACE,OAAIvG,GAAa,OAAOC,GAAkB,WACxCwG,EAAYzG,IAAc,MAAQC,EAAgB,GAAKA,GAElD4B,EAAa,CAClB,EAAG4E,EAAYH,EACf,EAAGE,EAAWH,CAClB,EAAM,CACF,EAAGG,EAAWH,EACd,EAAGI,EAAYH,CACnB,CACA,CASA,MAAM3B,GAAS,SAAU7T,EAAS,CAChC,OAAIA,IAAY,SACdA,EAAU,GAEL,CACL,KAAM,SACN,QAAAA,EACA,MAAM,GAAGsM,EAAO,CACd,KAAM,CACJ,EAAAmF,EACA,EAAAC,CACD,EAAGpF,EACEsJ,EAAa,MAAMN,GAAqBhJ,EAAOtM,CAAO,EAC5D,MAAO,CACL,EAAGyR,EAAImE,EAAW,EAClB,EAAGlE,EAAIkE,EAAW,EAClB,KAAMA,CACd,CACK,CACL,CACA,EAOMC,GAAQ,SAAU7V,EAAS,CAC/B,OAAIA,IAAY,SACdA,EAAU,CAAA,GAEL,CACL,KAAM,QACN,QAAAA,EACA,MAAM,GAAGsM,EAAO,CACd,KAAM,CACJ,EAAAmF,EACA,EAAAC,EACA,UAAAlD,CACD,EAAGlC,EACE,CACJ,SAAU4H,EAAgB,GAC1B,UAAWC,EAAiB,GAC5B,QAAA2B,EAAU,CACR,GAAIpF,GAAQ,CACV,GAAI,CACF,EAAAe,EACA,EAAAC,CACD,EAAGhB,EACJ,MAAO,CACL,EAAAe,EACA,EAAAC,CACd,CACW,CACF,EACD,GAAG6C,CACX,EAAU3R,GAAS5C,EAASsM,CAAK,EACrB6E,EAAS,CACb,EAAAM,EACA,EAAAC,CACR,EACYiD,EAAW,MAAM1C,GAAe3F,EAAOiI,CAAqB,EAC5DoB,EAAY9G,GAAYN,GAAQC,CAAS,CAAC,EAC1CkH,EAAWhH,GAAgBiH,CAAS,EAC1C,IAAII,EAAgB5E,EAAOuE,CAAQ,EAC/BM,EAAiB7E,EAAOwE,CAAS,EACrC,GAAIzB,EAAe,CACjB,MAAM+B,EAAUP,IAAa,IAAM,MAAQ,OACrCQ,EAAUR,IAAa,IAAM,SAAW,QACxC3H,EAAMgI,EAAgBpB,EAASsB,CAAO,EACtC/d,EAAM6d,EAAgBpB,EAASuB,CAAO,EAC5CH,EAAgB1H,GAAMN,EAAKgI,EAAe7d,CAAG,CAC9C,CACD,GAAIic,EAAgB,CAClB,MAAM8B,EAAUN,IAAc,IAAM,MAAQ,OACtCO,EAAUP,IAAc,IAAM,SAAW,QACzC5H,EAAMiI,EAAiBrB,EAASsB,CAAO,EACvC/d,EAAM8d,EAAiBrB,EAASuB,CAAO,EAC7CF,EAAiB3H,GAAMN,EAAKiI,EAAgB9d,CAAG,CAChD,CACD,MAAMie,EAAgBL,EAAQ,GAAG,CAC/B,GAAGxJ,EACH,CAACoJ,CAAQ,EAAGK,EACZ,CAACJ,CAAS,EAAGK,CACrB,CAAO,EACD,MAAO,CACL,GAAGG,EACH,KAAM,CACJ,EAAGA,EAAc,EAAI1E,EACrB,EAAG0E,EAAc,EAAIzE,CACtB,CACT,CACK,CACL,CACA,EA4EMlJ,GAAO,SAAUxI,EAAS,CAC9B,OAAIA,IAAY,SACdA,EAAU,CAAA,GAEL,CACL,KAAM,OACN,QAAAA,EACA,MAAM,GAAGsM,EAAO,CACd,KAAM,CACJ,UAAAkC,EACA,MAAAQ,EACA,SAAAuC,EACA,SAAAY,CACD,EAAG7F,EACE,CACJ,MAAA8J,EAAQ,IAAM,CAAE,EAChB,GAAG7B,CACX,EAAU3R,GAAS5C,EAASsM,CAAK,EACrBqI,EAAW,MAAM1C,GAAe3F,EAAOiI,CAAqB,EAC5D5E,EAAOpB,GAAQC,CAAS,EACxBU,EAAYT,GAAaD,CAAS,EAClCuE,EAAUlE,GAAYL,CAAS,IAAM,IACrC,CACJ,MAAA6H,EACA,OAAAC,CACR,EAAUtH,EAAM,SACV,IAAIuH,EACAC,EACA7G,IAAS,OAASA,IAAS,UAC7B4G,EAAa5G,EACb6G,EAAYtH,KAAgB,MAAOqC,EAAS,OAAS,KAAO,OAASA,EAAS,MAAMY,EAAS,QAAQ,GAAM,QAAU,OAAS,OAAS,UAEvIqE,EAAY7G,EACZ4G,EAAarH,IAAc,MAAQ,MAAQ,UAE7C,MAAMuH,EAA0BH,EAAS3B,EAAS4B,CAAU,EACtDG,EAAyBL,EAAQ1B,EAAS6B,CAAS,EACnDG,EAAU,CAACrK,EAAM,eAAe,MACtC,IAAIsK,EAAkBH,EAClBI,EAAiBH,EACrB,GAAI3D,EAAS,CACX,MAAM+D,EAAuBT,EAAQ1B,EAAS,KAAOA,EAAS,MAC9DkC,EAAiB3H,GAAayH,EAAU5I,GAAI2I,EAAwBI,CAAoB,EAAIA,CACpG,KAAa,CACL,MAAMC,EAAwBT,EAAS3B,EAAS,IAAMA,EAAS,OAC/DiC,EAAkB1H,GAAayH,EAAU5I,GAAI0I,EAAyBM,CAAqB,EAAIA,CAChG,CACD,GAAIJ,GAAW,CAACzH,EAAW,CACzB,MAAM8H,EAAO9e,GAAIyc,EAAS,KAAM,CAAC,EAC3BsC,EAAO/e,GAAIyc,EAAS,MAAO,CAAC,EAC5BuC,EAAOhf,GAAIyc,EAAS,IAAK,CAAC,EAC1BwC,EAAOjf,GAAIyc,EAAS,OAAQ,CAAC,EAC/B5B,EACF8D,EAAiBR,EAAQ,GAAKW,IAAS,GAAKC,IAAS,EAAID,EAAOC,EAAO/e,GAAIyc,EAAS,KAAMA,EAAS,KAAK,GAExGiC,EAAkBN,EAAS,GAAKY,IAAS,GAAKC,IAAS,EAAID,EAAOC,EAAOjf,GAAIyc,EAAS,IAAKA,EAAS,MAAM,EAE7G,CACD,MAAMyB,EAAM,CACV,GAAG9J,EACH,eAAAuK,EACA,gBAAAD,CACR,CAAO,EACD,MAAMQ,EAAiB,MAAM7F,EAAS,cAAcY,EAAS,QAAQ,EACrE,OAAIkE,IAAUe,EAAe,OAASd,IAAWc,EAAe,OACvD,CACL,MAAO,CACL,MAAO,EACR,CACX,EAEa,EACR,CACL,CACA,ECn+BA,SAASC,GAAYxV,EAAM,CACzB,OAAIyV,GAAOzV,CAAI,GACLA,EAAK,UAAY,IAAI,YAAW,EAKnC,WACT,CACA,SAAS0V,GAAU1V,EAAM,CACvB,IAAI2V,EACJ,OAAQ3V,GAAQ,OAAiB2V,EAAsB3V,EAAK,gBAAkB,KAAvD,OAAuE2V,EAAoB,cAAgB,MACpI,CACA,SAASC,GAAmB5V,EAAM,CAChC,IAAI6O,EACJ,OAAQA,GAAQ4G,GAAOzV,CAAI,EAAIA,EAAK,cAAgBA,EAAK,WAAa,OAAO,WAAa,KAAO,OAAS6O,EAAK,eACjH,CACA,SAAS4G,GAAOpgB,EAAO,CACrB,OAAOA,aAAiB,MAAQA,aAAiBqgB,GAAUrgB,CAAK,EAAE,IACpE,CACA,SAASwgB,GAAUxgB,EAAO,CACxB,OAAOA,aAAiB,SAAWA,aAAiBqgB,GAAUrgB,CAAK,EAAE,OACvE,CACA,SAAS8O,GAAc9O,EAAO,CAC5B,OAAOA,aAAiB,aAAeA,aAAiBqgB,GAAUrgB,CAAK,EAAE,WAC3E,CACA,SAASygB,GAAazgB,EAAO,CAE3B,OAAI,OAAO,WAAe,IACjB,GAEFA,aAAiB,YAAcA,aAAiBqgB,GAAUrgB,CAAK,EAAE,UAC1E,CACA,SAAS0gB,GAAkB3R,EAAS,CAClC,KAAM,CACJ,SAAA0O,EACA,UAAAkD,EACA,UAAAC,EACA,QAAAC,CACJ,EAAMC,GAAiB/R,CAAO,EAC5B,MAAO,kCAAkC,KAAK0O,EAAWmD,EAAYD,CAAS,GAAK,CAAC,CAAC,SAAU,UAAU,EAAE,SAASE,CAAO,CAC7H,CACA,SAASE,GAAehS,EAAS,CAC/B,MAAO,CAAC,QAAS,KAAM,IAAI,EAAE,SAASoR,GAAYpR,CAAO,CAAC,CAC5D,CACA,SAASiS,GAAkBjS,EAAS,CAClC,MAAMkS,EAASC,KACTC,EAAML,GAAiB/R,CAAO,EAGpC,OAAOoS,EAAI,YAAc,QAAUA,EAAI,cAAgB,SAAWA,EAAI,cAAgBA,EAAI,gBAAkB,SAAW,KAAU,CAACF,IAAWE,EAAI,eAAiBA,EAAI,iBAAmB,OAAS,KAAU,CAACF,IAAWE,EAAI,OAASA,EAAI,SAAW,OAAS,KAAU,CAAC,YAAa,cAAe,QAAQ,EAAE,KAAKnhB,IAAUmhB,EAAI,YAAc,IAAI,SAASnhB,CAAK,CAAC,GAAK,CAAC,QAAS,SAAU,SAAU,SAAS,EAAE,KAAKA,IAAUmhB,EAAI,SAAW,IAAI,SAASnhB,CAAK,CAAC,CACnc,CACA,SAASohB,GAAmBrS,EAAS,CACnC,IAAIsS,EAAcC,GAAcvS,CAAO,EACvC,KAAOD,GAAcuS,CAAW,GAAK,CAACE,GAAsBF,CAAW,GAAG,CACxE,GAAIL,GAAkBK,CAAW,EAC/B,OAAOA,EAEPA,EAAcC,GAAcD,CAAW,CAE1C,CACD,OAAO,IACT,CACA,SAASH,IAAW,CAClB,OAAI,OAAO,IAAQ,KAAe,CAAC,IAAI,SAAiB,GACjD,IAAI,SAAS,0BAA2B,MAAM,CACvD,CACA,SAASK,GAAsB5W,EAAM,CACnC,MAAO,CAAC,OAAQ,OAAQ,WAAW,EAAE,SAASwV,GAAYxV,CAAI,CAAC,CACjE,CACA,SAASmW,GAAiB/R,EAAS,CACjC,OAAOsR,GAAUtR,CAAO,EAAE,iBAAiBA,CAAO,CACpD,CACA,SAASyS,GAAczS,EAAS,CAC9B,OAAIyR,GAAUzR,CAAO,EACZ,CACL,WAAYA,EAAQ,WACpB,UAAWA,EAAQ,SACzB,EAES,CACL,WAAYA,EAAQ,YACpB,UAAWA,EAAQ,WACvB,CACA,CACA,SAASuS,GAAc3W,EAAM,CAC3B,GAAIwV,GAAYxV,CAAI,IAAM,OACxB,OAAOA,EAET,MAAMvK,EAENuK,EAAK,cAELA,EAAK,YAEL8V,GAAa9V,CAAI,GAAKA,EAAK,MAE3B4V,GAAmB5V,CAAI,EACvB,OAAO8V,GAAargB,CAAM,EAAIA,EAAO,KAAOA,CAC9C,CACA,SAASqhB,GAA2B9W,EAAM,CACxC,MAAM+W,EAAaJ,GAAc3W,CAAI,EACrC,OAAI4W,GAAsBG,CAAU,EAC3B/W,EAAK,cAAgBA,EAAK,cAAc,KAAOA,EAAK,KAEzDmE,GAAc4S,CAAU,GAAKhB,GAAkBgB,CAAU,EACpDA,EAEFD,GAA2BC,CAAU,CAC9C,CACA,SAASC,GAAqBhX,EAAMxI,EAAM,CACxC,IAAIyf,EACAzf,IAAS,SACXA,EAAO,CAAA,GAET,MAAM0f,EAAqBJ,GAA2B9W,CAAI,EACpDmX,EAASD,MAAyBD,EAAuBjX,EAAK,gBAAkB,KAAO,OAASiX,EAAqB,MACrH7O,EAAMsN,GAAUwB,CAAkB,EACxC,OAAIC,EACK3f,EAAK,OAAO4Q,EAAKA,EAAI,gBAAkB,GAAI2N,GAAkBmB,CAAkB,EAAIA,EAAqB,CAAE,CAAA,EAE5G1f,EAAK,OAAO0f,EAAoBF,GAAqBE,CAAkB,CAAC,CACjF,CCpHA,SAASE,GAAiBhT,EAAS,CACjC,MAAMoS,EAAML,GAAiB/R,CAAO,EAGpC,IAAIoQ,EAAQ,WAAWgC,EAAI,KAAK,GAAK,EACjC/B,EAAS,WAAW+B,EAAI,MAAM,GAAK,EACvC,MAAMa,EAAYlT,GAAcC,CAAO,EACjCkT,EAAcD,EAAYjT,EAAQ,YAAcoQ,EAChD+C,EAAeF,EAAYjT,EAAQ,aAAeqQ,EAClD+C,EAAiBrL,GAAMqI,CAAK,IAAM8C,GAAenL,GAAMsI,CAAM,IAAM8C,EACzE,OAAIC,IACFhD,EAAQ8C,EACR7C,EAAS8C,GAEJ,CACL,MAAA/C,EACA,OAAAC,EACA,EAAG+C,CACP,CACA,CAEA,SAASC,GAAcrT,EAAS,CAC9B,OAAQyR,GAAUzR,CAAO,EAA6BA,EAAzBA,EAAQ,cACvC,CAEA,SAASsT,GAAStT,EAAS,CACzB,MAAMuT,EAAaF,GAAcrT,CAAO,EACxC,GAAI,CAACD,GAAcwT,CAAU,EAC3B,OAAOtL,GAAa,CAAC,EAEvB,MAAMsC,EAAOgJ,EAAW,wBAClB,CACJ,MAAAnD,EACA,OAAAC,EACA,EAAAmD,CACJ,EAAMR,GAAiBO,CAAU,EAC/B,IAAI/H,GAAKgI,EAAIzL,GAAMwC,EAAK,KAAK,EAAIA,EAAK,OAAS6F,EAC3C3E,GAAK+H,EAAIzL,GAAMwC,EAAK,MAAM,EAAIA,EAAK,QAAU8F,EAIjD,OAAI,CAAC7E,GAAK,CAAC,OAAO,SAASA,CAAC,KAC1BA,EAAI,IAEF,CAACC,GAAK,CAAC,OAAO,SAASA,CAAC,KAC1BA,EAAI,GAEC,CACL,EAAAD,EACA,EAAAC,CACJ,CACA,CAEA,MAAMgI,GAAyBxL,GAAa,CAAC,EAC7C,SAASyL,GAAiB1T,EAAS,CACjC,MAAMgE,EAAMsN,GAAUtR,CAAO,EAC7B,MAAI,CAACmS,GAAQ,GAAM,CAACnO,EAAI,eACfyP,GAEF,CACL,EAAGzP,EAAI,eAAe,WACtB,EAAGA,EAAI,eAAe,SAC1B,CACA,CACA,SAAS2P,GAAuB3T,EAAS4T,EAASC,EAAsB,CAItE,OAHID,IAAY,SACdA,EAAU,IAER,CAACC,GAAwBD,GAAWC,IAAyBvC,GAAUtR,CAAO,EACzE,GAEF4T,CACT,CAEA,SAASE,GAAsB9T,EAAS+T,EAAcC,EAAiBvH,EAAc,CAC/EsH,IAAiB,SACnBA,EAAe,IAEbC,IAAoB,SACtBA,EAAkB,IAEpB,MAAMC,EAAajU,EAAQ,wBACrBuT,EAAaF,GAAcrT,CAAO,EACxC,IAAIkU,EAAQjM,GAAa,CAAC,EACtB8L,IACEtH,EACEgF,GAAUhF,CAAY,IACxByH,EAAQZ,GAAS7G,CAAY,GAG/ByH,EAAQZ,GAAStT,CAAO,GAG5B,MAAMmU,EAAgBR,GAAuBJ,EAAYS,EAAiBvH,CAAY,EAAIiH,GAAiBH,CAAU,EAAItL,GAAa,CAAC,EACvI,IAAIuD,GAAKyI,EAAW,KAAOE,EAAc,GAAKD,EAAM,EAChDzI,GAAKwI,EAAW,IAAME,EAAc,GAAKD,EAAM,EAC/C9D,EAAQ6D,EAAW,MAAQC,EAAM,EACjC7D,EAAS4D,EAAW,OAASC,EAAM,EACvC,GAAIX,EAAY,CACd,MAAMvP,EAAMsN,GAAUiC,CAAU,EAC1Ba,EAAY3H,GAAgBgF,GAAUhF,CAAY,EAAI6E,GAAU7E,CAAY,EAAIA,EACtF,IAAI4H,EAAgBrQ,EAAI,aACxB,KAAOqQ,GAAiB5H,GAAgB2H,IAAcpQ,GAAK,CACzD,MAAMsQ,EAAchB,GAASe,CAAa,EACpCE,EAAaF,EAAc,wBAC3BjC,EAAML,GAAiBsC,CAAa,EACpCG,EAAOD,EAAW,MAAQF,EAAc,WAAa,WAAWjC,EAAI,WAAW,GAAKkC,EAAY,EAChGG,EAAMF,EAAW,KAAOF,EAAc,UAAY,WAAWjC,EAAI,UAAU,GAAKkC,EAAY,EAClG9I,GAAK8I,EAAY,EACjB7I,GAAK6I,EAAY,EACjBlE,GAASkE,EAAY,EACrBjE,GAAUiE,EAAY,EACtB9I,GAAKgJ,EACL/I,GAAKgJ,EACLJ,EAAgB/C,GAAU+C,CAAa,EAAE,YAC1C,CACF,CACD,OAAO/J,GAAiB,CACtB,MAAA8F,EACA,OAAAC,EACA,EAAA7E,EACA,EAAAC,CACJ,CAAG,CACH,CAEA,SAASiJ,GAAsDjK,EAAM,CACnE,GAAI,CACF,KAAAF,EACA,aAAAkC,EACA,SAAArB,CACD,EAAGX,EACJ,MAAMkK,EAA0B5U,GAAc0M,CAAY,EACpD7I,EAAkB4N,GAAmB/E,CAAY,EACvD,GAAIA,IAAiB7I,EACnB,OAAO2G,EAET,IAAIqK,EAAS,CACX,WAAY,EACZ,UAAW,CACf,EACMV,EAAQjM,GAAa,CAAC,EAC1B,MAAM4M,EAAU5M,GAAa,CAAC,EAC9B,IAAI0M,GAA2B,CAACA,GAA2BvJ,IAAa,YAClEgG,GAAY3E,CAAY,IAAM,QAAUkF,GAAkB/N,CAAe,KAC3EgR,EAASnC,GAAchG,CAAY,GAEjC1M,GAAc0M,CAAY,GAAG,CAC/B,MAAMqI,EAAahB,GAAsBrH,CAAY,EACrDyH,EAAQZ,GAAS7G,CAAY,EAC7BoI,EAAQ,EAAIC,EAAW,EAAIrI,EAAa,WACxCoI,EAAQ,EAAIC,EAAW,EAAIrI,EAAa,SACzC,CAEH,MAAO,CACL,MAAOlC,EAAK,MAAQ2J,EAAM,EAC1B,OAAQ3J,EAAK,OAAS2J,EAAM,EAC5B,EAAG3J,EAAK,EAAI2J,EAAM,EAAIU,EAAO,WAAaV,EAAM,EAAIW,EAAQ,EAC5D,EAAGtK,EAAK,EAAI2J,EAAM,EAAIU,EAAO,UAAYV,EAAM,EAAIW,EAAQ,CAC/D,CACA,CAEA,SAASE,GAAe/U,EAAS,CAC/B,OAAO,MAAM,KAAKA,EAAQ,eAAgB,CAAA,CAC5C,CAEA,SAASgV,GAAoBhV,EAAS,CAGpC,OAAO8T,GAAsBtC,GAAmBxR,CAAO,CAAC,EAAE,KAAOyS,GAAczS,CAAO,EAAE,UAC1F,CAIA,SAASiV,GAAgBjV,EAAS,CAChC,MAAMkV,EAAO1D,GAAmBxR,CAAO,EACjC4U,EAASnC,GAAczS,CAAO,EAC9BiE,EAAOjE,EAAQ,cAAc,KAC7BoQ,EAAQne,GAAIijB,EAAK,YAAaA,EAAK,YAAajR,EAAK,YAAaA,EAAK,WAAW,EAClFoM,EAASpe,GAAIijB,EAAK,aAAcA,EAAK,aAAcjR,EAAK,aAAcA,EAAK,YAAY,EAC7F,IAAIuH,EAAI,CAACoJ,EAAO,WAAaI,GAAoBhV,CAAO,EACxD,MAAMyL,EAAI,CAACmJ,EAAO,UAClB,OAAI7C,GAAiB9N,CAAI,EAAE,YAAc,QACvCuH,GAAKvZ,GAAIijB,EAAK,YAAajR,EAAK,WAAW,EAAImM,GAE1C,CACL,MAAAA,EACA,OAAAC,EACA,EAAA7E,EACA,EAAAC,CACJ,CACA,CAEA,SAAS0J,GAAgBnV,EAASoL,EAAU,CAC1C,MAAMpH,EAAMsN,GAAUtR,CAAO,EACvBkV,EAAO1D,GAAmBxR,CAAO,EACjC0E,EAAiBV,EAAI,eAC3B,IAAIoM,EAAQ8E,EAAK,YACb7E,EAAS6E,EAAK,aACd1J,EAAI,EACJC,EAAI,EACR,GAAI/G,EAAgB,CAClB0L,EAAQ1L,EAAe,MACvB2L,EAAS3L,EAAe,OACxB,MAAM0Q,EAAsBjD,MACxB,CAACiD,GAAuBA,GAAuBhK,IAAa,WAC9DI,EAAI9G,EAAe,WACnB+G,EAAI/G,EAAe,UAEtB,CACD,MAAO,CACL,MAAA0L,EACA,OAAAC,EACA,EAAA7E,EACA,EAAAC,CACJ,CACA,CAGA,SAAS4J,GAA2BrV,EAASoL,EAAU,CACrD,MAAM6I,EAAaH,GAAsB9T,EAAS,GAAMoL,IAAa,OAAO,EACtEqJ,EAAMR,EAAW,IAAMjU,EAAQ,UAC/BwU,EAAOP,EAAW,KAAOjU,EAAQ,WACjCkU,EAAQnU,GAAcC,CAAO,EAAIsT,GAAStT,CAAO,EAAIiI,GAAa,CAAC,EACnEmI,EAAQpQ,EAAQ,YAAckU,EAAM,EACpC7D,EAASrQ,EAAQ,aAAekU,EAAM,EACtC1I,EAAIgJ,EAAON,EAAM,EACjBzI,EAAIgJ,EAAMP,EAAM,EACtB,MAAO,CACL,MAAA9D,EACA,OAAAC,EACA,EAAA7E,EACA,EAAAC,CACJ,CACA,CACA,SAAS6J,GAAkCtV,EAASuV,EAAkBnK,EAAU,CAC9E,IAAIb,EACJ,GAAIgL,IAAqB,WACvBhL,EAAO4K,GAAgBnV,EAASoL,CAAQ,UAC/BmK,IAAqB,WAC9BhL,EAAO0K,GAAgBzD,GAAmBxR,CAAO,CAAC,UACzCyR,GAAU8D,CAAgB,EACnChL,EAAO8K,GAA2BE,EAAkBnK,CAAQ,MACvD,CACL,MAAM+I,EAAgBT,GAAiB1T,CAAO,EAC9CuK,EAAO,CACL,GAAGgL,EACH,EAAGA,EAAiB,EAAIpB,EAAc,EACtC,EAAGoB,EAAiB,EAAIpB,EAAc,CAC5C,CACG,CACD,OAAO7J,GAAiBC,CAAI,CAC9B,CACA,SAASiL,GAAyBxV,EAASyV,EAAU,CACnD,MAAM9C,EAAaJ,GAAcvS,CAAO,EACxC,OAAI2S,IAAe8C,GAAY,CAAChE,GAAUkB,CAAU,GAAKH,GAAsBG,CAAU,EAChF,GAEFZ,GAAiBY,CAAU,EAAE,WAAa,SAAW6C,GAAyB7C,EAAY8C,CAAQ,CAC3G,CAKA,SAASC,GAA4B1V,EAAS7L,EAAO,CACnD,MAAMwhB,EAAexhB,EAAM,IAAI6L,CAAO,EACtC,GAAI2V,EACF,OAAOA,EAET,IAAItkB,EAASuhB,GAAqB5S,CAAO,EAAE,OAAOwB,GAAMiQ,GAAUjQ,CAAE,GAAK4P,GAAY5P,CAAE,IAAM,MAAM,EAC/FoU,EAAsC,KAC1C,MAAMC,EAAiB9D,GAAiB/R,CAAO,EAAE,WAAa,QAC9D,IAAIsS,EAAcuD,EAAiBtD,GAAcvS,CAAO,EAAIA,EAG5D,KAAOyR,GAAUa,CAAW,GAAK,CAACE,GAAsBF,CAAW,GAAG,CACpE,MAAMwD,EAAgB/D,GAAiBO,CAAW,EAC5CyD,EAA0B9D,GAAkBK,CAAW,EACzD,CAACyD,GAA2BD,EAAc,WAAa,UACzDF,EAAsC,OAEVC,EAAiB,CAACE,GAA2B,CAACH,EAAsC,CAACG,GAA2BD,EAAc,WAAa,UAAY,CAAC,CAACF,GAAuC,CAAC,WAAY,OAAO,EAAE,SAASA,EAAoC,QAAQ,GAAKjE,GAAkBW,CAAW,GAAK,CAACyD,GAA2BP,GAAyBxV,EAASsS,CAAW,GAGvZjhB,EAASA,EAAO,OAAO2kB,GAAYA,IAAa1D,CAAW,EAG3DsD,EAAsCE,EAExCxD,EAAcC,GAAcD,CAAW,CACxC,CACD,OAAAne,EAAM,IAAI6L,EAAS3O,CAAM,EAClBA,CACT,CAIA,SAAS4kB,GAAgBxL,EAAM,CAC7B,GAAI,CACF,QAAAzK,EACA,SAAAmM,EACA,aAAAC,EACA,SAAAhB,CACD,EAAGX,EAEJ,MAAMyL,EAAoB,CAAC,GADM/J,IAAa,oBAAsBuJ,GAA4B1V,EAAS,KAAK,EAAE,EAAI,CAAA,EAAG,OAAOmM,CAAQ,EAC9EC,CAAY,EAC9D+J,EAAwBD,EAAkB,CAAC,EAC3CE,EAAeF,EAAkB,OAAO,CAACG,EAASd,IAAqB,CAC3E,MAAMhL,EAAO+K,GAAkCtV,EAASuV,EAAkBnK,CAAQ,EAClF,OAAAiL,EAAQ,IAAMpkB,GAAIsY,EAAK,IAAK8L,EAAQ,GAAG,EACvCA,EAAQ,MAAQvO,GAAIyC,EAAK,MAAO8L,EAAQ,KAAK,EAC7CA,EAAQ,OAASvO,GAAIyC,EAAK,OAAQ8L,EAAQ,MAAM,EAChDA,EAAQ,KAAOpkB,GAAIsY,EAAK,KAAM8L,EAAQ,IAAI,EACnCA,CACR,EAAEf,GAAkCtV,EAASmW,EAAuB/K,CAAQ,CAAC,EAC9E,MAAO,CACL,MAAOgL,EAAa,MAAQA,EAAa,KACzC,OAAQA,EAAa,OAASA,EAAa,IAC3C,EAAGA,EAAa,KAChB,EAAGA,EAAa,GACpB,CACA,CAEA,SAASE,GAActW,EAAS,CAC9B,OAAOgT,GAAiBhT,CAAO,CACjC,CAEA,SAASuW,GAA8BvW,EAASyM,EAAcrB,EAAU,CACtE,MAAMuJ,EAA0B5U,GAAc0M,CAAY,EACpD7I,EAAkB4N,GAAmB/E,CAAY,EACjDmH,EAAUxI,IAAa,QACvBb,EAAOuJ,GAAsB9T,EAAS,GAAM4T,EAASnH,CAAY,EACvE,IAAImI,EAAS,CACX,WAAY,EACZ,UAAW,CACf,EACE,MAAMC,EAAU5M,GAAa,CAAC,EAC9B,GAAI0M,GAA2B,CAACA,GAA2B,CAACf,EAI1D,IAHIxC,GAAY3E,CAAY,IAAM,QAAUkF,GAAkB/N,CAAe,KAC3EgR,EAASnC,GAAchG,CAAY,GAEjCkI,EAAyB,CAC3B,MAAMG,EAAahB,GAAsBrH,EAAc,GAAMmH,EAASnH,CAAY,EAClFoI,EAAQ,EAAIC,EAAW,EAAIrI,EAAa,WACxCoI,EAAQ,EAAIC,EAAW,EAAIrI,EAAa,SACzC,MAAU7I,IACTiR,EAAQ,EAAIG,GAAoBpR,CAAe,GAGnD,MAAO,CACL,EAAG2G,EAAK,KAAOqK,EAAO,WAAaC,EAAQ,EAC3C,EAAGtK,EAAK,IAAMqK,EAAO,UAAYC,EAAQ,EACzC,MAAOtK,EAAK,MACZ,OAAQA,EAAK,MACjB,CACA,CAEA,SAASiM,GAAoBxW,EAASyW,EAAU,CAC9C,MAAI,CAAC1W,GAAcC,CAAO,GAAK+R,GAAiB/R,CAAO,EAAE,WAAa,QAC7D,KAELyW,EACKA,EAASzW,CAAO,EAElBA,EAAQ,YACjB,CAIA,SAAS0W,GAAgB1W,EAASyW,EAAU,CAC1C,MAAME,EAASrF,GAAUtR,CAAO,EAChC,GAAI,CAACD,GAAcC,CAAO,EACxB,OAAO2W,EAET,IAAIlK,EAAe+J,GAAoBxW,EAASyW,CAAQ,EACxD,KAAOhK,GAAgBuF,GAAevF,CAAY,GAAKsF,GAAiBtF,CAAY,EAAE,WAAa,UACjGA,EAAe+J,GAAoB/J,EAAcgK,CAAQ,EAE3D,OAAIhK,IAAiB2E,GAAY3E,CAAY,IAAM,QAAU2E,GAAY3E,CAAY,IAAM,QAAUsF,GAAiBtF,CAAY,EAAE,WAAa,UAAY,CAACwF,GAAkBxF,CAAY,GACnLkK,EAEFlK,GAAgB4F,GAAmBrS,CAAO,GAAK2W,CACxD,CAEA,MAAMC,GAAkB,eAAgBnM,EAAM,CAC5C,GAAI,CACF,UAAAC,EACA,SAAAC,EACA,SAAAS,CACD,EAAGX,EACJ,MAAMoM,EAAoB,KAAK,iBAAmBH,GAC5CI,EAAkB,KAAK,cAC7B,MAAO,CACL,UAAWP,GAA8B7L,EAAW,MAAMmM,EAAkBlM,CAAQ,EAAGS,CAAQ,EAC/F,SAAU,CACR,EAAG,EACH,EAAG,EACH,GAAI,MAAM0L,EAAgBnM,CAAQ,CACnC,CACL,CACA,EAEA,SAASoM,GAAM/W,EAAS,CACtB,OAAO+R,GAAiB/R,CAAO,EAAE,YAAc,KACjD,CAEA,MAAMsL,GAAW,CACf,sDAAAoJ,GACA,mBAAAlD,GACA,gBAAAyE,GACA,gBAAAS,GACA,gBAAAE,GACA,eAAA7B,GACA,cAAAuB,GACA,SAAAhD,GACA,UAAA7B,GACA,MAAAsF,EACF,EAGA,SAASC,GAAYhX,EAASiX,EAAQ,CACpC,IAAIC,EAAK,KACLC,EACJ,MAAMC,EAAO5F,GAAmBxR,CAAO,EACvC,SAASqX,GAAU,CACjB,aAAaF,CAAS,EACtBD,GAAMA,EAAG,aACTA,EAAK,IACN,CACD,SAASI,EAAQC,EAAMzgB,EAAW,CAC5BygB,IAAS,SACXA,EAAO,IAELzgB,IAAc,SAChBA,EAAY,GAEdugB,IACA,KAAM,CACJ,KAAA7C,EACA,IAAAC,EACA,MAAArE,EACA,OAAAC,CACN,EAAQrQ,EAAQ,wBAIZ,GAHKuX,GACHN,IAEE,CAAC7G,GAAS,CAACC,EACb,OAEF,MAAMmH,EAAWxP,GAAMyM,CAAG,EACpBgD,EAAazP,GAAMoP,EAAK,aAAe5C,EAAOpE,EAAM,EACpDsH,EAAc1P,GAAMoP,EAAK,cAAgB3C,EAAMpE,EAAO,EACtDsH,EAAY3P,GAAMwM,CAAI,EAEtBza,EAAU,CACd,WAFiB,CAACyd,EAAW,MAAQ,CAACC,EAAa,MAAQ,CAACC,EAAc,MAAQ,CAACC,EAAY,KAG/F,UAAW1lB,GAAI,EAAG6V,GAAI,EAAGhR,CAAS,CAAC,GAAK,CAC9C,EACI,IAAI8gB,EAAgB,GACpB,SAASC,EAAcC,EAAS,CAC9B,MAAMC,EAAQD,EAAQ,CAAC,EAAE,kBACzB,GAAIC,IAAUjhB,EAAW,CACvB,GAAI,CAAC8gB,EACH,OAAON,EAAO,EAEXS,EAKHT,EAAQ,GAAOS,CAAK,EAJpBZ,EAAY,WAAW,IAAM,CAC3BG,EAAQ,GAAO,IAAI,CACpB,EAAE,GAAG,CAIT,CACDM,EAAgB,EACjB,CAID,GAAI,CACFV,EAAK,IAAI,qBAAqBW,EAAe,CAC3C,GAAG9d,EAEH,KAAMqd,EAAK,aACnB,CAAO,CACF,MAAW,CACVF,EAAK,IAAI,qBAAqBW,EAAe9d,CAAO,CACrD,CACDmd,EAAG,QAAQlX,CAAO,CACnB,CACD,OAAAsX,EAAQ,EAAI,EACLD,CACT,CAUA,SAASW,GAAWtN,EAAWC,EAAU1a,EAAQ8J,EAAS,CACpDA,IAAY,SACdA,EAAU,CAAA,GAEZ,KAAM,CACJ,eAAAke,EAAiB,GACjB,eAAAC,EAAiB,GACjB,cAAAC,EAAgB,OAAO,gBAAmB,WAC1C,YAAAC,EAAc,OAAO,sBAAyB,WAC9C,eAAAC,EAAiB,EAClB,EAAGte,EACEue,EAAcjF,GAAc3I,CAAS,EACrC6N,EAAYN,GAAkBC,EAAiB,CAAC,GAAII,EAAc1F,GAAqB0F,CAAW,EAAI,CAAA,EAAK,GAAG1F,GAAqBjI,CAAQ,CAAC,EAAI,CAAA,EACtJ4N,EAAU,QAAQvC,GAAY,CAC5BiC,GAAkBjC,EAAS,iBAAiB,SAAU/lB,EAAQ,CAC5D,QAAS,EACf,CAAK,EACDioB,GAAkBlC,EAAS,iBAAiB,SAAU/lB,CAAM,CAChE,CAAG,EACD,MAAMuoB,EAAYF,GAAeF,EAAcpB,GAAYsB,EAAaroB,CAAM,EAAI,KAClF,IAAIwoB,EAAiB,GACjBC,EAAiB,KACjBP,IACFO,EAAiB,IAAI,eAAejO,GAAQ,CAC1C,GAAI,CAACkO,CAAU,EAAIlO,EACfkO,GAAcA,EAAW,SAAWL,GAAeI,IAGrDA,EAAe,UAAU/N,CAAQ,EACjC,qBAAqB8N,CAAc,EACnCA,EAAiB,sBAAsB,IAAM,CAC3CC,GAAkBA,EAAe,QAAQ/N,CAAQ,CAC3D,CAAS,GAEH1a,GACN,CAAK,EACGqoB,GAAe,CAACD,GAClBK,EAAe,QAAQJ,CAAW,EAEpCI,EAAe,QAAQ/N,CAAQ,GAEjC,IAAIiO,EACAC,EAAcR,EAAiBvE,GAAsBpJ,CAAS,EAAI,KAClE2N,GACFS,IAEF,SAASA,GAAY,CACnB,MAAMC,EAAcjF,GAAsBpJ,CAAS,EAC/CmO,IAAgBE,EAAY,IAAMF,EAAY,GAAKE,EAAY,IAAMF,EAAY,GAAKE,EAAY,QAAUF,EAAY,OAASE,EAAY,SAAWF,EAAY,SACtK5oB,IAEF4oB,EAAcE,EACdH,EAAU,sBAAsBE,CAAS,CAC1C,CACD,OAAA7oB,IACO,IAAM,CACXsoB,EAAU,QAAQvC,GAAY,CAC5BiC,GAAkBjC,EAAS,oBAAoB,SAAU/lB,CAAM,EAC/DioB,GAAkBlC,EAAS,oBAAoB,SAAU/lB,CAAM,CACrE,CAAK,EACDuoB,GAAaA,EAAS,EACtBE,GAAkBA,EAAe,aACjCA,EAAiB,KACbL,GACF,qBAAqBO,CAAO,CAElC,CACA,CAOA,MAAMzN,GAAkB,CAACT,EAAWC,EAAU5Q,IAAY,CAIxD,MAAM5F,EAAQ,IAAI,IACZ6kB,EAAgB,CACpB,SAAA1N,GACA,GAAGvR,CACP,EACQkf,EAAoB,CACxB,GAAGD,EAAc,SACjB,GAAI7kB,CACR,EACE,OAAO+kB,GAAkBxO,EAAWC,EAAU,CAC5C,GAAGqO,EACH,SAAUC,CACd,CAAG,CACH,EChlBME,GAAgB,CAClB,SAAU,WACV,UAAW,MACX,OAAQ,EACR,KAAM,GACN,UAAW,GACX,gBAAiB,CACrB,EACMC,GAAkB,CACpB,OAAQ,gBACR,KAAM,iBACN,IAAK,iBACL,MAAO,gBACX,EACO,SAASC,GAAY3O,EAAWC,EAAU2O,EAAO,CAAA,EAAI,CACxD,GAAI,CAAC3O,GAAY,CAACD,EACd,MAAO,CACH,QAASvL,EACrB,EACI,MAAMpF,EAAU,CAAE,GAAGof,GAAe,GAAGG,CAAI,EACrCC,EAAU5O,EAAS,cAAc,mBAAmB,EACpDU,EAAa,CAAA,EACftR,EAAQ,MACRsR,EAAW,KAAKyC,GAAK,CACjB,SAAU/T,EAAQ,SAClB,QAASA,EAAQ,eACpB,CAAA,CAAC,EAEN,MAAMyf,EAAczZ,GAAcwZ,CAAO,EAAIA,EAAQ,aAAe,EAAI,EACxE,GAAIxf,EAAQ,QAAUA,EAAQ,OAAQ,CAClC,MAAMvE,EAAOuE,EAAQ,OAAS,CAAE,SAAUA,EAAQ,MAAM,EAAKA,EAAQ,QACjEvE,GAAA,YAAAA,EAAM,WAAY,OAClBA,EAAK,UAAYgkB,GAErBnO,EAAW,KAAKuC,GAAOpY,CAAI,CAAC,CAC/B,CACD6V,EAAW,KAAKuE,GAAM,CAClB,SAAU7V,EAAQ,SAClB,UAAWA,EAAQ,QACnB,QAASA,EAAQ,eACpB,CAAA,CAAC,EACEwf,GACAlO,EAAW,KAAKuB,GAAM,CAAE,QAAS2M,EAAS,QAAS,CAAG,CAAA,CAAC,EAE3DlO,EAAW,KAAK9I,GAAK,CACjB,QAASxI,EAAQ,gBACjB,MAAM,CAAE,MAAAgP,EAAO,gBAAA4H,EAAiB,eAAAC,CAAc,EAAI,CAC1C7W,EAAQ,WACR,OAAO,OAAO4Q,EAAS,MAAO,CAC1B,MAAO,GAAG,KAAK,MAAM5B,EAAM,UAAU,KAAK,CAAC,KAC3C,SAAU,OAC9B,CAAiB,EAEDhP,EAAQ,aACR,OAAO,OAAO4Q,EAAS,MAAO,CAC1B,SAAU,GAAGiG,CAAc,KAC3B,UAAW,GAAGD,CAAe,IACjD,CAAiB,CAER,CACJ,CAAA,CAAC,EACF,SAAS8I,GAAU,CACf,GAAI,CAAC/O,GAAa,CAACC,EACf,OACJ,KAAM,CAAE,UAAApC,EAAW,SAAA6C,CAAU,EAAGrR,EAChCoR,GAAgBT,EAAWC,EAAU,CACjC,UAAApC,EACA,WAAA8C,EACA,SAAAD,CACZ,CAAS,EAAE,KAAM5V,GAAS,CACd,MAAMgW,EAAI,KAAK,MAAMhW,EAAK,CAAC,EACrBiW,EAAI,KAAK,MAAMjW,EAAK,CAAC,EAK3B,GAJA,OAAO,OAAOmV,EAAS,MAAO,CAC1B,IAAK,GAAGc,CAAC,KACT,KAAM,GAAGD,CAAC,IAC1B,CAAa,EACGzL,GAAcwZ,CAAO,GAAK/jB,EAAK,eAAe,MAAO,CACrD,KAAM,CAAE,EAAAgW,EAAG,EAAAC,CAAC,EAAKjW,EAAK,eAAe,MAC/BkkB,EAAMlkB,EAAK,UAAU,MAAM,GAAG,EAAE,CAAC,EACvC,OAAO,OAAO+jB,EAAQ,MAAO,CACzB,SAAU,WACV,KAAM/N,GAAK,KAAO,GAAGA,CAAC,KAAO,GAC7B,IAAKC,GAAK,KAAO,GAAGA,CAAC,KAAO,GAC5B,CAACiO,CAAG,EAAG,eAAeF,CAAW,MACjC,UAAWJ,GAAgBM,CAAG,EAC9B,gBAAiB,UACjB,OAAQ,SAC5B,CAAiB,CACJ,CACD,OAAOlkB,CACnB,CAAS,CACJ,CAED,cAAO,OAAOmV,EAAS,MAAO,CAC1B,SAAU5Q,EAAQ,QAC1B,CAAK,EACM,CACH,QAASie,GAAWtN,EAAWC,EAAU8O,CAAO,CACxD,CACA,CCxGA;AAAA;AAAA;AAAA,EASA,IAAIE,GAAqB,CAAC,qBAAsB,sBAAuB,wBAAyB,uBAAwB,sBAAuB,oCAAqC,+BAAgC,+BAAgC,gEAAiE,6CAA8C,sBAAsB,EACrXC,GAAmCD,GAAmB,KAAK,GAAG,EAC9DE,GAAY,OAAO,QAAY,IAC/B5gB,GAAU4gB,GAAY,UAAY,GAAK,QAAQ,UAAU,SAAW,QAAQ,UAAU,mBAAqB,QAAQ,UAAU,sBAC7HC,GAAc,CAACD,IAAa,QAAQ,UAAU,YAAc,SAAU7Z,EAAS,CACjF,IAAI+Z,EACJ,OAAO/Z,GAAY,OAAuC+Z,EAAuB/Z,EAAQ,eAAiB,MAAQ+Z,IAAyB,OAA3F,OAA6GA,EAAqB,KAAK/Z,CAAO,CAChM,EAAI,SAAUA,EAAS,CACrB,OAAOA,GAAY,KAA6B,OAASA,EAAQ,aACnE,EAUIga,GAAU,SAASA,EAAQpe,EAAMqe,EAAQ,CAC3C,IAAIC,EACAD,IAAW,SACbA,EAAS,IAKX,IAAIE,EAAWve,GAAS,OAAoCse,EAAqBte,EAAK,gBAAkB,MAAQse,IAAuB,OAArF,OAAuGA,EAAmB,KAAKte,EAAM,OAAO,EAC1Lwe,EAAQD,IAAa,IAAMA,IAAa,OAOxC9oB,EAAS+oB,GAASH,GAAUre,GAAQoe,EAAQpe,EAAK,UAAU,EAE/D,OAAOvK,CACT,EAOIgpB,GAAoB,SAA2Bze,EAAM,CACvD,IAAI0e,EAIAC,EAAW3e,GAAS,OAAoC0e,EAAsB1e,EAAK,gBAAkB,MAAQ0e,IAAwB,OAAvF,OAAyGA,EAAoB,KAAK1e,EAAM,iBAAiB,EAC3M,OAAO2e,IAAa,IAAMA,IAAa,MACzC,EAQIC,GAAgB,SAAuBhZ,EAAIiZ,EAAkBC,EAAQ,CAGvE,GAAIV,GAAQxY,CAAE,EACZ,MAAO,GAET,IAAImZ,EAAa,MAAM,UAAU,MAAM,MAAMnZ,EAAG,iBAAiBoY,EAAiB,CAAC,EACnF,OAAIa,GAAoBxhB,GAAQ,KAAKuI,EAAIoY,EAAiB,GACxDe,EAAW,QAAQnZ,CAAE,EAEvBmZ,EAAaA,EAAW,OAAOD,CAAM,EAC9BC,CACT,EAoCIC,GAA2B,SAASA,EAAyB1O,EAAUuO,EAAkB1gB,EAAS,CAGpG,QAFI4gB,EAAa,CAAA,EACbE,EAAkB,MAAM,KAAK3O,CAAQ,EAClC2O,EAAgB,QAAQ,CAC7B,IAAI7a,EAAU6a,EAAgB,QAC9B,GAAI,CAAAb,GAAQha,EAAS,EAAK,EAK1B,GAAIA,EAAQ,UAAY,OAAQ,CAE9B,IAAI8a,EAAW9a,EAAQ,mBACnB+a,EAAUD,EAAS,OAASA,EAAW9a,EAAQ,SAC/Cgb,EAAmBJ,EAAyBG,EAAS,GAAMhhB,CAAO,EAClEA,EAAQ,QACV4gB,EAAW,KAAK,MAAMA,EAAYK,CAAgB,EAElDL,EAAW,KAAK,CACd,YAAa3a,EACb,WAAYgb,CACtB,CAAS,CAET,KAAW,CAEL,IAAIC,EAAiBhiB,GAAQ,KAAK+G,EAAS4Z,EAAiB,EACxDqB,GAAkBlhB,EAAQ,OAAOiG,CAAO,IAAMya,GAAoB,CAACvO,EAAS,SAASlM,CAAO,IAC9F2a,EAAW,KAAK3a,CAAO,EAIzB,IAAIkb,EAAalb,EAAQ,YAEzB,OAAOjG,EAAQ,eAAkB,YAAcA,EAAQ,cAAciG,CAAO,EAKxEmb,EAAkB,CAACnB,GAAQkB,EAAY,EAAK,IAAM,CAACnhB,EAAQ,kBAAoBA,EAAQ,iBAAiBiG,CAAO,GACnH,GAAIkb,GAAcC,EAAiB,CAOjC,IAAIC,EAAoBR,EAAyBM,IAAe,GAAOlb,EAAQ,SAAWkb,EAAW,SAAU,GAAMnhB,CAAO,EACxHA,EAAQ,QACV4gB,EAAW,KAAK,MAAMA,EAAYS,CAAiB,EAEnDT,EAAW,KAAK,CACd,YAAa3a,EACb,WAAYob,CACxB,CAAW,CAEX,MAGQP,EAAgB,QAAQ,MAAMA,EAAiB7a,EAAQ,QAAQ,CAElE,CACF,CACD,OAAO2a,CACT,EAQIU,GAAc,SAAqBzf,EAAM,CAC3C,MAAO,CAAC,MAAM,SAASA,EAAK,aAAa,UAAU,EAAG,EAAE,CAAC,CAC3D,EAQI0f,GAAc,SAAqB1f,EAAM,CAC3C,GAAI,CAACA,EACH,MAAM,IAAI,MAAM,kBAAkB,EAEpC,OAAIA,EAAK,SAAW,IAQb,0BAA0B,KAAKA,EAAK,OAAO,GAAKye,GAAkBze,CAAI,IAAM,CAACyf,GAAYzf,CAAI,EACzF,EAGJA,EAAK,QACd,EAUI2f,GAAuB,SAA8B3f,EAAM4f,EAAS,CACtE,IAAIC,EAAWH,GAAY1f,CAAI,EAC/B,OAAI6f,EAAW,GAAKD,GAAW,CAACH,GAAYzf,CAAI,EACvC,EAEF6f,CACT,EACIC,GAAuB,SAA8B/nB,EAAGC,EAAG,CAC7D,OAAOD,EAAE,WAAaC,EAAE,SAAWD,EAAE,cAAgBC,EAAE,cAAgBD,EAAE,SAAWC,EAAE,QACxF,EACI+nB,GAAU,SAAiB/f,EAAM,CACnC,OAAOA,EAAK,UAAY,OAC1B,EACIggB,GAAgB,SAAuBhgB,EAAM,CAC/C,OAAO+f,GAAQ/f,CAAI,GAAKA,EAAK,OAAS,QACxC,EACIigB,GAAuB,SAA8BjgB,EAAM,CAC7D,IAAIkgB,EAAIlgB,EAAK,UAAY,WAAa,MAAM,UAAU,MAAM,MAAMA,EAAK,QAAQ,EAAE,KAAK,SAAUiB,EAAO,CACrG,OAAOA,EAAM,UAAY,SAC7B,CAAG,EACD,OAAOif,CACT,EACIC,GAAkB,SAAyBC,EAAOC,EAAM,CAC1D,QAAS7rB,EAAI,EAAGA,EAAI4rB,EAAM,OAAQ5rB,IAChC,GAAI4rB,EAAM5rB,CAAC,EAAE,SAAW4rB,EAAM5rB,CAAC,EAAE,OAAS6rB,EACxC,OAAOD,EAAM5rB,CAAC,CAGpB,EACI8rB,GAAkB,SAAyBtgB,EAAM,CACnD,GAAI,CAACA,EAAK,KACR,MAAO,GAET,IAAIugB,EAAavgB,EAAK,MAAQke,GAAYle,CAAI,EAC1CwgB,EAAc,SAAqBjqB,EAAM,CAC3C,OAAOgqB,EAAW,iBAAiB,6BAA+BhqB,EAAO,IAAI,CACjF,EACMkqB,EACJ,GAAI,OAAO,OAAW,KAAe,OAAO,OAAO,IAAQ,KAAe,OAAO,OAAO,IAAI,QAAW,WACrGA,EAAWD,EAAY,OAAO,IAAI,OAAOxgB,EAAK,IAAI,CAAC,MAEnD,IAAI,CACFygB,EAAWD,EAAYxgB,EAAK,IAAI,CACjC,OAAQ0gB,EAAK,CAEZ,eAAQ,MAAM,2IAA4IA,EAAI,OAAO,EAC9J,EACR,CAEH,IAAIC,EAAUR,GAAgBM,EAAUzgB,EAAK,IAAI,EACjD,MAAO,CAAC2gB,GAAWA,IAAY3gB,CACjC,EACI4gB,GAAU,SAAiB5gB,EAAM,CACnC,OAAO+f,GAAQ/f,CAAI,GAAKA,EAAK,OAAS,OACxC,EACI6gB,GAAqB,SAA4B7gB,EAAM,CACzD,OAAO4gB,GAAQ5gB,CAAI,GAAK,CAACsgB,GAAgBtgB,CAAI,CAC/C,EAGI8gB,GAAiB,SAAwB9gB,EAAM,CACjD,IAAI+gB,EAwBAC,EAAWhhB,GAAQke,GAAYle,CAAI,EACnCihB,GAAgBF,EAAYC,KAAc,MAAQD,IAAc,OAAS,OAASA,EAAU,KAI5FG,EAAW,GACf,GAAIF,GAAYA,IAAahhB,EAAM,CACjC,IAAImhB,EAAeC,EAAuBzL,EAE1C,IADAuL,EAAW,CAAC,GAAGC,EAAgBF,KAAkB,MAAQE,IAAkB,SAAWC,EAAwBD,EAAc,iBAAmB,MAAQC,IAA0B,QAAUA,EAAsB,SAASH,CAAY,GAAKjhB,GAAS,OAA4B2V,EAAsB3V,EAAK,iBAAmB,MAAQ2V,IAAwB,QAAUA,EAAoB,SAAS3V,CAAI,GAClY,CAACkhB,GAAYD,GAAc,CAChC,IAAII,EAAYC,EAAgBC,EAIhCP,EAAW9C,GAAY+C,CAAY,EACnCA,GAAgBI,EAAaL,KAAc,MAAQK,IAAe,OAAS,OAASA,EAAW,KAC/FH,EAAW,CAAC,GAAGI,EAAiBL,KAAkB,MAAQK,IAAmB,SAAWC,EAAwBD,EAAe,iBAAmB,MAAQC,IAA0B,QAAUA,EAAsB,SAASN,CAAY,EAC1O,CACF,CACD,OAAOC,CACT,EACIM,GAAa,SAAoBxhB,EAAM,CACzC,IAAIyhB,EAAwBzhB,EAAK,sBAAuB,EACtDwU,EAAQiN,EAAsB,MAC9BhN,EAASgN,EAAsB,OACjC,OAAOjN,IAAU,GAAKC,IAAW,CACnC,EACIiN,GAAW,SAAkB1hB,EAAM6O,EAAM,CAC3C,IAAI8S,EAAe9S,EAAK,aACtB+S,EAAgB/S,EAAK,cAMvB,GAAI,iBAAiB7O,CAAI,EAAE,aAAe,SACxC,MAAO,GAET,IAAI6hB,EAAkBxkB,GAAQ,KAAK2C,EAAM,+BAA+B,EACpE8hB,EAAmBD,EAAkB7hB,EAAK,cAAgBA,EAC9D,GAAI3C,GAAQ,KAAKykB,EAAkB,uBAAuB,EACxD,MAAO,GAET,GAAI,CAACH,GAAgBA,IAAiB,QAAUA,IAAiB,cAAe,CAC9E,GAAI,OAAOC,GAAkB,WAAY,CAIvC,QADIG,EAAe/hB,EACZA,GAAM,CACX,IAAIgiB,EAAgBhiB,EAAK,cACrBiiB,EAAW/D,GAAYle,CAAI,EAC/B,GAAIgiB,GAAiB,CAACA,EAAc,YAAcJ,EAAcI,CAAa,IAAM,GAIjF,OAAOR,GAAWxhB,CAAI,EACbA,EAAK,aAEdA,EAAOA,EAAK,aACH,CAACgiB,GAAiBC,IAAajiB,EAAK,cAE7CA,EAAOiiB,EAAS,KAGhBjiB,EAAOgiB,CAEV,CACDhiB,EAAO+hB,CACR,CAWD,GAAIjB,GAAe9gB,CAAI,EAKrB,MAAO,CAACA,EAAK,eAAgB,EAAC,OAmBhC,GAAI2hB,IAAiB,cACnB,MAAO,EAGb,SAAaA,IAAiB,gBAM1B,OAAOH,GAAWxhB,CAAI,EAKxB,MAAO,EACT,EAKIkiB,GAAyB,SAAgCliB,EAAM,CACjE,GAAI,mCAAmC,KAAKA,EAAK,OAAO,EAGtD,QAFI+W,EAAa/W,EAAK,cAEf+W,GAAY,CACjB,GAAIA,EAAW,UAAY,YAAcA,EAAW,SAAU,CAE5D,QAASviB,EAAI,EAAGA,EAAIuiB,EAAW,SAAS,OAAQviB,IAAK,CACnD,IAAIyM,EAAQ8V,EAAW,SAAS,KAAKviB,CAAC,EAEtC,GAAIyM,EAAM,UAAY,SAGpB,OAAO5D,GAAQ,KAAK0Z,EAAY,sBAAsB,EAAI,GAAO,CAAC9V,EAAM,SAASjB,CAAI,CAExF,CAED,MAAO,EACR,CACD+W,EAAaA,EAAW,aACzB,CAKH,MAAO,EACT,EACIoL,GAAkC,SAAyChkB,EAAS6B,EAAM,CAC5F,MAAI,EAAAA,EAAK,UAIToe,GAAQpe,CAAI,GAAKggB,GAAchgB,CAAI,GAAK0hB,GAAS1hB,EAAM7B,CAAO,GAE9D8hB,GAAqBjgB,CAAI,GAAKkiB,GAAuBliB,CAAI,EAI3D,EACIoiB,GAAiC,SAAwCjkB,EAAS6B,EAAM,CAC1F,MAAI,EAAA6gB,GAAmB7gB,CAAI,GAAK0f,GAAY1f,CAAI,EAAI,GAAK,CAACmiB,GAAgChkB,EAAS6B,CAAI,EAIzG,EACIqiB,GAA4B,SAAmCC,EAAgB,CACjF,IAAIzC,EAAW,SAASyC,EAAe,aAAa,UAAU,EAAG,EAAE,EACnE,MAAI,SAAMzC,CAAQ,GAAKA,GAAY,EAMrC,EAMI0C,GAAc,SAASA,EAAYxD,EAAY,CACjD,IAAIyD,EAAmB,CAAA,EACnBC,EAAmB,CAAA,EACvB,OAAA1D,EAAW,QAAQ,SAAU9lB,EAAMzE,EAAG,CACpC,IAAIorB,EAAU,CAAC,CAAC3mB,EAAK,YACjBmL,EAAUwb,EAAU3mB,EAAK,YAAcA,EACvCypB,EAAoB/C,GAAqBvb,EAASwb,CAAO,EACzDtP,EAAWsP,EAAU2C,EAAYtpB,EAAK,UAAU,EAAImL,EACpDse,IAAsB,EACxB9C,EAAU4C,EAAiB,KAAK,MAAMA,EAAkBlS,CAAQ,EAAIkS,EAAiB,KAAKpe,CAAO,EAEjGqe,EAAiB,KAAK,CACpB,cAAejuB,EACf,SAAUkuB,EACV,KAAMzpB,EACN,QAAS2mB,EACT,QAAStP,CACjB,CAAO,CAEP,CAAG,EACMmS,EAAiB,KAAK3C,EAAoB,EAAE,OAAO,SAAUtM,EAAKmP,EAAU,CACjF,OAAAA,EAAS,QAAUnP,EAAI,KAAK,MAAMA,EAAKmP,EAAS,OAAO,EAAInP,EAAI,KAAKmP,EAAS,OAAO,EAC7EnP,CACR,EAAE,EAAE,EAAE,OAAOgP,CAAgB,CAChC,EACII,GAAW,SAAkBC,EAAW1kB,EAAS,CACnDA,EAAUA,GAAW,GACrB,IAAI4gB,EACJ,OAAI5gB,EAAQ,cACV4gB,EAAaC,GAAyB,CAAC6D,CAAS,EAAG1kB,EAAQ,iBAAkB,CAC3E,OAAQikB,GAA+B,KAAK,KAAMjkB,CAAO,EACzD,QAAS,GACT,cAAeA,EAAQ,cACvB,iBAAkBkkB,EACxB,CAAK,EAEDtD,EAAaH,GAAciE,EAAW1kB,EAAQ,iBAAkBikB,GAA+B,KAAK,KAAMjkB,CAAO,CAAC,EAE7GokB,GAAYxD,CAAU,CAC/B,EACI+D,GAAY,SAAmBD,EAAW1kB,EAAS,CACrDA,EAAUA,GAAW,GACrB,IAAI4gB,EACJ,OAAI5gB,EAAQ,cACV4gB,EAAaC,GAAyB,CAAC6D,CAAS,EAAG1kB,EAAQ,iBAAkB,CAC3E,OAAQgkB,GAAgC,KAAK,KAAMhkB,CAAO,EAC1D,QAAS,GACT,cAAeA,EAAQ,aAC7B,CAAK,EAED4gB,EAAaH,GAAciE,EAAW1kB,EAAQ,iBAAkBgkB,GAAgC,KAAK,KAAMhkB,CAAO,CAAC,EAE9G4gB,CACT,EACIgE,GAAa,SAAoB/iB,EAAM7B,EAAS,CAElD,GADAA,EAAUA,GAAW,GACjB,CAAC6B,EACH,MAAM,IAAI,MAAM,kBAAkB,EAEpC,OAAI3C,GAAQ,KAAK2C,EAAMge,EAAiB,IAAM,GACrC,GAEFoE,GAA+BjkB,EAAS6B,CAAI,CACrD,EACIgjB,GAA4CjF,GAAmB,OAAO,QAAQ,EAAE,KAAK,GAAG,EACxFkF,GAAc,SAAqBjjB,EAAM7B,EAAS,CAEpD,GADAA,EAAUA,GAAW,GACjB,CAAC6B,EACH,MAAM,IAAI,MAAM,kBAAkB,EAEpC,OAAI3C,GAAQ,KAAK2C,EAAMgjB,EAA0B,IAAM,GAC9C,GAEFb,GAAgChkB,EAAS6B,CAAI,CACtD,ECvjBA;AAAA;AAAA;AAAA,EAMA,SAASkjB,GAAQC,EAAQC,EAAgB,CACvC,IAAIzsB,EAAO,OAAO,KAAKwsB,CAAM,EAC7B,GAAI,OAAO,sBAAuB,CAChC,IAAIE,EAAU,OAAO,sBAAsBF,CAAM,EACjDC,IAAmBC,EAAUA,EAAQ,OAAO,SAAUC,EAAK,CACzD,OAAO,OAAO,yBAAyBH,EAAQG,CAAG,EAAE,UAC1D,CAAK,GAAI3sB,EAAK,KAAK,MAAMA,EAAM0sB,CAAO,CACnC,CACD,OAAO1sB,CACT,CACA,SAAS4sB,GAAe5gB,EAAQ,CAC9B,QAASnO,EAAI,EAAGA,EAAI,UAAU,OAAQA,IAAK,CACzC,IAAIgvB,EAAiB,UAAUhvB,CAAC,GAAnB,KAAuB,UAAUA,CAAC,EAAI,GACnDA,EAAI,EAAI0uB,GAAQ,OAAOM,CAAM,EAAG,EAAE,EAAE,QAAQ,SAAU9uB,EAAK,CACzD+uB,GAAgB9gB,EAAQjO,EAAK8uB,EAAO9uB,CAAG,CAAC,CAC9C,CAAK,EAAI,OAAO,0BAA4B,OAAO,iBAAiBiO,EAAQ,OAAO,0BAA0B6gB,CAAM,CAAC,EAAIN,GAAQ,OAAOM,CAAM,CAAC,EAAE,QAAQ,SAAU9uB,EAAK,CACjK,OAAO,eAAeiO,EAAQjO,EAAK,OAAO,yBAAyB8uB,EAAQ9uB,CAAG,CAAC,CACrF,CAAK,CACF,CACD,OAAOiO,CACT,CACA,SAAS8gB,GAAgB5sB,EAAKnC,EAAKW,EAAO,CACxC,OAAAX,EAAMgvB,GAAehvB,CAAG,EACpBA,KAAOmC,EACT,OAAO,eAAeA,EAAKnC,EAAK,CAC9B,MAAOW,EACP,WAAY,GACZ,aAAc,GACd,SAAU,EAChB,CAAK,EAEDwB,EAAInC,CAAG,EAAIW,EAENwB,CACT,CACA,SAAS8sB,GAAaC,EAAOC,EAAM,CACjC,GAAI,OAAOD,GAAU,UAAYA,IAAU,KAAM,OAAOA,EACxD,IAAIE,EAAOF,EAAM,OAAO,WAAW,EACnC,GAAIE,IAAS,OAAW,CACtB,IAAI9iB,EAAM8iB,EAAK,KAAKF,EAAOC,GAAQ,SAAS,EAC5C,GAAI,OAAO7iB,GAAQ,SAAU,OAAOA,EACpC,MAAM,IAAI,UAAU,8CAA8C,CACnE,CACD,OAAQ6iB,IAAS,SAAW,OAAS,QAAQD,CAAK,CACpD,CACA,SAASF,GAAeK,EAAK,CAC3B,IAAIrvB,EAAMivB,GAAaI,EAAK,QAAQ,EACpC,OAAO,OAAOrvB,GAAQ,SAAWA,EAAM,OAAOA,CAAG,CACnD,CAEA,IAAIsvB,GAAmB,CACrB,aAAc,SAAsBC,EAAWC,EAAM,CACnD,GAAID,EAAU,OAAS,EAAG,CACxB,IAAIE,EAAaF,EAAUA,EAAU,OAAS,CAAC,EAC3CE,IAAeD,GACjBC,EAAW,MAAK,CAEnB,CACD,IAAIC,EAAYH,EAAU,QAAQC,CAAI,EAClCE,IAAc,IAIhBH,EAAU,OAAOG,EAAW,CAAC,EAC7BH,EAAU,KAAKC,CAAI,CAEtB,EACD,eAAgB,SAAwBD,EAAWC,EAAM,CACvD,IAAIE,EAAYH,EAAU,QAAQC,CAAI,EAClCE,IAAc,IAChBH,EAAU,OAAOG,EAAW,CAAC,EAE3BH,EAAU,OAAS,GACrBA,EAAUA,EAAU,OAAS,CAAC,EAAE,QAAO,CAE1C,CACH,EACII,GAAoB,SAA2BrkB,EAAM,CACvD,OAAOA,EAAK,SAAWA,EAAK,QAAQ,gBAAkB,SAAW,OAAOA,EAAK,QAAW,UAC1F,EACIskB,GAAgB,SAAuB,EAAG,CAC5C,OAAQ,GAAM,KAAuB,OAAS,EAAE,OAAS,WAAa,GAAM,KAAuB,OAAS,EAAE,OAAS,QAAU,GAAM,KAAuB,OAAS,EAAE,WAAa,EACxL,EACIC,GAAa,SAAoB,EAAG,CACtC,OAAQ,GAAM,KAAuB,OAAS,EAAE,OAAS,QAAU,GAAM,KAAuB,OAAS,EAAE,WAAa,CAC1H,EAGIC,GAAe,SAAsB,EAAG,CAC1C,OAAOD,GAAW,CAAC,GAAK,CAAC,EAAE,QAC7B,EAGIE,GAAgB,SAAuB,EAAG,CAC5C,OAAOF,GAAW,CAAC,GAAK,EAAE,QAC5B,EACIG,GAAQ,SAAe3hB,EAAI,CAC7B,OAAO,WAAWA,EAAI,CAAC,CACzB,EAII4hB,GAAY,SAAmBltB,EAAKsL,EAAI,CAC1C,IAAIjK,EAAM,GACV,OAAArB,EAAI,MAAM,SAAUpC,EAAOb,EAAG,CAC5B,OAAIuO,EAAG1N,CAAK,GACVyD,EAAMtE,EACC,IAGF,EACX,CAAG,EAEMsE,CACT,EASI8rB,GAAiB,SAAwBvvB,EAAO,CAClD,QAASwvB,EAAO,UAAU,OAAQ/Y,EAAS,IAAI,MAAM+Y,EAAO,EAAIA,EAAO,EAAI,CAAC,EAAGC,EAAO,EAAGA,EAAOD,EAAMC,IACpGhZ,EAAOgZ,EAAO,CAAC,EAAI,UAAUA,CAAI,EAEnC,OAAO,OAAOzvB,GAAU,WAAaA,EAAM,MAAM,OAAQyW,CAAM,EAAIzW,CACrE,EACI0vB,GAAkB,SAAyBjgB,EAAO,CAQpD,OAAOA,EAAM,OAAO,YAAc,OAAOA,EAAM,cAAiB,WAAaA,EAAM,aAAc,EAAC,CAAC,EAAIA,EAAM,MAC/G,EAIIkgB,GAAoB,CAAA,EACpBC,GAAkB,SAAyB3U,EAAU4U,EAAa,CAGpE,IAAInsB,GAAOmsB,GAAgB,KAAiC,OAASA,EAAY,WAAa,SAC1FjB,GAAaiB,GAAgB,KAAiC,OAASA,EAAY,YAAcF,GACjGxZ,EAAS+X,GAAe,CAC1B,wBAAyB,GACzB,kBAAmB,GACnB,kBAAmB,GACnB,aAAciB,GACd,cAAeC,EAChB,EAAES,CAAW,EACVza,EAAQ,CAGV,WAAY,CAAE,EAiBd,gBAAiB,CAAE,EAOnB,eAAgB,CAAE,EAClB,4BAA6B,KAC7B,wBAAyB,KACzB,OAAQ,GACR,OAAQ,GAGR,uBAAwB,OAExB,eAAgB,MACpB,EACMyZ,EAUAiB,EAAY,SAAmBC,EAAuBC,EAAYC,EAAkB,CACtF,OAAOF,GAAyBA,EAAsBC,CAAU,IAAM,OAAYD,EAAsBC,CAAU,EAAI7Z,EAAO8Z,GAAoBD,CAAU,CAC/J,EAYME,EAAqB,SAA4BnhB,EAASU,EAAO,CACnE,IAAI6G,EAAe,OAAQ7G,GAAU,KAA2B,OAASA,EAAM,eAAkB,WAAaA,EAAM,aAAc,EAAG,OAIrI,OAAO2F,EAAM,gBAAgB,UAAU,SAAUoE,EAAM,CACrD,IAAIgU,EAAYhU,EAAK,UACnB2W,EAAgB3W,EAAK,cACvB,OAAOgU,EAAU,SAASze,CAAO,IAIjCuH,GAAiB,KAAkC,OAASA,EAAa,SAASkX,CAAS,IAAM2C,EAAc,KAAK,SAAUxlB,EAAM,CAClI,OAAOA,IAASoE,CACxB,CAAO,CACP,CAAK,CACL,EAeMqhB,EAAmB,SAA0BJ,EAAY,CAC3D,IAAIK,EAAcla,EAAO6Z,CAAU,EACnC,GAAI,OAAOK,GAAgB,WAAY,CACrC,QAASC,EAAQ,UAAU,OAAQ7Z,EAAS,IAAI,MAAM6Z,EAAQ,EAAIA,EAAQ,EAAI,CAAC,EAAGC,EAAQ,EAAGA,EAAQD,EAAOC,IAC1G9Z,EAAO8Z,EAAQ,CAAC,EAAI,UAAUA,CAAK,EAErCF,EAAcA,EAAY,MAAM,OAAQ5Z,CAAM,CAC/C,CAKD,GAJI4Z,IAAgB,KAClBA,EAAc,QAGZ,CAACA,EAAa,CAChB,GAAIA,IAAgB,QAAaA,IAAgB,GAC/C,OAAOA,EAIT,MAAM,IAAI,MAAM,IAAI,OAAOL,EAAY,8DAA8D,CAAC,CACvG,CACD,IAAIrlB,EAAO0lB,EAEX,GAAI,OAAOA,GAAgB,WACzB1lB,EAAOjH,EAAI,cAAc2sB,CAAW,EAChC,CAAC1lB,GACH,MAAM,IAAI,MAAM,IAAI,OAAOqlB,EAAY,uCAAuC,CAAC,EAGnF,OAAOrlB,CACX,EACM6lB,EAAsB,UAA+B,CACvD,IAAI7lB,EAAOylB,EAAiB,cAAc,EAG1C,GAAIzlB,IAAS,GACX,MAAO,GAET,GAAIA,IAAS,QAAa,CAACijB,GAAYjjB,EAAMwL,EAAO,eAAe,EAEjE,GAAI+Z,EAAmBxsB,EAAI,aAAa,GAAK,EAC3CiH,EAAOjH,EAAI,kBACN,CACL,IAAI+sB,EAAqBrb,EAAM,eAAe,CAAC,EAC3Csb,EAAoBD,GAAsBA,EAAmB,kBAGjE9lB,EAAO+lB,GAAqBN,EAAiB,eAAe,CAC7D,CAEH,GAAI,CAACzlB,EACH,MAAM,IAAI,MAAM,8DAA8D,EAEhF,OAAOA,CACX,EACMgmB,EAAsB,UAA+B,CA4EvD,GA3EAvb,EAAM,gBAAkBA,EAAM,WAAW,IAAI,SAAUoY,EAAW,CAChE,IAAI2C,EAAgB5C,GAASC,EAAWrX,EAAO,eAAe,EAK1Dya,EAAiBnD,GAAUD,EAAWrX,EAAO,eAAe,EAC5Dua,EAAoBP,EAAc,OAAS,EAAIA,EAAc,CAAC,EAAI,OAClEU,EAAmBV,EAAc,OAAS,EAAIA,EAAcA,EAAc,OAAS,CAAC,EAAI,OACxFW,EAAuBF,EAAe,KAAK,SAAUjmB,EAAM,CAC7D,OAAO+iB,GAAW/iB,CAAI,CAC9B,CAAO,EACGomB,EAAsBH,EAAe,MAAK,EAAG,UAAU,KAAK,SAAUjmB,EAAM,CAC9E,OAAO+iB,GAAW/iB,CAAI,CAC9B,CAAO,EACGqmB,EAAqB,CAAC,CAACb,EAAc,KAAK,SAAUxlB,EAAM,CAC5D,OAAO0f,GAAY1f,CAAI,EAAI,CACnC,CAAO,EACD,MAAO,CACL,UAAW6iB,EACX,cAAe2C,EACf,eAAgBS,EAEhB,mBAAoBI,EAEpB,kBAAmBN,EAEnB,iBAAkBG,EASlB,qBAAsBC,EAEtB,oBAAqBC,EASrB,iBAAkB,SAA0BpmB,GAAM,CAChD,IAAIkC,EAAU,UAAU,OAAS,GAAK,UAAU,CAAC,IAAM,OAAY,UAAU,CAAC,EAAI,GAC9EokB,EAAUd,EAAc,QAAQxlB,EAAI,EACxC,OAAIsmB,EAAU,EAORpkB,EACK+jB,EAAe,MAAMA,EAAe,QAAQjmB,EAAI,EAAI,CAAC,EAAE,KAAK,SAAU4F,EAAI,CAC/E,OAAOmd,GAAWnd,CAAE,CACpC,CAAe,EAEIqgB,EAAe,MAAM,EAAGA,EAAe,QAAQjmB,EAAI,CAAC,EAAE,QAAO,EAAG,KAAK,SAAU4F,EAAI,CACxF,OAAOmd,GAAWnd,CAAE,CAClC,CAAa,EAEI4f,EAAcc,GAAWpkB,EAAU,EAAI,GAAG,CAClD,CACT,CACA,CAAK,EACDuI,EAAM,eAAiBA,EAAM,gBAAgB,OAAO,SAAU8b,EAAO,CACnE,OAAOA,EAAM,cAAc,OAAS,CAC1C,CAAK,EAGG9b,EAAM,eAAe,QAAU,GAAK,CAACgb,EAAiB,eAAe,EAEvE,MAAM,IAAI,MAAM,qGAAqG,EAUvH,GAAIhb,EAAM,gBAAgB,KAAK,SAAU+b,EAAG,CAC1C,OAAOA,EAAE,kBACV,CAAA,GAAK/b,EAAM,gBAAgB,OAAS,EACnC,MAAM,IAAI,MAAM,+KAA+K,CAErM,EACMgc,EAAW,SAASA,EAASzmB,EAAM,CACrC,GAAIA,IAAS,IAGTA,IAASjH,EAAI,cAGjB,IAAI,CAACiH,GAAQ,CAACA,EAAK,MAAO,CACxBymB,EAASZ,EAAmB,CAAE,EAC9B,MACD,CACD7lB,EAAK,MAAM,CACT,cAAe,CAAC,CAACwL,EAAO,aAC9B,CAAK,EAEDf,EAAM,wBAA0BzK,EAC5BqkB,GAAkBrkB,CAAI,GACxBA,EAAK,OAAM,EAEjB,EACM0mB,EAAqB,SAA4BC,EAAuB,CAC1E,IAAI3mB,EAAOylB,EAAiB,iBAAkBkB,CAAqB,EACnE,OAAO3mB,IAAcA,IAAS,GAAQ,GAAQ2mB,EAClD,EAaMC,EAAkB,SAAyBC,EAAO,CACpD,IAAIlkB,EAASkkB,EAAM,OACjB/hB,EAAQ+hB,EAAM,MACdC,EAAmBD,EAAM,WACzBE,EAAaD,IAAqB,OAAS,GAAQA,EACrDnkB,EAASA,GAAUoiB,GAAgBjgB,CAAK,EACxCkhB,IACA,IAAIgB,EAAkB,KACtB,GAAIvc,EAAM,eAAe,OAAS,EAAG,CAInC,IAAIwc,EAAiB1B,EAAmB5iB,EAAQmC,CAAK,EACjDoiB,EAAiBD,GAAkB,EAAIxc,EAAM,gBAAgBwc,CAAc,EAAI,OACnF,GAAIA,EAAiB,EAGfF,EAEFC,EAAkBvc,EAAM,eAAeA,EAAM,eAAe,OAAS,CAAC,EAAE,iBAGxEuc,EAAkBvc,EAAM,eAAe,CAAC,EAAE,0BAEnCsc,EAAY,CAIrB,IAAII,EAAoBxC,GAAUla,EAAM,eAAgB,SAAU2c,EAAO,CACvE,IAAIrB,EAAoBqB,EAAM,kBAC9B,OAAOzkB,IAAWojB,CAC5B,CAAS,EAUD,GATIoB,EAAoB,IAAMD,EAAe,YAAcvkB,GAAUsgB,GAAYtgB,EAAQ6I,EAAO,eAAe,GAAK,CAACuX,GAAWpgB,EAAQ6I,EAAO,eAAe,GAAK,CAAC0b,EAAe,iBAAiBvkB,EAAQ,EAAK,KAO/MwkB,EAAoBF,GAElBE,GAAqB,EAAG,CAI1B,IAAIE,GAAwBF,IAAsB,EAAI1c,EAAM,eAAe,OAAS,EAAI0c,EAAoB,EACxGG,EAAmB7c,EAAM,eAAe4c,EAAqB,EACjEL,EAAkBtH,GAAY/c,CAAM,GAAK,EAAI2kB,EAAiB,iBAAmBA,EAAiB,mBAC5G,MAAoB/C,GAAWzf,CAAK,IAG1BkiB,EAAkBE,EAAe,iBAAiBvkB,EAAQ,EAAK,EAEzE,KAAa,CAIL,IAAI4kB,EAAmB5C,GAAUla,EAAM,eAAgB,SAAU+c,EAAO,CACtE,IAAItB,EAAmBsB,EAAM,iBAC7B,OAAO7kB,IAAWujB,CAC5B,CAAS,EAUD,GATIqB,EAAmB,IAAML,EAAe,YAAcvkB,GAAUsgB,GAAYtgB,EAAQ6I,EAAO,eAAe,GAAK,CAACuX,GAAWpgB,EAAQ6I,EAAO,eAAe,GAAK,CAAC0b,EAAe,iBAAiBvkB,CAAM,KAOvM4kB,EAAmBN,GAEjBM,GAAoB,EAAG,CAIzB,IAAIE,EAAyBF,IAAqB9c,EAAM,eAAe,OAAS,EAAI,EAAI8c,EAAmB,EACvGG,EAAoBjd,EAAM,eAAegd,CAAsB,EACnET,EAAkBtH,GAAY/c,CAAM,GAAK,EAAI+kB,EAAkB,kBAAoBA,EAAkB,oBAC/G,MAAoBnD,GAAWzf,CAAK,IAG1BkiB,EAAkBE,EAAe,iBAAiBvkB,CAAM,EAE3D,CACP,MAGMqkB,EAAkBvB,EAAiB,eAAe,EAEpD,OAAOuB,CACX,EAIMW,EAAmB,SAA0Bjc,EAAG,CAClD,IAAI/I,EAASoiB,GAAgBrZ,CAAC,EAC9B,GAAI,EAAA6Z,EAAmB5iB,EAAQ+I,CAAC,GAAK,GAIrC,IAAIkZ,GAAepZ,EAAO,wBAAyBE,CAAC,EAAG,CAErDwY,EAAK,WAAW,CAOd,YAAa1Y,EAAO,uBAC5B,CAAO,EACD,MACD,CAKGoZ,GAAepZ,EAAO,kBAAmBE,CAAC,GAM9CA,EAAE,eAAc,EACpB,EAMMkc,EAAe,SAAsB9iB,EAAO,CAC9C,IAAInC,EAASoiB,GAAgBjgB,CAAK,EAC9B+iB,EAAkBtC,EAAmB5iB,EAAQmC,CAAK,GAAK,EAG3D,GAAI+iB,GAAmBllB,aAAkB,SACnCklB,IACFpd,EAAM,wBAA0B9H,OAE7B,CAELmC,EAAM,yBAAwB,EAK9B,IAAIgjB,EACAC,EAAsB,GAC1B,GAAItd,EAAM,wBACR,GAAIiV,GAAYjV,EAAM,uBAAuB,EAAI,EAAG,CAElD,IAAIud,EAAkBzC,EAAmB9a,EAAM,uBAAuB,EAKlE+a,EAAgB/a,EAAM,gBAAgBud,CAAe,EAAE,cAC3D,GAAIxC,EAAc,OAAS,EAAG,CAE5B,IAAIyC,EAAYzC,EAAc,UAAU,SAAUxlB,EAAM,CACtD,OAAOA,IAASyK,EAAM,uBACpC,CAAa,EACGwd,GAAa,IACXzc,EAAO,aAAaf,EAAM,cAAc,EACtCwd,EAAY,EAAIzC,EAAc,SAChCsC,EAAWtC,EAAcyC,EAAY,CAAC,EACtCF,EAAsB,IAKpBE,EAAY,GAAK,IACnBH,EAAWtC,EAAcyC,EAAY,CAAC,EACtCF,EAAsB,IAO7B,CAKX,MAKetd,EAAM,gBAAgB,KAAK,SAAU+b,EAAG,CAC3C,OAAOA,EAAE,cAAc,KAAK,SAAU/xB,GAAG,CACvC,OAAOirB,GAAYjrB,EAAC,EAAI,CACtC,CAAa,CACb,CAAW,IAICszB,EAAsB,SAQ1BA,EAAsB,GAEpBA,IACFD,EAAWlB,EAAgB,CAGzB,OAAQnc,EAAM,wBACd,WAAYe,EAAO,cAAcf,EAAM,cAAc,CAC/D,CAAS,GAGDgc,EADEqB,GAGOrd,EAAM,yBAA2Bob,EAAqB,CAF9C,CAIpB,CACDpb,EAAM,eAAiB,MAC3B,EAMMyd,EAAc,SAAqBpjB,EAAO,CAC5C,IAAIiiB,EAAa,UAAU,OAAS,GAAK,UAAU,CAAC,IAAM,OAAY,UAAU,CAAC,EAAI,GACrFtc,EAAM,eAAiB3F,EACvB,IAAIkiB,EAAkBJ,EAAgB,CACpC,MAAO9hB,EACP,WAAYiiB,CAClB,CAAK,EACGC,IACEzC,GAAWzf,CAAK,GAKlBA,EAAM,eAAc,EAEtB2hB,EAASO,CAAe,EAG9B,EAEMmB,EAAW,SAAkBrjB,EAAO,CACtC,GAAIwf,GAAcxf,CAAK,GAAK8f,GAAepZ,EAAO,kBAAmB1G,CAAK,IAAM,GAAO,CACrFA,EAAM,eAAc,EACpBof,EAAK,WAAU,EACf,MACD,EACG1Y,EAAO,aAAa1G,CAAK,GAAK0G,EAAO,cAAc1G,CAAK,IAC1DojB,EAAYpjB,EAAO0G,EAAO,cAAc1G,CAAK,CAAC,CAEpD,EACMsjB,EAAa,SAAoB1c,EAAG,CACtC,IAAI/I,EAASoiB,GAAgBrZ,CAAC,EAC1B6Z,EAAmB5iB,EAAQ+I,CAAC,GAAK,GAGjCkZ,GAAepZ,EAAO,wBAAyBE,CAAC,GAGhDkZ,GAAepZ,EAAO,kBAAmBE,CAAC,IAG9CA,EAAE,eAAc,EAChBA,EAAE,yBAAwB,EAC9B,EAMM2c,EAAe,UAAwB,CACzC,GAAK5d,EAAM,OAKX,OAAAuZ,GAAiB,aAAaC,EAAWC,CAAI,EAI7CzZ,EAAM,uBAAyBe,EAAO,kBAAoBkZ,GAAM,UAAY,CAC1E+B,EAASZ,EAAmB,CAAE,CACpC,CAAK,EAAIY,EAASZ,EAAmB,CAAE,EACnC9sB,EAAI,iBAAiB,UAAW6uB,EAAc,EAAI,EAClD7uB,EAAI,iBAAiB,YAAa4uB,EAAkB,CAClD,QAAS,GACT,QAAS,EACf,CAAK,EACD5uB,EAAI,iBAAiB,aAAc4uB,EAAkB,CACnD,QAAS,GACT,QAAS,EACf,CAAK,EACD5uB,EAAI,iBAAiB,QAASqvB,EAAY,CACxC,QAAS,GACT,QAAS,EACf,CAAK,EACDrvB,EAAI,iBAAiB,UAAWovB,EAAU,CACxC,QAAS,GACT,QAAS,EACf,CAAK,EACMjE,CACX,EACMoE,EAAkB,UAA2B,CAC/C,GAAK7d,EAAM,OAGX,OAAA1R,EAAI,oBAAoB,UAAW6uB,EAAc,EAAI,EACrD7uB,EAAI,oBAAoB,YAAa4uB,EAAkB,EAAI,EAC3D5uB,EAAI,oBAAoB,aAAc4uB,EAAkB,EAAI,EAC5D5uB,EAAI,oBAAoB,QAASqvB,EAAY,EAAI,EACjDrvB,EAAI,oBAAoB,UAAWovB,EAAU,EAAI,EAC1CjE,CACX,EAMMqE,EAAkB,SAAyBC,EAAW,CACxD,IAAIC,EAAuBD,EAAU,KAAK,SAAUE,EAAU,CAC5D,IAAIC,EAAe,MAAM,KAAKD,EAAS,YAAY,EACnD,OAAOC,EAAa,KAAK,SAAU3oB,EAAM,CACvC,OAAOA,IAASyK,EAAM,uBAC9B,CAAO,CACP,CAAK,EAIGge,GACFhC,EAASZ,EAAmB,CAAE,CAEpC,EAIM+C,EAAmB,OAAO,OAAW,KAAe,qBAAsB,OAAS,IAAI,iBAAiBL,CAAe,EAAI,OAC3HM,EAAsB,UAA+B,CAClDD,IAGLA,EAAiB,WAAU,EACvBne,EAAM,QAAU,CAACA,EAAM,QACzBA,EAAM,WAAW,IAAI,SAAUoY,EAAW,CACxC+F,EAAiB,QAAQ/F,EAAW,CAClC,QAAS,GACT,UAAW,EACrB,CAAS,CACT,CAAO,EAEP,EAME,OAAAqB,EAAO,CACL,IAAI,QAAS,CACX,OAAOzZ,EAAM,MACd,EACD,IAAI,QAAS,CACX,OAAOA,EAAM,MACd,EACD,SAAU,SAAkBqe,EAAiB,CAC3C,GAAIre,EAAM,OACR,OAAO,KAET,IAAIse,EAAa5D,EAAU2D,EAAiB,YAAY,EACpDE,EAAiB7D,EAAU2D,EAAiB,gBAAgB,EAC5DG,EAAoB9D,EAAU2D,EAAiB,mBAAmB,EACjEG,GACHjD,IAEFvb,EAAM,OAAS,GACfA,EAAM,OAAS,GACfA,EAAM,4BAA8B1R,EAAI,cACxCgwB,GAAe,MAAyCA,IACxD,IAAIG,EAAmB,UAA4B,CAC7CD,GACFjD,IAEFqC,IACAQ,IACAG,GAAmB,MAA6CA,GACxE,EACM,OAAIC,GACFA,EAAkBxe,EAAM,WAAW,OAAM,CAAE,EAAE,KAAKye,EAAkBA,CAAgB,EAC7E,OAETA,IACO,KACR,EACD,WAAY,SAAoBC,EAAmB,CACjD,GAAI,CAAC1e,EAAM,OACT,OAAO,KAET,IAAItM,EAAUolB,GAAe,CAC3B,aAAc/X,EAAO,aACrB,iBAAkBA,EAAO,iBACzB,oBAAqBA,EAAO,mBAC7B,EAAE2d,CAAiB,EACpB,aAAa1e,EAAM,sBAAsB,EACzCA,EAAM,uBAAyB,OAC/B6d,IACA7d,EAAM,OAAS,GACfA,EAAM,OAAS,GACfoe,IACA7E,GAAiB,eAAeC,EAAWC,CAAI,EAC/C,IAAIkF,EAAejE,EAAUhnB,EAAS,cAAc,EAChDkrB,EAAmBlE,EAAUhnB,EAAS,kBAAkB,EACxDmrB,EAAsBnE,EAAUhnB,EAAS,qBAAqB,EAC9DorB,EAAcpE,EAAUhnB,EAAS,cAAe,yBAAyB,EAC7EirB,GAAiB,MAA2CA,IAC5D,IAAII,EAAqB,UAA8B,CACrD9E,GAAM,UAAY,CACZ6E,GACF9C,EAASC,EAAmBjc,EAAM,2BAA2B,CAAC,EAEhE4e,GAAqB,MAA+CA,GAC9E,CAAS,CACT,EACM,OAAIE,GAAeD,GACjBA,EAAoB5C,EAAmBjc,EAAM,2BAA2B,CAAC,EAAE,KAAK+e,EAAoBA,CAAkB,EAC/G,OAETA,IACO,KACR,EACD,MAAO,SAAeC,EAAc,CAClC,GAAIhf,EAAM,QAAU,CAACA,EAAM,OACzB,OAAO,KAET,IAAIif,EAAUvE,EAAUsE,EAAc,SAAS,EAC3CE,EAAcxE,EAAUsE,EAAc,aAAa,EACvD,OAAAhf,EAAM,OAAS,GACfif,GAAY,MAAsCA,IAClDpB,IACAO,IACAc,GAAgB,MAA0CA,IACnD,IACR,EACD,QAAS,SAAiBC,EAAgB,CACxC,GAAI,CAACnf,EAAM,QAAU,CAACA,EAAM,OAC1B,OAAO,KAET,IAAIof,EAAY1E,EAAUyE,EAAgB,WAAW,EACjDE,EAAgB3E,EAAUyE,EAAgB,eAAe,EAC7D,OAAAnf,EAAM,OAAS,GACfof,GAAc,MAAwCA,IACtD7D,IACAqC,IACAQ,IACAiB,GAAkB,MAA4CA,IACvD,IACR,EACD,wBAAyB,SAAiCC,EAAmB,CAC3E,IAAIC,EAAkB,CAAA,EAAG,OAAOD,CAAiB,EAAE,OAAO,OAAO,EACjE,OAAAtf,EAAM,WAAauf,EAAgB,IAAI,SAAU5lB,EAAS,CACxD,OAAO,OAAOA,GAAY,SAAWrL,EAAI,cAAcqL,CAAO,EAAIA,CAC1E,CAAO,EACGqG,EAAM,QACRub,IAEF6C,IACO,IACR,CACL,EAGE3E,EAAK,wBAAwB5T,CAAQ,EAC9B4T,CACT,EC94BO,SAASe,GAAgBzZ,EAAS,GAAI,CACzC,IAAI0Y,EACJ,KAAM,CAAE,UAAA+F,EAAW,GAAGC,CAAgB,EAAK1e,EACrC2e,EAAW7f,GAAS,EAAK,EACzB8f,EAAW9f,GAAS,EAAK,EACzB+f,EAAY3M,GAASwG,GAAA,YAAAA,EAAM,SAASxG,GACpC4M,EAAc5M,GAAS,CACzBwG,GAAA,MAAAA,EAAM,WAAWxG,EACzB,EACU6M,EAAQ,IAAM,CACZrG,IACAA,EAAK,MAAK,EACVkG,EAAS,IAAI,EAAI,EAE7B,EACUI,EAAU,IAAM,CACdtG,IACAA,EAAK,QAAO,EACZkG,EAAS,IAAI,EAAK,EAE9B,EAuBI,MAAO,CACH,aAvBkBpqB,IAClBkkB,EAAOuG,GAAiBzqB,EAAM,CAC1B,GAAGkqB,EACH,YAAa,OACTC,EAAS,IAAI,EAAI,GACjBte,EAAAL,EAAO,aAAP,MAAAK,EAAA,KAAAL,EACH,EACD,cAAe,OACX2e,EAAS,IAAI,EAAK,GAClBte,EAAAL,EAAO,eAAP,MAAAK,EAAA,KAAAL,EACH,CACb,CAAS,EACGye,GACAI,IAEG,CACH,SAAU,CACNC,IACApG,EAAO,MACV,CACb,GAIQ,SAAUwG,GAASP,CAAQ,EAC3B,SAAUO,GAASN,CAAQ,EAC3B,SAAAC,EACA,WAAAC,EACA,MAAAC,EACA,QAAAC,CACR,CACA,CCvDA,MAAMjN,GAAgB,CAClB,SAAU,CAAE,EACZ,UAAW,CAAE,EACb,aAAc,CAAE,EAChB,cAAe,CAAE,EACjB,OAAQ,MACZ,EACaoN,GAAY,CAACC,EAAezrB,IAAS,CAC9CyrB,EAAc,QAAQ,QAAU,GAChC,KAAM,CAAE,cAAAC,EAAe,KAAAzhB,EAAM,QAAAjL,CAAO,EAAKgB,EACzC,GAAI,CAAC0rB,GAAiB,CAACzhB,GAAQ,CAACjL,EAC5B,MAAO,CAAE,QAASoF,IAEtB,MAAMma,EAAO,CAAE,GAAGH,GAAe,GAAGpf,CAAO,EACrCwG,EAAY,CAAA,EAClB,GAAI+Y,EAAK,SAAW,KAAM,CACtB,MAAMoN,EAASC,GAAUH,EAAelN,EAAK,MAAM,EAC/CoN,GAAA,MAAAA,EAAQ,SACRnmB,EAAU,KAAKmmB,EAAO,OAAO,CAEpC,CAED,GADAnmB,EAAU,KAAK8Y,GAAYoN,EAAeD,EAAelN,EAAK,QAAQ,EAAE,OAAO,EAC3EA,EAAK,YAAc,KAAM,CACzB,KAAM,CAAE,aAAAsN,CAAc,EAAG/F,GAAgB,CACrC,UAAW,GACX,kBAAmB,GACnB,kBAAmB,GACnB,wBAAyB,GACzB,cAAe2F,EACf,GAAGlN,EAAK,SACpB,CAAS,EACKuN,EAAgBD,EAAaJ,CAAa,EAC5CK,GAAA,MAAAA,EAAe,SACftmB,EAAU,KAAKsmB,EAAc,OAAO,CAE3C,CACGvN,EAAK,eAAiB,MACtB/Y,EAAU,KAAK4G,GAAgBqf,EAAe,CAC1C,QAASxhB,EACT,QAAUsC,GAAM,CACRA,EAAE,kBAEFvH,GAAc0mB,CAAa,GAAK,CAACA,EAAc,SAASnf,EAAE,MAAM,IAChEtC,EAAK,IAAI,EAAK,EACdyhB,EAAc,MAAK,EAE1B,EACD,GAAGnN,EAAK,YACpB,CAAS,EAAE,OAAO,EAEVA,EAAK,gBAAkB,MACvB/Y,EAAU,KAAKsH,GAAiB2e,EAAe,CAC3C,QAASxhB,EACT,QAAUsC,GAAM,CACRA,EAAE,kBAENtC,EAAK,IAAI,EAAK,CACjB,EACD,GAAGsU,EAAK,aACpB,CAAS,EAAE,OAAO,EAEd,MAAM5T,EAAcpF,GAAiB,GAAGC,CAAS,EACjD,MAAO,CACH,SAAU,CACNmF,GACH,CACT,CACA,ECnEaihB,GAAY,CAACnlB,EAAIjD,EAAS,SAAW,CAC9C,IAAIuoB,EACJ,GAAI,CAAC/mB,GAAcxB,CAAM,GAAK,OAAOA,GAAW,SAC5C,MAAO,CACH,QAASY,EACrB,EAEI,eAAelP,EAAO82B,EAAW,CAE7B,GADAxoB,EAASwoB,EACL,OAAOxoB,GAAW,UAMlB,GALAuoB,EAAW,SAAS,cAAcvoB,CAAM,EACpCuoB,IAAa,OACb,MAAME,GAAI,EACVF,EAAW,SAAS,cAAcvoB,CAAM,GAExCuoB,IAAa,KACb,MAAM,IAAI,MAAM,4CAA4CvoB,CAAM,GAAG,UAGpEA,aAAkB,YACvBuoB,EAAWvoB,MAGX,OAAM,IAAI,UAAU,+BAA+BA,IAAW,KAAO,OAAS,OAAOA,CAAM,wDAAwD,EAEvJiD,EAAG,QAAQ,OAAS,GACpBslB,EAAS,YAAYtlB,CAAE,EACvBA,EAAG,OAAS,EACf,CACD,SAASylB,GAAU,CACfzlB,EAAG,OAAM,CACZ,CACD,OAAAvR,EAAOsO,CAAM,EACN,CACH,OAAAtO,EACA,QAAAg3B,CACR,CACA,ECtCO,SAASC,IAAc,CAa1B,MAAO,CACH,SAAU,CACN,KAdKtoB,GAAQ,QAAS,CAC1B,OAAShD,IAME,CACH,QANckF,GAAqBlF,EAAM,YAAc0L,GAAM,CACzD,CAACA,EAAE,kBAAoBA,EAAE,OAAS,GAClCA,EAAE,eAAc,CAEpC,CAAa,CAGb,EAEA,CAAK,CAII,CACT,CACA,CCXO,MAAM6f,GAAmB,CAAC1kB,EAAI,WAAYA,EAAI,OAAQA,EAAI,YAAaA,EAAI,MAAOA,EAAI,UAAWA,EAAI,QAASA,EAAI,IAAKA,EAAI,KAAMA,EAAI,MAAOA,EAAI,GAAIA,EAAI,GAAIA,EAAI,GAAIA,EAAI,GAAIA,EAAI,GAAIA,EAAI,GAAIA,EAAI,GAAIA,EAAI,GAAIA,EAAI,GAAIA,EAAI,IAAKA,EAAI,IAAKA,EAAI,GAAG,EAC9O2kB,GAAW,CACb,YAAa,CACT,UAAW,SACX,UAAW,EACd,EACD,gBAAiB,UACjB,KAAM,GACN,YAAa,GACb,oBAAqB,GACrB,cAAe,GACf,cAAe,GACf,aAAc,GACd,OAAQ,OACR,eAAgB,IAAM,GACtB,SAAU,CACd,EACM,CAAE,KAAAj1B,GAAM,SAAAwN,EAAQ,EAAKJ,GAAgB,UAAU,EAQ9C,SAAS8nB,GAAeC,EAAO,QAClC,MAAMC,EAAe,CAAE,GAAGH,GAAU,GAAGE,CAAK,EAEtCpiB,EAAgBgB,GAAS,IAAI,EAE7BshB,EAAkBthB,GAAS,IAAI,EAC/BuhB,EAAmBF,EAAa,UAClCrhB,GAASqhB,EAAa,eAAe,EACnCG,EAAWhmB,GAAY+lB,EAAkBF,GAAA,YAAAA,EAAc,gBAAgB,EAEvEI,EAAa5hB,KAAa0B,GAAA8f,EAAa,kBAAb,YAAA9f,GAA8B,QAAS,GAAI8f,EAAa,QAAQ,EAE1FK,EAAeL,EAAa,MAAQrhB,GAAS,EAAK,EAElDlB,EAAOtD,GAAYkmB,EAAcL,GAAA,YAAAA,EAAc,YAAY,EAC3DM,EAAU3hB,GAAS,EAAK,EACxBnM,EAAUyM,GAAiB/E,GAAK8lB,EAAc,OAAQ,cAAe,UAAU,CAAC,EAChF,CAAE,gBAAAO,EAAiB,KAAAlqB,EAAM,eAAAmqB,EAAgB,oBAAAC,EAAqB,cAAAC,EAAe,cAAAC,EAAe,OAAAxB,EAAQ,aAAAzhB,EAAc,YAAAkjB,CAAW,EAAMpuB,EACnIquB,EAAeriB,GAAa,GAAOwhB,EAAa,QAAQ,EACxDc,EAAM,CACR,MAAO7lB,GAAY,EACnB,KAAMA,GAAY,EAClB,MAAOA,GAAY,CAC3B,EAII,SAAS8lB,EAAe9mB,EAAI,CACxB,MAAMvQ,EAAQuQ,EAAG,aAAa,YAAY,EACpC+mB,EAAQ/mB,EAAG,aAAa,YAAY,EACpCpB,EAAWoB,EAAG,aAAa,eAAe,EAChD,MAAO,CACH,MAAOvQ,GAAQ,KAAK,MAAMA,CAAK,EAC/B,MAAOs3B,GAAS/mB,EAAG,aAAe,OAClC,SAAU,EAAApB,CACtB,CACK,CAED,SAAS2L,GAAQ,OACS5Y,GAAIu0B,CAAQ,EAM9BC,EAAW,MAAIx0B,EAAAA,GAAIu0B,CAAQ,IAAZv0B,YAAAA,EAAe,QAAS,EAAE,EAHzCw0B,EAAW,IAAI,EAAE,EAKrBS,EAAa,IAAI,EAAK,CACzB,CAKD,SAASI,EAAW3zB,EAAM,CACtB,MAAMyyB,EAAQgB,EAAezzB,CAAI,EACjC6yB,EAAS,IAAIJ,CAAK,EAClB,MAAMpiB,EAAgB,SAAS,eAAemjB,EAAI,KAAK,EACnDnjB,GACAA,EAAc,MAAK,CAE1B,CACD,eAAeujB,GAAgB,CAC3B,GAAI,CAAC7oB,GACD,OACJ,MAAMonB,GAAI,EACV,MAAM0B,EAAc,SAAS,eAAeL,EAAI,IAAI,EACpD,GAAI,CAACtoB,GAAc2oB,CAAW,EAC1B,OACYnnB,GAAWmnB,CAAW,EACP,OAAQC,GAE5B,EADUA,EAAI,QAAQ,SAAW,OAE3C,EACmB,OAIhBd,EAAQ,IAAI,EAAK,EAHjBA,EAAQ,IAAI,EAAI,CAKvB,CAMD,eAAee,EAASC,EAAmB,GAAO,CAOzCA,GACD7jB,EAAK,IAAI,EAAI,EAEjB,MAAM8jB,EAAY,SAAS,eAAeT,EAAI,KAAK,EACnD,GAAI,CAACS,EACD,OAEJ5jB,EAAc,IAAI4jB,CAAS,EAE3B,MAAM9B,GAAI,EACV,MAAM0B,EAAc,SAAS,eAAeL,EAAI,IAAI,EACpD,GAAI,CAACtoB,GAAc2oB,CAAW,EAC1B,OACJ,MAAMK,EAAeL,EAAY,cAAc,sBAAsB,EAChE3oB,GAAcgpB,CAAY,GAE/BvB,EAAgB,IAAIuB,CAAY,CACnC,CAED,SAASC,GAAY,CACjBhkB,EAAK,IAAI,EAAK,EACdojB,EAAa,IAAI,EAAK,CACzB,CAMD,MAAMa,EAAYlkB,GAAe,CAAE,KAAAC,EAAM,aAAAC,EAAc,cAAAC,CAAa,CAAE,EAKhEgkB,EAAajqB,GAAQ,CAACyoB,CAAQ,EAAG,CAAC,CAACyB,CAAM,IACnCt0B,GAASu0B,GAAUD,GAAA,YAAAA,EAAQ,MAAOt0B,CAAI,CACjD,EAKK2qB,EAAQ5gB,GAAQzM,GAAK,OAAO,EAAG,CACjC,OAAQ,CAAC6S,EAAMwiB,EAAiBG,CAAU,EAC1C,SAAU,CAAC,CAACxiB,EAAOkkB,EAAkBC,CAAW,KACrC,CACH,wBAAyBD,GAAA,YAAAA,EAAkB,GAC3C,oBAAqB,OACrB,gBAAiBhB,EAAI,KACrB,gBAAiBljB,EACjB,kBAAmBkjB,EAAI,MACvB,aAAc,MACd,GAAIA,EAAI,MACR,KAAM,WACN,MAAOiB,EAAY,KACnC,GAEQ,OAAS1tB,GAAS,CACd,MAAM8J,EAAcpF,GAAiBQ,GAAqBlF,EAAM,QAAS,IAAM,CAC3E,MAAMuJ,EAAQhS,GAAI6R,CAAI,EAClBG,GAGJyjB,EAASzjB,CAAK,CAC9B,CAAa,EAEDrE,GAAqBlF,EAAM,UAAY0L,GAAM,CACzC,MAAMnC,EAAQhS,GAAI6R,CAAI,EAItB,GAAI,CAACG,EAAO,CAUR,GARIgiB,GAAiB,SAAS7f,EAAE,GAAG,GAI/BA,EAAE,MAAQ7E,EAAI,KAId6E,EAAE,MAAQ7E,EAAI,WAAa7G,EAAK,QAAU,GAC1C,OAGJgtB,EAASzjB,CAAK,EACd6hB,GAAI,EAAG,KAAK,IAAM,CAEd,GADsB7zB,GAAIu0B,CAAQ,EAE9B,OACJ,MAAM6B,EAAS,SAAS,eAAelB,EAAI,IAAI,EAC/C,GAAI,CAACtoB,GAAcwpB,CAAM,EACrB,OACJ,MAAMC,EAAe,MAAM,KAAKD,EAAO,iBAAiB,GAAG5pB,GAAS,MAAM,CAAC,0CAA0C,CAAC,EAAE,OAAQ9K,IAASkL,GAAclL,EAAI,CAAC,EACvJ20B,EAAa,SAEdliB,EAAE,MAAQ7E,EAAI,WACd+kB,EAAgB,IAAIgC,EAAa,CAAC,CAAC,EAE9BliB,EAAE,MAAQ7E,EAAI,UACnB+kB,EAAgB,IAAItpB,GAAKsrB,CAAY,CAAC,EAElE,CAAqB,CACJ,CAKD,GAAIliB,EAAE,MAAQ7E,EAAI,KAAO6E,EAAE,MAAQ7E,EAAI,OAAQ,CAC3CumB,IACAjd,IACA,MACH,CAED,GAAIzE,EAAE,MAAQ7E,EAAI,MAAO,CACrB,MAAM4mB,EAAmBl2B,GAAIq0B,CAAe,EACxC6B,GACAb,EAAWa,CAAgB,EAE/BL,GACH,CAOD,GALI1hB,EAAE,MAAQ7E,EAAI,UAAY6E,EAAE,SAC5B0hB,IACAjd,KAGAnJ,GAAgB,SAAS0E,EAAE,GAAG,EAAG,CACjCA,EAAE,eAAc,EAEhB,MAAMohB,EAAc,SAAS,eAAeL,EAAI,IAAI,EACpD,GAAI,CAACtoB,GAAc2oB,CAAW,EAC1B,OACJ,MAAMe,EAAeloB,GAAWmnB,CAAW,EAC3C,GAAI,CAACe,EAAa,OACd,OAEJ,MAAMC,EAAiBD,EAAa,OAAQd,IAAQ,CAACzoB,GAAkByoB,EAAG,GAAKA,GAAI,QAAQ,SAAW,MAAS,EAEzGgB,GAAex2B,GAAIq0B,CAAe,EAClCvpB,GAAe0rB,GAAeD,EAAe,QAAQC,EAAY,EAAI,GAErEC,GAAQz2B,GAAIyK,CAAI,EAChBisB,GAAmB12B,GAAI20B,CAAe,EAC5C,IAAIgC,GACJ,OAAQxiB,EAAE,IAAG,CACT,KAAK7E,EAAI,WACLqnB,GAAWpuB,GAAKguB,EAAgBzrB,GAAc2rB,EAAK,EACnD,MACJ,KAAKnnB,EAAI,SACLqnB,GAAW9rB,GAAK0rB,EAAgBzrB,GAAc2rB,EAAK,EACnD,MACJ,KAAKnnB,EAAI,UACLqnB,GAAWhsB,GAAQ4rB,EAAgBzrB,GAAc,GAAI2rB,EAAK,EAC1D,MACJ,KAAKnnB,EAAI,QACLqnB,GAAWrsB,GAAKisB,EAAgBzrB,GAAc,GAAI2rB,EAAK,EACvD,MACJ,KAAKnnB,EAAI,KACLqnB,GAAWJ,EAAe,CAAC,EAC3B,MACJ,KAAKjnB,EAAI,IACLqnB,GAAW5rB,GAAKwrB,CAAc,EAC9B,MACJ,QACI,MACP,CAEDlC,EAAgB,IAAIsC,EAAQ,EAC5BA,GAAS,eAAe,CAAE,MAAOD,EAAkB,CAAA,CACtD,CACjB,CAAa,EAED/oB,GAAqBlF,EAAM,QAAU0L,GAAM,CACvC,GAAI,CAACrH,GAAmBqH,EAAE,MAAM,EAC5B,OACJ,MAAMrW,EAAQqW,EAAE,OAAO,MACvBqgB,EAAW,aAAa12B,CAAK,EAC7Bm3B,EAAa,aAAa,EAAI,EAC9BpB,GAAI,EAAG,KAAK,IAAM,CACd,MAAMqC,EAAmBl2B,GAAIq0B,CAAe,EAC5C,GAAI6B,GAAA,MAAAA,EAAkB,QAAQ,OAAQ,CAElC,MAAMX,EAAc,SAAS,eAAeL,EAAI,IAAI,EACpD,GAAI,CAACtoB,GAAc2oB,CAAW,EAC1B,OAEJ,MAAMgB,GADenoB,GAAWmnB,CAAW,EACP,OAAQC,IAAQ,CAACzoB,GAAkByoB,EAAG,GAAK,CAACA,GAAI,QAAQ,MAAM,EAClGnB,EAAgB,IAAIkC,GAAe,CAAC,GAAK,IAAI,CAChD,CACrB,CAAiB,CACJ,CAAA,CAAC,EACF,IAAIK,EAAqB5qB,GACzB,OAAA2G,GAAOd,EAAOG,GAAU,CAChBA,EACA6hB,GAAI,EAAG,KAAK,IAAM,CACd,MAAMgD,EAASniB,GAAiBjM,EAAM,CAClC,QAAS,IAAM,CACXotB,IACAjd,GACH,CAC7B,CAAyB,EACGie,GAAUA,EAAO,UACjBD,EAAqBC,EAAO,QAExD,CAAqB,EAGDD,GAEpB,CAAa,EACM,CACH,SAAU,CACNrkB,IACAqkB,GACH,CACjB,CACS,CACT,CAAK,EAIKE,EAAOrrB,GAAQzM,GAAK,MAAM,EAAG,CAC/B,OAAQ,CAAC82B,CAAS,EAClB,SAAU,CAAC,CAACiB,CAAU,KACX,CACH,OAAQA,EAAa,OAAY,GACjC,GAAI7B,EAAI,KACR,KAAM,UACN,MAAOnmB,GAAc,CAAE,QAASgoB,EAAa,OAAY,OAAQ,CACjF,GAEQ,OAAStuB,GAAS,CACd,IAAIuuB,EAAchrB,GACdirB,EAAcjrB,GAClB,MAAMuG,EAAcpF,GAEpBwF,GAAO,CAACmjB,EAAWf,EAAeD,EAAevB,EAAQsB,EAAqBG,CAAW,EAAG,CAAC,CAAC+B,EAAYG,EAAgBC,EAAgBC,EAASC,GAAsBC,MAAmB,CACxLN,IACAC,IACA,MAAM/kB,GAAiBlS,GAAI+R,CAAa,EAClCglB,GAAc7kB,KAEhBglB,IACAD,EAActmB,GAAY,GAE9BkjB,GAAI,EAAG,KAAK,IAAM,CACd,MAAM0D,GAASnE,GAAU3qB,EAAM,CAC3B,cAAeyJ,GACf,KAAAL,EACA,QAAS,CACL,SAAUylB,GACV,UAAW,KACX,aAAcD,GACR,CACE,QAAUljB,IAAM,CACGA,GAAE,SACFjC,KAEf2jB,IACAjd,IACH,CACJ,EACC,KACN,cAAeue,EACT,CACE,QAAS,IAAM,CACXtB,IACAjd,GACH,CACJ,EACC,KACN,OAAQlF,GAAqBjL,EAAM2uB,CAAO,CAC7C,CACzB,CAAqB,EACGG,IAAUA,GAAO,UACjBP,EAAcO,GAAO,QAE7C,CAAiB,EACjB,CAAa,EAED5pB,GAAqBlF,EAAM,eAAgB,IAAM,CAC7C4rB,EAAgB,IAAI,IAAI,CAC3B,CAAA,CAAC,EACF,MAAO,CACH,QAAS,IAAM,CACX9hB,IACAykB,IACAC,GACH,CACjB,CACS,CACT,CAAK,EAEK,CAAE,SAAU,CAAE,KAAMO,CAAc,CAAA,EAAMzD,KACxC,CAAE,OAAQ0D,CAAa,EAAGz3B,GAAIw3B,CAAY,EAC1CpC,EAAQ3pB,GAAQzM,GAAK,OAAO,EAAG,CACjC,SAAU,KACC,CACH,GAAIk2B,EAAI,MACR,IAAKA,EAAI,KACzB,GAEQ,OAAQuC,CAChB,CAAK,EACKC,EAASjsB,GAAQzM,GAAK,QAAQ,EAAG,CACnC,OAAQ,CAACu1B,EAAUK,EAAgBJ,EAAYS,CAAY,EAC3D,SAAU,CAAC,CAACe,EAAQ2B,EAAiBxB,EAAayB,CAAa,IAAOzD,GAAU,CAC5E,IAAI0D,EAAS,GACTD,EAAc,YACdD,GAAA,YAAAA,EAAkB,CAAE,MAAOxB,EAAY,UAAW,UAAWhC,EAAM,WAAa,KAChF0D,EAAS,IAEb,MAAMtD,EAAW0B,GAAU9B,EAAM,MAAO6B,CAAM,EAC9C,MAAO,CACH,aAAc,KAAK,UAAU7B,EAAM,KAAK,EACxC,aAAcA,EAAM,MACpB,gBAAiBA,EAAM,SAAW,GAAK,OACvC,gBAAiBA,EAAM,SAAW,GAAO,OACzC,gBAAiBI,EACjB,gBAAiBA,EAAW,GAAK,OACjC,OAAQsD,EAAS,GAAO,OACxB,cAAeA,EAAS,GAAK,OAC7B,GAAIxoB,GAAY,EAChB,KAAM,SACN,MAAON,GAAc,CAAE,OAAQolB,EAAM,SAAW,UAAY,UAAW,CACvF,CACS,EACD,OAAS1rB,IAqBE,CAAE,QApBW0E,GAEpBQ,GAAqBlF,EAAM,cAAe,IAAM,CAE5C,GAAIsE,GAAkBtE,CAAI,EAAG,CACzB4rB,EAAgB,IAAI,IAAI,EACxB,MACH,CAEDA,EAAgB,IAAI5rB,CAAI,CAC3B,CAAA,EAAGkF,GAAqBlF,EAAM,QAAU0L,GAAM,CAE3C,GAAIpH,GAAkBtE,CAAI,EAAG,CACzB0L,EAAE,eAAc,EAChB,MACH,CAEDkhB,EAAW5sB,CAAI,EACfotB,GACH,CAAA,CAAC,GAGd,CAAK,EAID,OAAAiC,GAAQ,IAAM,CAEV,GADAjmB,EAAK,IAAIuiB,EAAa,WAAW,EAC7B,CAAC3nB,GACD,OACJ,MAAM2pB,EAAS,SAAS,eAAelB,EAAI,IAAI,EAC/C,GAAI,CAACkB,EACD,OACJ,MAAMT,EAAY,SAAS,eAAeT,EAAI,KAAK,EAC/CS,GACA5jB,EAAc,IAAI4jB,CAAS,EAE/B,MAAMoC,EAAa3B,EAAO,cAAc,iBAAiB,EACzD,GAAI,CAACxpB,GAAcmrB,CAAU,EACzB,OACJ,MAAMC,EAAYD,EAAW,aAAa,YAAY,EACtDvD,EAAW,aAAawD,GAAaD,EAAW,aAAe,EAAE,CACzE,CAAK,EACDplB,GAAO4hB,EAAU,SAAuB0D,EAAW,CAC/CzD,EAAW,cAAayD,GAAA,YAAAA,EAAW,QAAS,EAAE,CACtD,CAAK,EAKDtlB,GAAO,CAAC0hB,EAAiBM,CAAe,EAAG,CAAC,CAACuB,EAAkBQ,CAAgB,IAAM,CACjF,GAAI,CAACjqB,GACD,OACJ,MAAM8oB,EAAc,SAAS,eAAeL,EAAI,IAAI,EAC/CtoB,GAAc2oB,CAAW,IAE9BnnB,GAAWmnB,CAAW,EAAE,QAAS9sB,GAAS,CAClCA,IAASytB,EACThoB,GAAazF,CAAI,EAGjB0F,GAAgB1F,CAAI,CAEpC,CAAS,EACGytB,GACArnB,GAAM,CAAC,EAAE,KAAK,IAAMqnB,EAAiB,eAAe,CAAE,MAAOQ,CAAkB,CAAA,CAAC,EAE5F,CAAK,EACD/jB,GAAO,CAAC6hB,EAAYS,CAAY,EAAG,IAAM,CACrCK,GACR,CAAK,EACM,CACH,SAAU,CACN,MAAAjJ,EACA,OAAAqL,EACA,KAAAZ,EACA,MAAA1B,CACH,EACD,OAAQ,CACJ,KAAAvjB,EACA,SAAA0iB,EACA,WAAYC,EACZ,QAASrB,GAASuB,CAAO,CAC5B,EACD,QAAS,CACL,WAAAqB,CACH,EACD,QAAAnvB,CACR,CACA,CChgBO,MAAMsxB,GAAuBC,GAAc,MAAM,0DC0BbC,EAAO,CAAA,EAAA,CAC9B,MAAOA,EAAM,EAAA,EAAC,KACd,MAAOA,EAAM,EAAA,EAAC,KAAK,MAAQ,GAC3B,SAAU,gDAJfC,EAAY,CAAA,CAAA,uBAAjB,OAAI,GAAA,oNAACA,EAAY,CAAA,CAAA,oBAAjB,OAAIp7B,GAAA,EAAA,2HAAJ,0QAYUq7B,EAAqCltB,EAAAmtB,EAAAC,CAAA,+PAFrCF,EAAwCltB,EAAAmtB,EAAAC,CAAA,6CAKvCH,EAAM,EAAA,EAAC,KAAK,KAAI,2BANhB,GAAAA,EAAO,EAAA,EAAA,KAAK,OAAS,aAAY,OAAAI,GAE5B,GAAAJ,EAAO,EAAA,EAAA,KAAK,OAAS,UAAS,OAAAK,2BAJpCL,EAAoB,EAAA,CAAA,iWAD5BC,EAWKltB,EAAAutB,EAAAH,CAAA,wBAHDI,EAEMD,EAAAE,CAAA,4HADDR,EAAM,EAAA,EAAC,KAAK,KAAI,KAAAS,GAAAC,EAAAC,CAAA,qBARjBX,EAAoB,EAAA,CAAA,CAAA,CAAA,oFAb/BY,EAAAZ,KAAI,OAAM,EAAA,oBADJA,EAAM,CAAA,EAAA,CAAA,IAAA,UAAA,CAAA,MAAA,iBAAA,CAAA,0GAGuCA,EAAM,CAAA,uDAGzDA,EAAI,EAAA,GAAAa,GAAAb,CAAA,6BADiBA,EAAK,CAAA,CAAA,mfANnCC,EAKMltB,EAAAytB,EAAAL,CAAA,EAJFI,EAEQC,EAAAM,CAAA,gBACRP,EAAoFC,EAAAO,CAAA,kCAExFd,EAsBKltB,EAAAiuB,EAAAb,CAAA,kGA1BIc,EAAA,GAAAL,KAAAA,EAAAZ,KAAI,OAAM,EAAA,KAAAkB,GAAAC,EAAAP,EAAAQ,EAAA,eAAA,oBADJpB,EAAM,CAAA,4IAGuCA,EAAM,CAAA,8BAGzDA,EAAI,EAAA,GAAAqB,EAAA,EAAArB,EAAAiB,CAAA,6CADiBjB,EAAK,CAAA,CAAA,CAAA,CAAA,yKAhDxB,YAAAsB,CAAW,EAAAC,GACX,SAAAC,CAAQ,EAAAD,EACb,MAAAx5B,MAAY8I,GAAI,IAEfywB,EAAY,IAAKhR,QACfA,EACH,KAAM,YAAW,EAAA,KAEhBkR,EAAS,IAAKC,QACZA,EACH,KAAM,SAAQ,EAAA,GAIhB,CAAA,eAAgB,GAChB,MAAO,MAAM,CAAA,CAAA,EAIf,CAAA,SAAY,CAAA,KAAAhD,EAAM,MAAAzK,EAAO,OAAAqL,EAAQ,MAAAtC,CACjC,EAAA,OAAU,CAAA,KAAAvjB,IACRqiB,GAAc,CAChB,aAAc,GACd,cAAe,GACf,oBAAqB,GACrB,iBAAgB,CAAA,CAAK,KAAAtlB,EAAM,KAAArG,KAAI,OACzB,KAAA+L,EAAA/L,GAAA,YAAAA,EAAM,QAAN,YAAA+L,EAAa,QAAS,aAAY,CACpC4jB,OAAS6B,CAAO,gBAAgBxxB,EAAK,MAAM,EAAE,EAAA,SAG3C,OAAAA,GAAA,MAAAA,EAAM,OACR,MAAM,yBAA2BA,EAAK,MAAM,IAAI,EAE3CA,oNAITyxB,EAAA,EAAAC,EAAe75B,EAAM,OAAO85B,EAAO,MACjC,CAAA,MAAO,CAAA,CAAA,CAAA,2KC2BgB,MAAAC,EAAA/B,EAAa,CAAA,IAAA,KAAO,KAAO,uKA9BnB+B,EAAA/B,KAAYA,EAAU,EAAA,CAAA,wDAChC,OAAAC,QAAS,QAAOI,2TAGTh7B,GAAa46B,EAAU,EAAA,EAAC,EAAE,EAAA+B,CAAA,iKAA1B38B,GAAa46B,EAAU,EAAA,EAAC,EAAE,IAAAgC,GAAAC,EAAAF,CAAA,6EAFjC,IAAAG,EAAAlC,KAAI,MAAK,EAAA,gEAATiB,EAAA,GAAAiB,KAAAA,EAAAlC,KAAI,MAAK,EAAA,KAAAS,GAAA0B,EAAAD,CAAA,uFAKLlC,EAAS,EAAA,EAAA,6BAAC,KACf,yBADe,KACf,gDADKA,EAAS,EAAA,EAAA,KAAAS,GAAAU,EAAAP,CAAA,wCAFT,IAAAsB,EAAAlC,KAAI,KAAI,EAAA,gEAARiB,EAAA,GAAAiB,KAAAA,EAAAlC,KAAI,KAAI,EAAA,KAAAS,GAAA0B,EAAAD,CAAA,2CAVdtB,EAAAZ,MAAW,KAAI,WAElBoC,EAAApC,MAAW,UAAS,OAAKqC,EAAArC,MAAW,WAAU,6BAEtC,OAAAa,+IAFa,KAAG,gRAAH,KAAG,4IAHrBb,EAAO,CAAA,EAAA,gBAAeA,EAAU,EAAA,EAAC,EAAE,wJADfsC,EAAAhC,EAAA,aAAAiC,EAAAvC,MAAW,IAAI,UAAlDC,EAqBKltB,EAAAutB,EAAAH,CAAA,EApBDI,EAEID,EAAAn4B,CAAA,EADAo4B,EAA8Bp4B,EAAA+3B,CAAA,gBAElCK,EAA+DD,EAAAkC,CAAA,8BAC/DjC,EAeMD,EAAAE,CAAA,6BAlBKS,EAAA,GAAAL,KAAAA,EAAAZ,MAAW,KAAI,KAAAS,GAAAU,EAAAP,CAAA,kBADfZ,EAAO,CAAA,EAAA,gBAAeA,EAAU,EAAA,EAAC,mBAGpCiB,EAAA,GAAAmB,KAAAA,EAAApC,MAAW,UAAS,KAAAS,GAAAgC,EAAAL,CAAA,EAAKnB,EAAA,GAAAoB,KAAAA,EAAArC,MAAW,WAAU,KAAAS,GAAAiC,EAAAL,CAAA,gBAJvBpB,EAAA,GAAAsB,KAAAA,EAAAvC,MAAW,sEA8BzCY,EAAAZ,KAAQ,KAAI,0JADDsC,EAAAhC,EAAA,aAAAiC,EAAAvC,KAAQ,IAAI,wCAA5BC,EAEKltB,EAAAutB,EAAAH,CAAA,wBADAc,EAAA,GAAAL,KAAAA,EAAAZ,KAAQ,KAAI,KAAAS,GAAAU,EAAAP,CAAA,EADDK,EAAA,GAAAsB,KAAAA,EAAAvC,KAAQ,kEAgBb2C,EAAAC,GAAa5C,EAAQ,CAAA,CAAA,EAAA,qNANpBA,EAAQ,CAAA,CAAA,yEAINsC,EAAAn6B,EAAA,WAAA06B,EAAA7C,OAAYA,EAAQ,CAAA,KAAQ,MAAS,EADjC8C,GAAA36B,EAAA,SAAA63B,OAAYA,EAAQ,CAAA,CAAA,UAJtCC,EAQIltB,EAAA5K,EAAAg4B,CAAA,0BADOc,EAAA,GAAA0B,KAAAA,EAAAC,GAAa5C,EAAQ,CAAA,CAAA,EAAA,KAAA+C,EAAA,EAAAJ,CAAA,kBANpB3C,EAAQ,CAAA,kBAINiB,EAAA,GAAA4B,KAAAA,EAAA7C,OAAYA,EAAQ,CAAA,KAAQ,gCADxB8C,GAAA36B,EAAA,SAAA63B,OAAYA,EAAQ,CAAA,CAAA,iDApDxCoC,EAAApC,KAAQ,YAAW,EAAA,OAAMqC,EAAArC,KAAI,MAAK,EAAA,SACpCgD,EAAAhD,EAAI,CAAA,EAAA,GAAK,CAAA,KAAM,OAAM,EAAA,eAMpBiD,EAAAjD,KAAI,YAAW,EAAA,aA4BfkD,EAAAlD,KAAI,SAAQ,EAAA,eAvCL,SAAA,MAAAmD,EAAAnD,KAAI,yBAQY,YAAAA,KAAK,YAAuB,SAAAA,KAAK,YAKlD,IAAAoD,EAAAh/B,GAAA47B,KAAK,WAAW,uBAArB,OAAIp7B,GAAA,qBA6BC,IAAAy+B,GAAAj/B,GAAA47B,KAAK,QAAQ,wBAAlB,OAAIp7B,GAAA,sBAQC,IAAA0+B,EAAAl/B,GAAA47B,KAAK,SAAS,uBAAnB,OAAIp7B,GAAA,iEA9CN,GAAC,aAAuB,IAAE,6aAA1B,GAAC,mBAAuB,IAAE,smBAHQ09B,EAAAiB,EAAA,UAAAC,EAAAxD,KAAI,MAAK,CAAA,mIAA3CO,EAAiD,SAAA,KAAAgD,CAAA,WAGrDtD,EAAgDltB,EAAA0wB,EAAAtD,CAAA,uCAChDF,EAAiCltB,EAAA0uB,EAAAtB,CAAA,kBAEjCF,EAEUltB,EAAA2wB,EAAAvD,CAAA,wBAEVF,EAA4BltB,EAAA4wB,EAAAxD,CAAA,kBAC5BF,EAyBKltB,EAAA6wB,EAAAzD,CAAA,4DAELF,EAAyBltB,EAAA8wB,EAAA1D,CAAA,kBAEzBF,EAMKltB,EAAA+wB,EAAA3D,CAAA,4DAELF,EAaMltB,EAAAytB,EAAAL,CAAA,mEA9DM,CAAA4D,GAAA9C,EAAA,IAAAkC,KAAAA,EAAAnD,KAAI,MAAK,wBACiB,CAAA+D,GAAA9C,EAAA,GAAAuC,KAAAA,EAAAxD,KAAI,MAAK,uBAGzC,CAAA+D,GAAA9C,EAAA,IAAAmB,KAAAA,EAAApC,KAAQ,YAAW,EAAA,KAAAS,GAAAgC,EAAAL,CAAA,GAAM,CAAA2B,GAAA9C,EAAA,IAAAoB,KAAAA,EAAArC,KAAI,MAAK,EAAA,KAAAS,GAAAiC,EAAAL,CAAA,GACpC,CAAA0B,GAAA9C,EAAA,IAAA+B,KAAAA,EAAAhD,EAAI,CAAA,EAAA,GAAK,CAAA,KAAM,MAAM,CAAA,EAAA,KAAAS,GAAAuD,EAAAhB,CAAA,gBAGG/B,EAAA,IAAAgD,EAAA,YAAAjE,KAAK,aAAuBiB,EAAA,IAAAgD,EAAA,SAAAjE,KAAK,qBAGxD,CAAA+D,GAAA9C,EAAA,IAAAgC,KAAAA,EAAAjD,KAAI,YAAW,EAAA,KAAAS,GAAAyD,EAAAjB,CAAA,QAETG,EAAAh/B,GAAA47B,KAAK,WAAW,oBAArB,OAAIp7B,GAAA,EAAA,mHAAJ,WA0BD,CAAAm/B,GAAA9C,EAAA,IAAAiC,KAAAA,EAAAlD,KAAI,SAAQ,EAAA,KAAAS,GAAA0D,EAAAjB,CAAA,OAGNG,GAAAj/B,GAAA47B,KAAK,QAAQ,qBAAlB,OAAIp7B,GAAA,EAAA,qHAAJ,eAQK0+B,EAAAl/B,GAAA47B,KAAK,SAAS,oBAAnB,OAAIp7B,GAAA,EAAA,mHAAJ,2MAxDG,SAAAg+B,GAAawB,EAAI,CACjB,OAAAA,EAAK,MAAM,EAAE,EAAE,IAAKC,GAAWA,EAAO,WAAW,CAAC,EAAI,GAAK,MAAM,EAAE,IAAKC,GAAc,OAAO,cAAcA,CAAS,CAAG,EAAA,KAAK,EAAE,2EAL5H,KAAAt6B,CAAI,EAAAu3B,EACT,MAAAgD,EAAev/B,GACZD,GAAiBC,EAAYE,IAAa,EAAM,OAAS","x_google_ignoreList":[0,1,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42]}