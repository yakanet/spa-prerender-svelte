{"version":3,"file":"navigation.6910295d.js","sources":["../../../../../../node_modules/.pnpm/svelte@4.2.0/node_modules/svelte/src/runtime/internal/await_block.js","../../../../../../node_modules/.pnpm/@sveltejs+kit@1.24.1_svelte@4.2.0_vite@4.4.9/node_modules/@sveltejs/kit/src/runtime/app/navigation.js"],"sourcesContent":["import { is_promise } from './utils.js';\nimport { check_outros, group_outros, transition_in, transition_out } from './transitions.js';\nimport { flush } from './scheduler.js';\nimport { get_current_component, set_current_component } from './lifecycle.js';\n\n/**\n * @template T\n * @param {Promise<T>} promise\n * @param {import('./private.js').PromiseInfo<T>} info\n * @returns {boolean}\n */\nexport function handle_promise(promise, info) {\n\tconst token = (info.token = {});\n\t/**\n\t * @param {import('./private.js').FragmentFactory} type\n\t * @param {0 | 1 | 2} index\n\t * @param {number} [key]\n\t * @param {any} [value]\n\t * @returns {void}\n\t */\n\tfunction update(type, index, key, value) {\n\t\tif (info.token !== token) return;\n\t\tinfo.resolved = value;\n\t\tlet child_ctx = info.ctx;\n\t\tif (key !== undefined) {\n\t\t\tchild_ctx = child_ctx.slice();\n\t\t\tchild_ctx[key] = value;\n\t\t}\n\t\tconst block = type && (info.current = type)(child_ctx);\n\t\tlet needs_flush = false;\n\t\tif (info.block) {\n\t\t\tif (info.blocks) {\n\t\t\t\tinfo.blocks.forEach((block, i) => {\n\t\t\t\t\tif (i !== index && block) {\n\t\t\t\t\t\tgroup_outros();\n\t\t\t\t\t\ttransition_out(block, 1, 1, () => {\n\t\t\t\t\t\t\tif (info.blocks[i] === block) {\n\t\t\t\t\t\t\t\tinfo.blocks[i] = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tcheck_outros();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tinfo.block.d(1);\n\t\t\t}\n\t\t\tblock.c();\n\t\t\ttransition_in(block, 1);\n\t\t\tblock.m(info.mount(), info.anchor);\n\t\t\tneeds_flush = true;\n\t\t}\n\t\tinfo.block = block;\n\t\tif (info.blocks) info.blocks[index] = block;\n\t\tif (needs_flush) {\n\t\t\tflush();\n\t\t}\n\t}\n\tif (is_promise(promise)) {\n\t\tconst current_component = get_current_component();\n\t\tpromise.then(\n\t\t\t(value) => {\n\t\t\t\tset_current_component(current_component);\n\t\t\t\tupdate(info.then, 1, info.value, value);\n\t\t\t\tset_current_component(null);\n\t\t\t},\n\t\t\t(error) => {\n\t\t\t\tset_current_component(current_component);\n\t\t\t\tupdate(info.catch, 2, info.error, error);\n\t\t\t\tset_current_component(null);\n\t\t\t\tif (!info.hasCatch) {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\t// if we previously had a then/catch block, destroy it\n\t\tif (info.current !== info.pending) {\n\t\t\tupdate(info.pending, 0);\n\t\t\treturn true;\n\t\t}\n\t} else {\n\t\tif (info.current !== info.then) {\n\t\t\tupdate(info.then, 1, info.value, promise);\n\t\t\treturn true;\n\t\t}\n\t\tinfo.resolved = /** @type {T} */ (promise);\n\t}\n}\n\n/** @returns {void} */\nexport function update_await_block_branch(info, ctx, dirty) {\n\tconst child_ctx = ctx.slice();\n\tconst { resolved } = info;\n\tif (info.current === info.then) {\n\t\tchild_ctx[info.value] = resolved;\n\t}\n\tif (info.current === info.catch) {\n\t\tchild_ctx[info.error] = resolved;\n\t}\n\tinfo.block.p(child_ctx, dirty);\n}\n","import { client_method } from '../client/singletons.js';\n\n/**\n * If called when the page is being updated following a navigation (in `onMount` or `afterNavigate` or an action, for example), this disables SvelteKit's built-in scroll handling.\n * This is generally discouraged, since it breaks user expectations.\n * @returns {void}\n */\nexport const disableScrollHandling = /* @__PURE__ */ client_method('disable_scroll_handling');\n\n/**\n * Returns a Promise that resolves when SvelteKit navigates (or fails to navigate, in which case the promise rejects) to the specified `url`.\n * For external URLs, use `window.location = url` instead of calling `goto(url)`.\n *\n * @type {(url: string | URL, opts?: {\n *   replaceState?: boolean;\n *   noScroll?: boolean;\n *   keepFocus?: boolean;\n *   invalidateAll?: boolean;\n *   state?: any\n * }) => Promise<void>}\n * @param {string | URL} url Where to navigate to. Note that if you've set [`config.kit.paths.base`](https://kit.svelte.dev/docs/configuration#paths) and the URL is root-relative, you need to prepend the base path if you want to navigate within the app.\n * @param {Object} [opts] Options related to the navigation\n * @param {boolean} [opts.replaceState] If `true`, will replace the current `history` entry rather than creating a new one with `pushState`\n * @param {boolean} [opts.noScroll] If `true`, the browser will maintain its scroll position rather than scrolling to the top of the page after navigation\n * @param {boolean} [opts.keepFocus] If `true`, the currently focused element will retain focus after navigation. Otherwise, focus will be reset to the body\n * @param {boolean} [invalidateAll] If `true`, all `load` functions of the page will be rerun. See https://kit.svelte.dev/docs/load#rerunning-load-functions for more info on invalidation.\n * @param {any} [opts.state] The state of the new/updated history entry\n * @returns {Promise<void>}\n */\nexport const goto = /* @__PURE__ */ client_method('goto');\n\n/**\n * Causes any `load` functions belonging to the currently active page to re-run if they depend on the `url` in question, via `fetch` or `depends`. Returns a `Promise` that resolves when the page is subsequently updated.\n *\n * If the argument is given as a `string` or `URL`, it must resolve to the same URL that was passed to `fetch` or `depends` (including query parameters).\n * To create a custom identifier, use a string beginning with `[a-z]+:` (e.g. `custom:state`) — this is a valid URL.\n *\n * The `function` argument can be used define a custom predicate. It receives the full `URL` and causes `load` to rerun if `true` is returned.\n * This can be useful if you want to invalidate based on a pattern instead of a exact match.\n *\n * ```ts\n * // Example: Match '/path' regardless of the query parameters\n * import { invalidate } from '$app/navigation';\n *\n * invalidate((url) => url.pathname === '/path');\n * ```\n * @type {(url: string | URL | ((url: URL) => boolean)) => Promise<void>}\n * @param {string | URL | ((url: URL) => boolean)} url The invalidated URL\n * @returns {Promise<void>}\n */\nexport const invalidate = /* @__PURE__ */ client_method('invalidate');\n\n/**\n * Causes all `load` functions belonging to the currently active page to re-run. Returns a `Promise` that resolves when the page is subsequently updated.\n * @type {() => Promise<void>}\n * @returns {Promise<void>}\n */\nexport const invalidateAll = /* @__PURE__ */ client_method('invalidate_all');\n\n/**\n * Programmatically preloads the given page, which means\n *  1. ensuring that the code for the page is loaded, and\n *  2. calling the page's load function with the appropriate options.\n *\n * This is the same behaviour that SvelteKit triggers when the user taps or mouses over an `<a>` element with `data-sveltekit-preload-data`.\n * If the next navigation is to `href`, the values returned from load will be used, making navigation instantaneous.\n * Returns a Promise that resolves when the preload is complete.\n *\n * @type {(href: string) => Promise<void>}\n * @param {string} href Page to preload\n * @returns {Promise<void>}\n */\nexport const preloadData = /* @__PURE__ */ client_method('preload_data');\n\n/**\n * Programmatically imports the code for routes that haven't yet been fetched.\n * Typically, you might call this to speed up subsequent navigation.\n *\n * You can specify routes by any matching pathname such as `/about` (to match `src/routes/about/+page.svelte`) or `/blog/*` (to match `src/routes/blog/[slug]/+page.svelte`).\n *\n * Unlike `preloadData`, this won't call `load` functions.\n * Returns a Promise that resolves when the modules have been imported.\n *\n * @type {(...urls: string[]) => Promise<void>}\n * @param {...string[]} urls\n * @returns {Promise<void>}\n */\nexport const preloadCode = /* @__PURE__ */ client_method('preload_code');\n\n/**\n * A navigation interceptor that triggers before we navigate to a new URL, whether by clicking a link, calling `goto(...)`, or using the browser back/forward controls.\n * Calling `cancel()` will prevent the navigation from completing. If the navigation would have directly unloaded the current page, calling `cancel` will trigger the native\n * browser unload confirmation dialog. In these cases, `navigation.willUnload` is `true`.\n *\n * When a navigation isn't client side, `navigation.to.route.id` will be `null`.\n *\n * `beforeNavigate` must be called during a component initialization. It remains active as long as the component is mounted.\n * @type {(callback: (navigation: import('@sveltejs/kit').BeforeNavigate) => void) => void}\n * @param {(navigation: import('@sveltejs/kit').BeforeNavigate) => void} callback\n * @returns {void}\n */\nexport const beforeNavigate = /* @__PURE__ */ client_method('before_navigate');\n\n/**\n * A lifecycle function that runs the supplied `callback` immediately before we navigate to a new URL.\n *\n * If you return a `Promise`, SvelteKit will wait for it to resolve before completing the navigation. This allows you to — for example — use `document.startViewTransition`. Avoid promises that are slow to resolve, since navigation will appear stalled to the user.\n *\n * If a function (or a `Promise` that resolves to a function) is returned from the callback, it will be called once the DOM has updated.\n *\n * `onNavigate` must be called during a component initialization. It remains active as long as the component is mounted.\n * @type {(callback: (navigation: import('@sveltejs/kit').OnNavigate) => import('../../types/internal.js').MaybePromise<(() => void) | void>) => void}\n * @param {(navigation: import('@sveltejs/kit').OnNavigate) => void} callback\n * @returns {void}\n */\nexport const onNavigate = /* @__PURE__ */ client_method('on_navigate');\n\n/**\n * A lifecycle function that runs the supplied `callback` when the current component mounts, and also whenever we navigate to a new URL.\n *\n * `afterNavigate` must be called during a component initialization. It remains active as long as the component is mounted.\n * @type {(callback: (navigation: import('@sveltejs/kit').AfterNavigate) => void) => void}\n * @param {(navigation: import('@sveltejs/kit').AfterNavigate) => void} callback\n * @returns {void}\n */\nexport const afterNavigate = /* @__PURE__ */ client_method('after_navigate');\n"],"names":["handle_promise","promise","info","token","update","type","index","key","value","child_ctx","block","needs_flush","i","group_outros","transition_out","check_outros","transition_in","flush","is_promise","current_component","get_current_component","set_current_component","error","update_await_block_branch","ctx","dirty","resolved","goto","client_method","onNavigate"],"mappings":"2KAWO,SAASA,EAAeC,EAASC,EAAM,CAC7C,MAAMC,EAASD,EAAK,MAAQ,CAAE,EAQ9B,SAASE,EAAOC,EAAMC,EAAOC,EAAKC,EAAO,CACxC,GAAIN,EAAK,QAAUC,EAAO,OAC1BD,EAAK,SAAWM,EAChB,IAAIC,EAAYP,EAAK,IACjBK,IAAQ,SACXE,EAAYA,EAAU,QACtBA,EAAUF,CAAG,EAAIC,GAElB,MAAME,EAAQL,IAASH,EAAK,QAAUG,GAAMI,CAAS,EACrD,IAAIE,EAAc,GACdT,EAAK,QACJA,EAAK,OACRA,EAAK,OAAO,QAAQ,CAACQ,EAAOE,IAAM,CAC7BA,IAAMN,GAASI,IAClBG,IACAC,EAAeJ,EAAO,EAAG,EAAG,IAAM,CAC7BR,EAAK,OAAOU,CAAC,IAAMF,IACtBR,EAAK,OAAOU,CAAC,EAAI,KAEzB,CAAO,EACDG,IAEN,CAAK,EAEDb,EAAK,MAAM,EAAE,CAAC,EAEfQ,EAAM,EAAC,EACPM,EAAcN,EAAO,CAAC,EACtBA,EAAM,EAAER,EAAK,MAAK,EAAIA,EAAK,MAAM,EACjCS,EAAc,IAEfT,EAAK,MAAQQ,EACTR,EAAK,SAAQA,EAAK,OAAOI,CAAK,EAAII,GAClCC,GACHM,GAED,CACD,GAAIC,EAAWjB,CAAO,EAAG,CACxB,MAAMkB,EAAoBC,IAiB1B,GAhBAnB,EAAQ,KACNO,GAAU,CACVa,EAAsBF,CAAiB,EACvCf,EAAOF,EAAK,KAAM,EAAGA,EAAK,MAAOM,CAAK,EACtCa,EAAsB,IAAI,CAC1B,EACAC,GAAU,CAIV,GAHAD,EAAsBF,CAAiB,EACvCf,EAAOF,EAAK,MAAO,EAAGA,EAAK,MAAOoB,CAAK,EACvCD,EAAsB,IAAI,EACtB,CAACnB,EAAK,SACT,MAAMoB,CAEP,CACJ,EAEMpB,EAAK,UAAYA,EAAK,QACzB,OAAAE,EAAOF,EAAK,QAAS,CAAC,EACf,EAEV,KAAQ,CACN,GAAIA,EAAK,UAAYA,EAAK,KACzB,OAAAE,EAAOF,EAAK,KAAM,EAAGA,EAAK,MAAOD,CAAO,EACjC,GAERC,EAAK,SAA6BD,CAClC,CACF,CAGO,SAASsB,EAA0BrB,EAAMsB,EAAKC,EAAO,CAC3D,MAAMhB,EAAYe,EAAI,QAChB,CAAE,SAAAE,CAAU,EAAGxB,EACjBA,EAAK,UAAYA,EAAK,OACzBO,EAAUP,EAAK,KAAK,EAAIwB,GAErBxB,EAAK,UAAYA,EAAK,QACzBO,EAAUP,EAAK,KAAK,EAAIwB,GAEzBxB,EAAK,MAAM,EAAEO,EAAWgB,CAAK,CAC9B,CCtEY,MAACE,EAAuBC,EAAc,MAAM,EAsF3CC,EAA6BD,EAAc,aAAa","x_google_ignoreList":[0,1]}